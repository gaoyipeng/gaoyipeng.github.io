---
title: 使用docker安装redis哨兵(sentinel)
date: 2020-02-11 11:27:51
tags: [Docker,Redis]
categories: [Docker,Redis]
description: 使用docker安装redis哨兵(sentinel)
---
上一节我们搭建了redis主从模式，实现了redis的主从复制，读写分离。主从模式保证了数据备份，但是发生故障依然需要运维人员施工。为了解决主从模式的弊端，本节我们搭建redis哨兵模式。

本节我们搭建一主二从三哨兵。

## redis哨兵模式
sentinel 通常翻译成哨兵，用来监控主从节点的健康情况。客户端连接redis主从的时候，先连接 sentinel，sentinel告诉客户端<font color=red>主redis</font>的地址是多少，然后客户端连接上redis并进行后续的操作。

当主节点挂掉的时候，客户端就得不到连接了因而报错了，客户端重新向sentinel询问主master的地址，然后客户端得到了<font color=red>新选举出来的主redis</font>。当原来的主机恢复后，会将其作为新主的从机。

我们直接在上一节的已经搭建好的主从基础上搭建redis哨兵模式，上一节的主从模式节点信息如下：

|角色|端口|密码|容器名称|
|:---|:---:|---:|---:|
|master |6380  |123456 |redis-6380|
|slaver |6381  |123456 |redis-6381|
|slaver |6382  |123456 |redis-6382|

各容器network信心如下：
```
 "Containers": {
    "3729ea952faade7c3bf37467f00f8a8c6676b9a98e27a897582272f1edce2087": {
        "Name": "redis-6382",
        "EndpointID": "95f9a05d2b6d10c13eb3d8df706a2700f33a6704ddda290bc6840676eebc6676",
        "MacAddress": "02:42:ac:14:00:04",
        "IPv4Address": "172.20.0.4/16",
        "IPv6Address": ""
    },
    "a7f4ccfa8e8aa87efb697f3ee5fef686e5138ebb0ad5faac282e7850d8cb176f": {
        "Name": "redis-6380",
        "EndpointID": "71af5cda52f5026aba9b4040890629d5ca560c2a7208b2bc7f0682a97a19d9bf",
        "MacAddress": "02:42:ac:14:00:02",
        "IPv4Address": "172.20.0.2/16",
        "IPv6Address": ""
    },
    "ff3d51f269c40912a21b2a8686078d963f292b32d32bce6dad089d9008377a36": {
        "Name": "redis-6381",
        "EndpointID": "405a1e61ea2afae2fca8b0ce31f6ac83b7c03440668b3f7ec42072a0ebff18e3",
        "MacAddress": "02:42:ac:14:00:03",
        "IPv4Address": "172.20.0.3/16",
        "IPv6Address": ""
    }
}
```

现在我们约定sentinel哨兵节点信息：

|名称|端口|
|:---|:---:|
|sentinel-26379 |26379  |
|sentinel-26380 |26380  |
|sentinel-26381 |26381  |

### 创建工作目录

```
mkdir -p /usr/local/redis/sentinel/sentinel-26379/conf
mkdir -p /usr/local/redis/sentinel/sentinel-26379/data

mkdir -p /usr/local/redis/sentinel/sentinel-26380/conf
mkdir -p /usr/local/redis/sentinel/sentinel-26380/data

mkdir -p /usr/local/redis/sentinel/sentinel-26381/conf
mkdir -p /usr/local/redis/sentinel/sentinel-26381/data
```
用来存放3个哨兵的配置文件及日志文件。

### 准备sentinel.conf

```
wget http://download.redis.io/redis-stable/sentinel.conf
```
将sentinel.conf复制3份，分别存放到这3个目录下，并修改对应内容：

* /usr/local/redis/sentinel/sentinel-26379/conf
```
dir /data
logfile "sentinel-26379.log"  # 修改日志文件的路径
sentinel monitor mymaster redis-6380 6379 2 # redis-6380表示 master 节点地址，最后一个2表示，两个sentinel判定master被动下线后，就进行failover(故障转移)
sentinel auth-pass mymaster 123456 # 设置master的密码
```
* /usr/local/redis/sentinel/sentinel-26380/conf
```
dir /data
logfile "sentinel-26380.log"  # 修改日志文件的路径
sentinel monitor mymaster redis-6380 6379 2 # redis-6380表示 master 节点地址，最后一个2表示，两个sentinel判定master被动下线后，就进行failover(故障转移)
sentinel auth-pass mymaster 123456 # 设置master的密码
```
* /usr/local/redis/sentinel/sentinel-26381/conf
```
dir /data
logfile "sentinel-26381.log"  # 修改日志文件的路径
sentinel monitor mymaster redis-6380 6379 2 # redis-6380表示 master 节点地址，最后一个2表示，两个sentinel判定master被动下线后，就进行failover(故障转移)
sentinel auth-pass mymaster 123456 # 设置master的密码
```

### 目录结构
```
[root@localhost sentinel]# tree
.
├── sentinel-26379
│   ├── conf
│   │   └── sentinel.conf
│   └── data
├── sentinel-26380
│   ├── conf
│   │   └── sentinel.conf
│   └── data
└── sentinel-26381
    ├── conf
    │   └── sentinel.conf
    └── data

9 directories, 3 files
```

### 创建sentinel容器

官网建议设置奇数个哨兵，这样才适合选举机制。
我们逐个执行下面的启动命令，并查看sentinel.conf文件的变化。

```
docker run -d -p 26379:26379 --name sentinel-26379 --net=redis-master-slaver \
-v /usr/local/redis/sentinel/sentinel-26379/conf/sentinel.conf:/etc/redis/sentinel.conf \
-v /usr/local/redis/sentinel/sentinel-26379/data:/data redis:5.0.7 \
redis-sentinel /etc/redis/sentinel.conf

docker run -d -p 26380:26379 --name sentinel-26380 --net=redis-master-slaver \
-v /usr/local/redis/sentinel/sentinel-26380/conf/sentinel.conf:/etc/redis/sentinel.conf \
-v /usr/local/redis/sentinel/sentinel-26380/data:/data redis:5.0.7 \
redis-sentinel /etc/redis/sentinel.conf

docker run -d -p 26381:26379 --name sentinel-26381 --net=redis-master-slaver \
-v /usr/local/redis/sentinel/sentinel-26381/conf/sentinel.conf:/etc/redis/sentinel.conf \
-v /usr/local/redis/sentinel/sentinel-26381/data:/data redis:5.0.7 \
redis-sentinel /etc/redis/sentinel.conf
```

我们启动sentinel-26379后，查看/usr/local/redis/sentinel/sentinel-26379/conf/sentinel.conf文件，有了这些变化：
````
sentinel myid 327716021d2b88790338b362173a34163a855e56
sentinel deny-scripts-reconfig yes
sentinel monitor mymaster 172.20.0.2 6379 2  #自动替换成了redis-6380的ip
sentinel config-epoch mymaster 0
sentinel leader-epoch mymaster 0
# Generated by CONFIG REWRITE
sentinel known-replica mymaster 172.20.0.4 6379
sentinel known-replica mymaster 172.20.0.3 6379
sentinel current-epoch 0
````
日志文件（/usr/local/redis/sentinel/sentinel-26379/data/sentinel-26379.log）：
```
[root@localhost data]# vim sentinel-26379.log 
1:X 12 Feb 2020 03:03:09.681 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo
1:X 12 Feb 2020 03:03:09.681 # Redis version=5.0.7, bits=64, commit=00000000, modified=0, pid=1, just started
1:X 12 Feb 2020 03:03:09.681 # Configuration loaded
1:X 12 Feb 2020 03:03:09.683 * Running mode=sentinel, port=26379.
1:X 12 Feb 2020 03:03:09.683 # WARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128.
1:X 12 Feb 2020 03:03:09.687 # Sentinel ID is 327716021d2b88790338b362173a34163a855e56
1:X 12 Feb 2020 03:03:09.687 # +monitor master mymaster 172.20.0.2 6379 quorum 2
1:X 12 Feb 2020 03:03:09.689 * +slave slave 172.20.0.3:6379 172.20.0.3 6379 @ mymaster 172.20.0.2 6379
1:X 12 Feb 2020 03:03:09.690 * +slave slave 172.20.0.4:6379 172.20.0.4 6379 @ mymaster 172.20.0.2 6379
1:X 12 Feb 2020 03:06:10.373 * +fix-slave-config slave 172.20.0.4:6379 172.20.0.4 6379 @ mymaster 172.20.0.2 6379
1:X 12 Feb 2020 03:06:10.374 * +fix-slave-config slave 172.20.0.3:6379 172.20.0.3 6379 @ mymaster 172.20.0.2 6379
```
可以看到它已经检测到了master和2个slave.

我们接下来启动sentinel-26380和sentinel-26381，查看/usr/local/redis/sentinel/sentinel-26379/conf/sentinel.conf文件,新增了2行记录，表示监测到了新的哨兵
```
sentinel known-sentinel mymaster 172.20.0.7 26379 90137df24fb27cb5821c3a3372c2101379b75018
sentinel known-sentinel mymaster 172.20.0.6 26379 d88c61fe5d93be0aaaaff6629196f0034683bb58
```

### 验证效果

此时master节点是redis-6380
![sentinel-master-6380.png](/images/redis/sentinel-master-6380.png)

我们关掉redis-6380，模式master节点故障情况。
```
docker stop redis-6380
```
我们查看日志sentinel-26379.log
![sentinel-new-master-log.png](/images/redis/sentinel-new-master-log.png)

我们可以看到选举过程，现在选定了172.20.0.4这个节点为新的master，即redis-6382,我们来验证一下：
![sentinel-new-master.png](/images/redis/sentinel-new-master.png)

可以看到符合我们的预期。

此时我们再次启动redis-6380,并查看redis-6380信息
```
docker start redis-6380
```
![sentinel-failer-link-master.png](/images/redis/sentinel-failer-link-master.png)

可以看到，redis-6380变为了slave,但是没有连接上新的master。

这是因为我们在上一节主从模式时，在redis-6380的redis.conf中未配置密码的原因。
修改/usr/local/redis/master-slaver/master/conf/redis.conf,添加
```
masterauth 123456
```
我们重启redis-6380,并查看redis-6380信息
![sentinel-success-link-master.png](/images/redis/sentinel-success-link-master.png)

OK，新启动的redis-6380已经成为的新master的从节点。

我们搭建的是伪哨兵模式，真实环境下，这 3个redis节点应该分别部署在3台服务器上，每台服务器都布置一个sentinel哨兵。

至此，redis一主二从三哨兵搭建完成，哨兵模式主要解决了高可用问题（HA），保证特殊情况故障自动切换，哨兵盯着你的“redis主从集群”，如果主库死了，它会告诉你新的老大是谁。

参考：
https://www.cnblogs.com/demingblog/p/10295236.html#redis-cluster
https://blog.csdn.net/cyfblog/article/details/100340640