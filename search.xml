<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Docker Compose笔记</title>
    <url>/2020/01/26/docker-04/</url>
    <content><![CDATA[<p>Docker Compose 是用于定义和运行多容器 Docker 应用程序的工具。部署一个应用可能需要用到多个Docker容器，比如MySQL，Redis，Nginx等，单独的去管理每个容器可能会比较麻烦。</p>
<p>Docker Compose可以通过一个yml文件来统一管理这些容器，可以极大简化我们的应用部署过程。</p>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>docker常用命令及Dockerfile笔记</title>
    <url>/2020/01/19/docker-03/</url>
    <content><![CDATA[<blockquote>
<p>docker主要的3个概念：镜像（image）+容器（container）+仓库（repository）</p>
</blockquote>
<ul>
<li>docker镜像：概念类似虚拟机的镜像，可以用来创建新的容器。</li>
<li>docker仓库：docker仓库概念和git类似。docker仓库是用来包含镜像的位置。</li>
<li>docker容器：是由docker镜像创建的运行实例。docker容器类似虚拟机，可以执行包含启动，停止，删除等。每个容器间是相互隔离的。容器中会运行特定的运用，包含特定应用的代码及所需的依赖文件。可以把容器看作一个简易版的linux环境（包含root用户权限，进程空间，用户空间和网络空间等）和运行在其中的应用程序。</li>
</ul>
<p><img src="/images/docker/%E4%BB%93%E5%BA%93-%E9%95%9C%E5%83%8F-%E5%AE%B9%E5%99%A8%E5%85%B3%E7%B3%BB%E5%9B%BE.png" alt="仓库-镜像-容器关系图.png"></p>
<p>我们在这个过程中熟悉经常使用的命令。</p>
<h2 id="Docker-镜像和容器"><a href="#Docker-镜像和容器" class="headerlink" title="Docker 镜像和容器"></a>Docker 镜像和容器</h2><h3 id="镜像查询"><a href="#镜像查询" class="headerlink" title="镜像查询"></a>镜像查询</h3><p>docker镜像查询地址dockerhub：<a href="https://hub.docker.com/search" target="_blank" rel="noopener">https://hub.docker.com/search</a><br><img src="/images/docker/hub.docker.com.png" alt="hub.docker.com.png"></p>
<p>我们也可以使用docker search:镜像名称  的方式，搜索镜像,这种方式无法查询镜像tags。<br><img src="/images/docker/%E6%90%9C%E7%B4%A2%E9%95%9C%E5%83%8F.png" alt="搜索镜像.png"></p>
<p>各个选项说明:<br>NAME: 镜像仓库源的名称<br>DESCRIPTION: 镜像的描述<br>OFFICIAL: 是否 docker 官方发布<br>stars: 类似 Github 里面的 star，表示点赞、喜欢的意思。<br>AUTOMATED: 自动构建。</p>
<h3 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h3><p>我们以nginx 为例</p>
<ul>
<li>拉取nginx镜像到本地</li>
</ul>
<p>docker pull 镜像名称:镜像tags,此处我们拉取最新镜像。如果不加 :镜像tags，默认拉取最新镜像。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull nginx:latest</span></pre></td></tr></table></figure>

<p>直接执行命令报：<br>Got permission denied while trying to connect to the Docker daemon socket ….: connect: permission denied</p>
<p>我们使用su root 命令切换到root用户，再次执行docker pull nginx:latest。<br><img src="/images/docker/%E4%B8%8B%E8%BD%BDnginx%E9%95%9C%E5%83%8F.png" alt="下载nginx镜像.png"></p>
<p>使用docker images 命令即可查看已经拥有的镜像。<br><img src="/images/docker/%E6%9F%A5%E7%9C%8B%E5%B7%B2%E4%B8%8B%E8%BD%BDimages.png" alt="查看已下载images.png"></p>
<p>各个选项说明:</p>
<p>REPOSITORY：表示镜像的仓库源<br>TAG：镜像的标签<br>IMAGE ID：镜像ID<br>CREATED：镜像创建时间<br>SIZE：镜像大小</p>
<h3 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h3><p>如果不加 :镜像tags，默认删除最新镜像。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker rmi nginx:latest</span></pre></td></tr></table></figure>

<h3 id="创建容器"><a href="#创建容器" class="headerlink" title="创建容器"></a>创建容器</h3><p>使用镜像创建一个 nginx容器</p>
<ol>
<li>创建挂载目录<br>mkdir -p /usr/local/nginx/{conf,html,logs}</li>
<li>在/usr/local/nginx/conf下创建nginx.conf文件，作为外置配置文件使用。这样我们就可以很方便的配置nginx。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">user  nginx;</span></pre></td></tr><tr><td class="code"><pre><span class="line">worker_processes  1;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">error_log  &#x2F;var&#x2F;log&#x2F;nginx&#x2F;error.log warn;</span></pre></td></tr><tr><td class="code"><pre><span class="line">pid        &#x2F;var&#x2F;run&#x2F;nginx.pid;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">events &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    worker_connections  1024;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">http &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    include       &#x2F;etc&#x2F;nginx&#x2F;mime.types;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    default_type  application&#x2F;octet-stream;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                      &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                      &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    access_log  &#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log  main;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    sendfile        on;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    #tcp_nopush     on;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    keepalive_timeout  65;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    #gzip  on;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    include &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;*.conf;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
在/usr/local/nginx/html目录下新建index.html<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;html&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;head&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;meta charset&#x3D;&quot;utf-8&quot;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;title&gt;Docker Nginx&lt;&#x2F;title&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;&#x2F;head&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;body&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;h1&gt;Docker Nginx&lt;&#x2F;h1&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;p&gt; Hello, Nginx.&lt;&#x2F;p&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;&#x2F;body&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;&#x2F;html&gt;</span></pre></td></tr></table></figure>
执行命令：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -d -p 80:80 --name nginx80 --restart&#x3D;always -v &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;html:&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html -v &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;nginx.conf:&#x2F;etc&#x2F;nginx&#x2F;nginx.conf -v &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;logs&#x2F;:&#x2F;var&#x2F;log&#x2F;nginx nginx:latest</span></pre></td></tr></table></figure>

</li>
</ol>
<p>如果返回一长串字符即为成功。使用docker ps 即可看到已启动容器列表：<br><img src="/images/docker/docker-nginx80.png" alt="docker-nginx80.png"></p>
<p>参数说明：<br>-d 后台运行<br>-p 设置端口映射 宿主机端口：容器端口<br>–name 设置容器别名<br>–restart=always 设置容器开机启动<br>-v 数据卷映射 宿主机目录：容器目录。这样方便我们访问配置文件及日志文件<br>最后加上nginx:latest</p>
<p>浏览器访问：<a href="http://192.168.85.128/" target="_blank" rel="noopener">http://192.168.85.128/</a> 返回<br><img src="/images/docker/nginx-%E9%A6%96%E9%A1%B5.png" alt="nginx-首页.png"></p>
<h3 id="基于容器构建镜像"><a href="#基于容器构建镜像" class="headerlink" title="基于容器构建镜像"></a>基于容器构建镜像</h3><p>镜像创建有2种方式：</p>
<ul>
<li>从已经创建的容器中更新镜像，并且提交这个镜像</li>
<li>使用 Dockerfile 指令来创建一个新的镜像</li>
</ul>
<p>我们先介绍第一种。<br>在上一步已经创建了一个nginx容器，使用命令docker commit 可创建镜像。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker commit -m&#x3D;&quot;garnett nginx&quot; -a&#x3D;&quot;garnett&quot; nginx80 garnett&#x2F;nginx:1.0</span></pre></td></tr></table></figure>
<p>参数介绍：<br>-m 设置注释<br>-a 设置作者<br>nginx80 容器名称，也可以使用container id<br>garnett/nginx:1.0  设置镜像的仓库源repository和tags</p>
<p>使用docker images 查看镜像列表：<br><img src="/images/docker/%E5%AE%B9%E5%99%A8%E5%88%9B%E5%BB%BA%E9%95%9C%E5%83%8F.png" alt="容器创建镜像.png"></p>
<h3 id="常用命令总结"><a href="#常用命令总结" class="headerlink" title="常用命令总结"></a>常用命令总结</h3><ol>
<li>docker exec -it &lt;容器ID或名字&gt; /bin/bash   进入容器命令，有个交互式 Shell</li>
<li>docker ps -a                查看所有的容器命令</li>
<li>docker stop &lt;容器ID或名字&gt;   停止容器</li>
<li>docker start &lt;容器ID或名字&gt;  启动容器</li>
<li>docker restart &lt;容器ID或名字&gt; 重启容器</li>
<li>docker logs -f &lt;容器ID或名字&gt; 输出容器日志 -f: 让 docker logs 像使用 tail -f 一样来输出容器内部的标准输出。</li>
<li>docker inspect &lt;容器ID或名字&gt; 返回一个 JSON 文件记录着 Docker 容器的配置和状态信息</li>
<li>docker images 查看镜像列表</li>
<li>docker rmi &lt;镜像ID&gt;  删除镜像</li>
<li>docker rm &lt;容器ID或名字&gt;  删除容器</li>
<li>docker pull 镜像名：tags  拉取镜像</li>
<li>docker run … 使用镜像构建容器</li>
<li>docker commit … 使用容器构建镜像</li>
</ol>
<h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><p>我们在上面已经介绍过，Dockerfile可以用来构造镜像，包含了一条条构建镜像所需的指令和说明。</p>
<h3 id="基于Dockerfile构建镜像"><a href="#基于Dockerfile构建镜像" class="headerlink" title="基于Dockerfile构建镜像"></a>基于Dockerfile构建镜像</h3><h4 id="构建nginx的镜像"><a href="#构建nginx的镜像" class="headerlink" title="构建nginx的镜像"></a>构建nginx的镜像</h4><p>我们先构建一个nginx的镜像。然后再介绍Dockerfile语法。<br>新建一个目录： mkdir -p /usr/local/mydockerfile/nginx，我们在这个目录下创建一个nginx的镜像。<br>使用vim 命令新建一个名为 Dockerfile 文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM nginx:latest</span></pre></td></tr><tr><td class="code"><pre><span class="line">RUN echo &#39;这是一个本地构建的nginx镜像&#39; &gt; &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;index.html</span></pre></td></tr></table></figure>
<p>FROM 表示基于nginx:latest 的基础镜像。如果本地没有会使用docker pull 自动下载。<br>RUN 用于执行后面跟着的命令行命令。有以下俩种格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shell 格式：</span></pre></td></tr><tr><td class="code"><pre><span class="line">RUN &lt;命令行命令&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"># &lt;命令行命令&gt; 等同于，在终端操作的 shell 命令。</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">exec 格式：</span></pre></td></tr><tr><td class="code"><pre><span class="line">RUN [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;]</span></pre></td></tr><tr><td class="code"><pre><span class="line"># 例如：</span></pre></td></tr><tr><td class="code"><pre><span class="line"># RUN [&quot;.&#x2F;test.php&quot;, &quot;dev&quot;, &quot;offline&quot;] 等价于 RUN .&#x2F;test.php dev offline</span></pre></td></tr></table></figure>

<p>注意： FROM 、RUN 等指令需要大写。</p>
<p>接下来我们在/usr/local/mydockerfile/nginx目录下执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker build -t nginx:1.1 .</span></pre></td></tr></table></figure>
<p>docker build 命令经常用到-t -f 参数</p>
<p>-t 指定镜像名称及tag<br>-f 指定 Dockerfile文件地址，因为我们是在/usr/local/mydockerfile/nginx目录下执行的，已经包含了Dockerfile 文件，所以上面的命令不需要-f</p>
<p>注意：最后的 . 代表本次执行的上下文路径。上下文路径，是指 docker 在构建镜像，有时候想要使用到本机的文件（比如复制），docker build 命令得知这个路径后，会将路径下的所有内容打包。<br>上下文路径下不要放无用的文件，因为会一起打包发送给 docker 引擎，如果文件过多会造成过程缓慢。</p>
<p>可以看到构建过程及构建好的镜像文件。<br><img src="/images/docker/dockerfile%E6%9E%84%E5%BB%BAnginx%E9%95%9C%E5%83%8F.png" alt="dockerfile构建nginx镜像.png"></p>
<p>我们使用刚才构建好的镜像创建容器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -d -p 82:80 --name nginx82 nginx:1.1</span></pre></td></tr></table></figure>
<p><img src="/images/docker/nginx82.png" alt="nginx82.png">乱码是因为写入容器的/usr/share/nginx/html/index.html 中只包含’这是一个本地构建的nginx镜像’，不是一个正常的html。至此表示我们构建的镜像是可以使用的。</p>
<h3 id="Dockerfile指令详解"><a href="#Dockerfile指令详解" class="headerlink" title="Dockerfile指令详解"></a>Dockerfile指令详解</h3><ol>
<li><p>FROM<br>位于Dockerfile开头，表示基于什么镜像构建</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM nginx:latest</span></pre></td></tr><tr><td class="code"><pre><span class="line">RUN echo &#39;这是一个本地构建的nginx镜像&#39; &gt; &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;index.html</span></pre></td></tr></table></figure>
</li>
<li><p>LABEL<br>Dockerfile的元数据，描述作用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM nginx:latest</span></pre></td></tr><tr><td class="code"><pre><span class="line">LABEL version&#x3D;&quot;1.0&quot; author&#x3D;&quot;garnett&quot; description&#x3D;&quot;nginx port 82&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">RUN echo &#39;这是一个本地构建的nginx镜像&#39; &gt; &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;index.html</span></pre></td></tr></table></figure>
</li>
<li><p>RUN<br>运行命令，每次run都会生成一个图层，所以最好使用 &amp;&amp; 将命令合并</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM nginx:latest</span></pre></td></tr><tr><td class="code"><pre><span class="line">LABEL version&#x3D;&quot;1.0&quot; author&#x3D;&quot;garnett&quot; description&#x3D;&quot;nginx port 82&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">RUN echo &#39;这是一个本地构建的nginx镜像&#39; &gt; &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;index.html</span></pre></td></tr><tr><td class="code"><pre><span class="line">RUN echo &#39;追加。。。&#39; &gt; &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;index.html</span></pre></td></tr></table></figure>

<p>可以修改为：</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM nginx:latest</span></pre></td></tr><tr><td class="code"><pre><span class="line">LABEL version&#x3D;&quot;1.0&quot; author&#x3D;&quot;garnett&quot; description&#x3D;&quot;nginx port 82&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">RUN echo &#39;这是一个本地构建的nginx镜像&#39; &gt; &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;index.html \</span></pre></td></tr><tr><td class="code"><pre><span class="line">&amp;&amp; echo &#39;追加。。。&#39; &gt; &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;index.html</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#96;&#96;&#96;</span></pre></td></tr></table></figure>
<ol start="4">
<li>ADD 和 COPY<br>ADD 和COPY都可以将上下文目录中复制文件或者目录到容器里指定路径。<br>语法：<pre><code>ADD  &lt;源路径1&gt;  &lt;目标路径&gt;
COPY &lt;源路径1&gt;  &lt;目标路径&gt;</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ADD ADD test test&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">COPY ADD test test&#x2F;</span></pre></td></tr></table></figure>
区别：<br>ADD 添加的文件是压缩文件的话，会自动解压。<br>COPY 只能复制构建目录下的文件，ADD可以添加一个构建上下文中的文件或目录，也可以是一个URL，如：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ADD http:&#x2F;&#x2F;wordpress.org&#x2F;latest.zip &#x2F;</span></pre></td></tr></table></figure>

<ol start="5">
<li>CMD<br> 类似于 RUN 指令，用于运行程序，但二者运行的时间点不同:<ul>
<li>CMD 在docker run 时运行。</li>
<li>RUN 是在 docker build。</li>
<li>docker run指定了其他命令，CMD命令会被忽略。</li>
<li>定义了多个CMD，只有最后一个有效。</li>
</ul>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CMD echo &quot;hello docker&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">CMD echo &quot;hello garnett&quot;</span></pre></td></tr></table></figure>
<p>构建镜像并运行docker run<br>输出hello garnett</p>
<p>运行 docker run -it [image] /bin/bash 则没有输出。因为/bin/bash覆盖了CMD 指令。</p>
<ol start="6">
<li>ENTRYPOINT<br> 类似于 CMD 指令，但其不会被 docker run 的命令行参数指定的指令所覆盖<ul>
<li>设置容器启动时运行的命令。</li>
<li>不会被忽略，一定会执行。</li>
<li>一般写一个shell脚本作为ENTRYPOINT。</li>
<li>如果 Dockerfile 中如果存在多个 ENTRYPOINT 指令，仅最后一个生效。</li>
</ul>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM ubuntu</span></pre></td></tr><tr><td class="code"><pre><span class="line">ENTRYPOINT [&quot;&#x2F;bin&#x2F;ls&quot;]</span></pre></td></tr><tr><td class="code"><pre><span class="line">CMD []</span></pre></td></tr></table></figure>

<ol start="7">
<li>ENV<br>环境变量，定义了环境变量，那么在后续的指令中，就可以使用这个环境变量。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ENV MYSQL_VERSION 5.7</span></pre></td></tr><tr><td class="code"><pre><span class="line">RUN apt-get install -y mysql-server&#x3D;&quot;$&#123;MYSQL_VERSION&#125;&quot;</span></pre></td></tr></table></figure>
<ol start="8">
<li>WORKDIR<br>指定工作目录。用 WORKDIR 指定的工作目录，会在构建镜像的每一层中都存在。（WORKDIR 指定的工作目录，必须是提前创建好的）。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM ubuntu</span></pre></td></tr><tr><td class="code"><pre><span class="line">WORKDIR &#x2F;test # 没有则自动创建test目录</span></pre></td></tr><tr><td class="code"><pre><span class="line">WORKDIR demo</span></pre></td></tr><tr><td class="code"><pre><span class="line">RUN pwd</span></pre></td></tr></table></figure>
<p>输出 /test/demo。<br>9. VOLUME<br>定义匿名数据卷。在启动容器时忘记挂载数据卷，会自动挂载到匿名卷。</p>
<ul>
<li>避免重要的数据，因容器重启而丢失，这是非常致命的。</li>
<li>避免容器不断变大。</li>
<li>例如我们用nginx搭建mysql服务，数据文件可以挂到宿主机。以免因容器删除而都是数据</li>
</ul>
<p>格式：<br>VOLUME [“&lt;路径1&gt;”, “&lt;路径2&gt;”…]<br>VOLUME &lt;路径&gt;</p>
<p>在启动容器 docker run 的时候，我们可以通过 -v 参数修改挂载点。</p>
<ol start="10">
<li><p>EXPOSE<br>仅仅只是声明端口。</p>
<ul>
<li>帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射。</li>
<li>在运行时使用随机端口映射时，也就是 docker run -P 时，会自动随机映射 EXPOSE 的端口。<br>格式：<br>EXPOSE &lt;端口1&gt; [&lt;端口2&gt;…]</li>
</ul>
</li>
</ol>
<p>参考链接：<br><a href="https://www.cnblogs.com/baizhanshi/p/9655102.html" target="_blank" rel="noopener">https://www.cnblogs.com/baizhanshi/p/9655102.html</a><br><a href="https://www.runoob.com/docker" target="_blank" rel="noopener">https://www.runoob.com/docker</a></p>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Java8 Lambda表达式</title>
    <url>/2019/12/29/java8-lamada/</url>
    <content><![CDATA[<div class="note info">
            <p> Java 8的Lambda表达式，简化了匿名函数的表达方式。Lambda表达式可以直接以内联的形式为函数式接口的抽象方法提供实现，并把整个表达式作为函数式接口的实例。</p><p>什么是函数式接口？简单来说就是只包含一个抽象方法的接口，允许有默认的实现（使用default关键字描述方法）。函数式接口建议使用@FunctionalInterface注解标注，虽然这不是必须的，但是这样做更符合规范。</p>
          </div>

<p>本节主要记录java8 内置函数式接口的使用。</p>
<h2 id="java8-中常用的函数式接口"><a href="#java8-中常用的函数式接口" class="headerlink" title="java8 中常用的函数式接口"></a>java8 中常用的函数式接口</h2><table>
<thead>
<tr>
<th align="center">函数式接口</th>
<th align="center">函数描述符</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Predicate</td>
<td align="center">T-&gt;boolean</td>
<td align="center">断言：主要作用就是用于判断作用</td>
</tr>
<tr>
<td align="center">Consumer</td>
<td align="center">T-&gt;void</td>
<td align="center">消费者：该函数式接口用于消费一个对象，即接收一个对象，对其执行某些操作，然后没有返回值。</td>
</tr>
<tr>
<td align="center">Supplier</td>
<td align="center">()-&gt;T</td>
<td align="center">供应商：无参数，返回T类型的对象</td>
</tr>
<tr>
<td align="center">Function</td>
<td align="center">T-&gt;R</td>
<td align="center">它接受一个泛型T的对象，并返回一个泛型R的对象</td>
</tr>
</tbody></table>
<h2 id="Predicate-断言"><a href="#Predicate-断言" class="headerlink" title="Predicate 断言"></a>Predicate 断言</h2><p>源码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package java.util.function;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import java.util.Objects;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;**</span></pre></td></tr><tr><td class="code"><pre><span class="line"> * @since 1.8</span></pre></td></tr><tr><td class="code"><pre><span class="line"> *&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">@FunctionalInterface</span></pre></td></tr><tr><td class="code"><pre><span class="line">public interface Predicate&lt;T&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    boolean test(T t);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    default Predicate&lt;T&gt; and(Predicate&lt;? super T&gt; other) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Objects.requireNonNull(other);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        return (t) -&gt; test(t) &amp;&amp; other.test(t);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    default Predicate&lt;T&gt; negate() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        return (t) -&gt; !test(t);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    default Predicate&lt;T&gt; or(Predicate&lt;? super T&gt; other) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Objects.requireNonNull(other);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        return (t) -&gt; test(t) || other.test(t);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    static &lt;T&gt; Predicate&lt;T&gt; isEqual(Object targetRef) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        return (null &#x3D;&#x3D; targetRef)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                ? Objects::isNull</span></pre></td></tr><tr><td class="code"><pre><span class="line">                : object -&gt; targetRef.equals(object);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>java.util.function.Predicate<T>接口定义了一个名叫test的抽象方法，它接受泛型T对象，并返回一个boolean。<br>除了抽象方法外，java.util.function.Predicate<T>接口还定义了三个默认方法：and，negate和or，对应“与”，“非”和“或”操作，这样我们便可以复合Lambda表达式了.</p>
<p>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;**</span></pre></td></tr><tr><td class="code"><pre><span class="line">     * 函数式接口：Predicate</span></pre></td></tr><tr><td class="code"><pre><span class="line">     *&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Predicate&lt;Integer&gt; isEven &#x3D; (i) -&gt; i%2 &#x3D;&#x3D;0 ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F;判断： 是否为偶数</span></pre></td></tr><tr><td class="code"><pre><span class="line">    System.out.println( isEven.test(18) );</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F;判断： 大于10 且 为偶数</span></pre></td></tr><tr><td class="code"><pre><span class="line">    System.out.println( isEven.and((i) -&gt; i&gt;10).test(18) );</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F;判断： 小于10 或 为偶数</span></pre></td></tr><tr><td class="code"><pre><span class="line">    System.out.println( isEven.or((i) -&gt; i&lt;10).test(18) );</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F;判断： 奇数判断</span></pre></td></tr><tr><td class="code"><pre><span class="line">    System.out.println( isEven.negate().test(18) );</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>运行结果为：<br>true<br>true<br>true<br>false</p>
<h2 id="Consumer-消费者，接收参数，无返回值"><a href="#Consumer-消费者，接收参数，无返回值" class="headerlink" title="Consumer 消费者，接收参数，无返回值"></a>Consumer 消费者，接收参数，无返回值</h2><p>源码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package java.util.function;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import java.util.Objects;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">@FunctionalInterface</span></pre></td></tr><tr><td class="code"><pre><span class="line">public interface Consumer&lt;T&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    void accept(T t);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    default Consumer&lt;T&gt; andThen(Consumer&lt;? super T&gt; after) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Objects.requireNonNull(after);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        return (T t) -&gt; &#123; accept(t); after.accept(t); &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>java.util.function.Consumer<T>定义了一个名叫accept的抽象方法，它接受泛型T的对象，没有返回(void)，函数描述符为(T) -&gt; void。<br>其还提供了一个默认方法andThen</p>
<p>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;**</span></pre></td></tr><tr><td class="code"><pre><span class="line">     * 函数式接口：Consumer</span></pre></td></tr><tr><td class="code"><pre><span class="line">     *&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    String str &#x3D; &quot;hello&quot;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Consumer&lt;String&gt; consumer &#x3D; (i) -&gt; System.out.println(i);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F;判断： 输出 &quot;hello&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    consumer.accept(str);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F;判断： 输出&quot;hello&quot; 和 &quot;hello world&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    consumer.andThen((i) -&gt; System.out.println(i+&quot; world&quot;)).accept(str);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h2 id="Supplier-供应商：无参数，返回T类型的对象"><a href="#Supplier-供应商：无参数，返回T类型的对象" class="headerlink" title="Supplier  供应商：无参数，返回T类型的对象"></a>Supplier  供应商：无参数，返回T类型的对象</h2><p>源码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package java.util.function;</span></pre></td></tr><tr><td class="code"><pre><span class="line">@FunctionalInterface</span></pre></td></tr><tr><td class="code"><pre><span class="line">public interface Supplier&lt;T&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    T get();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>java.util.function.Supplier<T>很简单，只定义了一个名叫get的抽象方法，它不接收参数，返回泛型T的对象，函数描述符为() -&gt; T</p>
<p>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;**</span></pre></td></tr><tr><td class="code"><pre><span class="line">     * 函数式接口：Supplier</span></pre></td></tr><tr><td class="code"><pre><span class="line">     *&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Supplier&lt;String&gt; supplier &#x3D; () -&gt; new String(&quot;supplier&quot;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    System.out.println(supplier.get());&#x2F;&#x2F; 返回一个String对象&quot;supplier&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h2 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h2><p>源码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package java.util.function;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import java.util.Objects;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;**</span></pre></td></tr><tr><td class="code"><pre><span class="line"> * @since 1.8</span></pre></td></tr><tr><td class="code"><pre><span class="line"> *&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">@FunctionalInterface</span></pre></td></tr><tr><td class="code"><pre><span class="line">public interface Function&lt;T, R&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    R apply(T t);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    default &lt;V&gt; Function&lt;V, R&gt; compose(Function&lt;? super V, ? extends T&gt; before) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Objects.requireNonNull(before);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        return (V v) -&gt; apply(before.apply(v));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    default &lt;V&gt; Function&lt;T, V&gt; andThen(Function&lt;? super R, ? extends V&gt; after) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Objects.requireNonNull(after);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        return (T t) -&gt; after.apply(apply(t));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    static &lt;T&gt; Function&lt;T, T&gt; identity() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        return t -&gt; t;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>java.util.function.Function&lt;T, R&gt;接口定义了一个叫作apply的方法，它接受一个泛型T的对象，并返回一个泛型R的对象，函数描述符为(T) -&gt; R<br>除了抽象方法外，java.util.function.Function&lt;T, R&gt;接口还定义了三个默认方法：compose，andThen,identity</p>
<p>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;**</span></pre></td></tr><tr><td class="code"><pre><span class="line">     * 函数式接口：Function</span></pre></td></tr><tr><td class="code"><pre><span class="line">     *&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F; 接收一个Integer ,返回一个String</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Function&lt;Integer,String&gt; function &#x3D; (i)-&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        return Integer.toString(i);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F;接收 integer 123 ，返回String &quot;123&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    System.out.println(function.apply(123));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    System.out.println(function.apply(123) instanceof String);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F;compose 过程为：f(g(2))，也就是 (2*2)+1 ,即把g的执行结果当做f的参数</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Function&lt;Integer, Integer&gt; f &#x3D; (x) -&gt; x + 1;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Function&lt;Integer, Integer&gt; g &#x3D; (x) -&gt; x * 2;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    f.compose(g).apply(2); &#x2F;&#x2F; 5</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F;andThen 过程为：g1(f1(2))，也就是(2+1)*2 ，即把f1的执行结果当做g1的参数</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Function&lt;Integer, Integer&gt; f1 &#x3D; (x) -&gt; x + 1;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Function&lt;Integer, Integer&gt; g1 &#x3D; (x) -&gt; x * 2;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    f1.andThen(g1).apply(2); &#x2F;&#x2F; 6</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h2 id="最后附上全部代码"><a href="#最后附上全部代码" class="headerlink" title="最后附上全部代码"></a>最后附上全部代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.sxdx.spring.security.oauth2.controller;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">import java.util.function.Consumer;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import java.util.function.Function;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import java.util.function.Predicate;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import java.util.function.Supplier;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">public class Java8TestController &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    public static void main1(String[] args) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#x2F;**</span></pre></td></tr><tr><td class="code"><pre><span class="line">         * 函数式接口：Predicate</span></pre></td></tr><tr><td class="code"><pre><span class="line">         *&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Predicate&lt;Integer&gt; isEven &#x3D; (i) -&gt; i%2 &#x3D;&#x3D;0 ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#x2F;&#x2F;判断： 是否为偶数</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println( isEven.test(18) );</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#x2F;&#x2F;判断： 大于10 且 为偶数</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println( isEven.and((i) -&gt; i&gt;10).test(18) );</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#x2F;&#x2F;判断： 小于10 或 为偶数</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println( isEven.or((i) -&gt; i&lt;10).test(18) );</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#x2F;&#x2F;判断： 奇数判断</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println( isEven.negate().test(18) );</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public static void main2(String[] args) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#x2F;**</span></pre></td></tr><tr><td class="code"><pre><span class="line">         * 函数式接口：Consumer</span></pre></td></tr><tr><td class="code"><pre><span class="line">         *&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        String str &#x3D; &quot;hello&quot;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Consumer&lt;String&gt; consumer &#x3D; (i) -&gt; System.out.println(i);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#x2F;&#x2F;判断： 输出 &quot;hello&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        consumer.accept(str);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#x2F;&#x2F;判断： 输出&quot;hello&quot; 和 &quot;hello world&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        consumer.andThen((i) -&gt; System.out.println(i+&quot; world&quot;)).accept(str);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    public static void main3(String[] args) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#x2F;**</span></pre></td></tr><tr><td class="code"><pre><span class="line">         * 函数式接口：Supplier</span></pre></td></tr><tr><td class="code"><pre><span class="line">         *&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#x2F;&#x2F; 无参，直接返回一个String字符串</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Supplier&lt;String&gt; supplier &#x3D; () -&gt; new String(&quot;supplier&quot;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(supplier.get());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    public static void main(String[] args) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#x2F;**</span></pre></td></tr><tr><td class="code"><pre><span class="line">         * 函数式接口：Function</span></pre></td></tr><tr><td class="code"><pre><span class="line">         *&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#x2F;&#x2F; 接收一个Integer ,返回一个String</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Function&lt;Integer,String&gt; function &#x3D; (i)-&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            return Integer.toString(i);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#x2F;&#x2F;接收 integer 123 ，返回String &quot;123&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(function.apply(123));</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(function.apply(123) instanceof String);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#x2F;&#x2F;compose 过程为：f(g(2))，也就是 (2*2)+1 ,即把g的执行结果当做f的参数</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Function&lt;Integer, Integer&gt; f &#x3D; (x) -&gt; x + 1;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Function&lt;Integer, Integer&gt; g &#x3D; (x) -&gt; x * 2;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        f.compose(g).apply(2); &#x2F;&#x2F; 5</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#x2F;&#x2F;andThen 过程为：g1(f1(2))，也就是(2+1)*2 ，即把f1的执行结果当做g1的参数</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Function&lt;Integer, Integer&gt; f1 &#x3D; (x) -&gt; x + 1;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Function&lt;Integer, Integer&gt; g1 &#x3D; (x) -&gt; x * 2;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        f1.andThen(g1).apply(2); &#x2F;&#x2F; 6</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>参考文章：<a href="https://mrbird.cc/java8lambda2.html" target="_blank" rel="noopener">https://mrbird.cc/java8lambda2.html</a><br>         <a href="https://www.runoob.com/java/java8-lambda-expressions.html" target="_blank" rel="noopener">https://www.runoob.com/java/java8-lambda-expressions.html</a></p>
]]></content>
      <categories>
        <category>Java8</category>
      </categories>
      <tags>
        <tag>Java8</tag>
      </tags>
  </entry>
  <entry>
    <title>linux（centos7）安装docker</title>
    <url>/2019/12/26/docker-01/</url>
    <content><![CDATA[<div class="note info">
            <p>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中,然后发布到任何流行的Linux机器或Windows 机器上,也可以实现虚拟化,容器是完全使用沙箱机制,相互之间不会有任何接口。</p>
          </div>

<h2 id="检查内核版本"><a href="#检查内核版本" class="headerlink" title="检查内核版本"></a>检查内核版本</h2><blockquote>
<p>centos7 必须是3.10及以上: uname ‐r</p>
</blockquote>
<p><img src="/images/docker/%E7%89%88%E6%9C%AC%E6%A3%80%E6%9F%A5.png" alt="版本检查.png"></p>
<h2 id="安装docker前的准备"><a href="#安装docker前的准备" class="headerlink" title="安装docker前的准备"></a>安装docker前的准备</h2><blockquote>
<p>官网地址：<a href="https://docs.docker.com/install/linux/docker-ce/centos/" target="_blank" rel="noopener">https://docs.docker.com/install/linux/docker-ce/centos/</a></p>
</blockquote>
<h3 id="安装所需的软件包"><a href="#安装所需的软件包" class="headerlink" title="安装所需的软件包"></a>安装所需的软件包</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install -y yum-utils \</span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt;   device-mapper-persistent-data \</span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt;   lvm2</span></pre></td></tr></table></figure>

<p><img src="/images/docker/%E5%AE%89%E8%A3%85%E6%89%80%E9%9C%80%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%8C%85.png" alt="安装所需的软件包.png"></p>
<h3 id="设置存储库"><a href="#设置存储库" class="headerlink" title="设置存储库"></a>设置存储库</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum-config-manager \</span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt;     --add-repo \</span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt;     https:&#x2F;&#x2F;download.docker.com&#x2F;linux&#x2F;centos&#x2F;docker-ce.repo</span></pre></td></tr></table></figure>
<p><img src="/images/docker/%E5%AE%89%E8%A3%85%E6%89%80%E9%9C%80%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%8C%85.png" alt="安装所需的软件包.png"></p>
<h2 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h2><h3 id="安装最新版本docker"><a href="#安装最新版本docker" class="headerlink" title="安装最新版本docker"></a>安装最新版本docker</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install docker-ce</span></pre></td></tr></table></figure>
<p><img src="/images/docker/%E5%AE%89%E8%A3%85docker.png" alt="安装docker.png"></p>
<h3 id="安装指定版本的docker"><a href="#安装指定版本的docker" class="headerlink" title="安装指定版本的docker"></a>安装指定版本的docker</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install docker-ce-&lt;VERSION_STRING&gt; docker-ce-cli-&lt;VERSION_STRING&gt; containerd.io</span></pre></td></tr></table></figure>
<p>其中<VERSION_STRING>可以通过以下命令查看</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum list docker-ce --showduplicates | sort -r</span></pre></td></tr></table></figure>
<p><img src="/images/docker/%E6%9F%A5%E8%AF%A2docker%E7%89%88%E6%9C%AC.png" alt="查询docker版本.png"></p>
<p>最终命令如下：</p>
<blockquote>
<p>我们以第一个截图第一个为例，以下命令未实践，根据官网说明自己写的，所以没有截图，仅供参考，本人安装的是最新docker</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install docker-ce-19.03.4.ce docker-ce-cli-19.03.4.ce containerd.io</span></pre></td></tr></table></figure>

<h3 id="安装成功确认"><a href="#安装成功确认" class="headerlink" title="安装成功确认"></a>安装成功确认</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker version</span></pre></td></tr></table></figure>
<p><img src="/images/docker/%E7%89%88%E6%9C%AC%E6%9F%A5%E8%AF%A2.png" alt="版本查询.png"></p>
<h3 id="docker启动、关闭"><a href="#docker启动、关闭" class="headerlink" title="docker启动、关闭"></a>docker启动、关闭</h3><p>启动docker</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl start docker</span></pre></td></tr></table></figure>
<p>设置开机启动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl enable docker</span></pre></td></tr></table></figure>
<p><img src="/images/docker/docker%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8.png" alt="docker开机启动.png"></p>
<p>关闭docker</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl stop docker</span></pre></td></tr></table></figure>
<h2 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h2><h3 id="卸载旧版本docker"><a href="#卸载旧版本docker" class="headerlink" title="卸载旧版本docker"></a>卸载旧版本docker</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum remove docker \</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  docker-client \</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  docker-client-latest \</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  docker-common \</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  docker-latest \</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  docker-latest-logrotate \</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  docker-logrotate \</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  docker-engine</span></pre></td></tr></table></figure>
<h3 id="卸载新版本"><a href="#卸载新版本" class="headerlink" title="卸载新版本"></a>卸载新版本</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum remove docker-ce</span></pre></td></tr></table></figure>
<p>删除所有图像，容器和卷</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rm -rf &#x2F;var&#x2F;lib&#x2F;docker</span></pre></td></tr></table></figure>

<h2 id="docker-镜像查看地址：https-hub-docker-com"><a href="#docker-镜像查看地址：https-hub-docker-com" class="headerlink" title="docker 镜像查看地址：https://hub.docker.com"></a>docker 镜像查看地址：<a href="https://hub.docker.com" target="_blank" rel="noopener">https://hub.docker.com</a></h2><p><img src="/images/docker/%E9%95%9C%E5%83%8F%E6%9F%A5%E8%AF%A2.png" alt="镜像查询.png"></p>
<h2 id="安装docker-compose"><a href="#安装docker-compose" class="headerlink" title="安装docker-compose"></a>安装docker-compose</h2><blockquote>
<p>Docker Compose 是一个用来定义和运行复杂应用的 Docker 工具。<br> 使用 Docker Compose 不再需要使用 shell 脚本来启动容器。(通过 docker-compose.yml 配置)</p>
</blockquote>
<h3 id="安装命令"><a href="#安装命令" class="headerlink" title="安装命令"></a>安装命令</h3><p>官网的安装命令太慢，有时无法连接，查阅其他人博客后发现如下安装方式：</p>
<ol>
<li>通过GitHub安装（可以通过修改 URL 中的版本，自定义需要的版本）</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo curl -L https:&#x2F;&#x2F;github.com&#x2F;docker&#x2F;compose&#x2F;releases&#x2F;download&#x2F;1.22.0&#x2F;docker-compose-&#96;uname -s&#96;-&#96;uname -m&#96; -o &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose</span></pre></td></tr><tr><td class="code"><pre><span class="line">sudo chmod +x &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose</span></pre></td></tr></table></figure>

<ol start="2">
<li>通过Daocloud镜像安装（可以通过修改 URL 中的版本，自定义需要的版本）</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -L https:&#x2F;&#x2F;get.daocloud.io&#x2F;docker&#x2F;compose&#x2F;releases&#x2F;download&#x2F;1.22.0&#x2F;docker-compose-&#96;uname -s&#96;-&#96;uname -m&#96; &gt; &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose</span></pre></td></tr><tr><td class="code"><pre><span class="line">chmod +x &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose</span></pre></td></tr></table></figure>

<h3 id="卸载docker-compose"><a href="#卸载docker-compose" class="headerlink" title="卸载docker-compose"></a>卸载docker-compose</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo rm &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose</span></pre></td></tr></table></figure>

<h3 id="docker-compose常用命令"><a href="#docker-compose常用命令" class="headerlink" title="docker-compose常用命令"></a>docker-compose常用命令</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker-compose up -d</span></pre></td></tr></table></figure>

<p>后台启动 docker-compose 中的容器，如果没有容器会根据docker-compose内容创建容器，并启动。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker-compose stop</span></pre></td></tr></table></figure>
<p>停止 docker-compose 中的容器，但不会删除容器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker-compose down</span></pre></td></tr></table></figure>
<p>停止 docker-compose 中的容器并删除容器</p>
<p>参考博客：<a href="https://www.cnblogs.com/morang/p/9501223.html" target="_blank" rel="noopener">https://www.cnblogs.com/morang/p/9501223.html</a></p>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>centos7设置docker阿里云镜像加速器</title>
    <url>/2019/12/26/docker-02/</url>
    <content><![CDATA[<div class="note info">
            <p>国内从 DockerHub 拉取镜像有时会遇到困难，此时可以配置镜像加速器。本节记录如何配置使用阿里云镜像仓库。</p>
          </div>

<h2 id="配置使用阿里云镜像仓库下载镜像"><a href="#配置使用阿里云镜像仓库下载镜像" class="headerlink" title="配置使用阿里云镜像仓库下载镜像"></a>配置使用阿里云镜像仓库下载镜像</h2><h3 id="注册阿里云账号，并登陆"><a href="#注册阿里云账号，并登陆" class="headerlink" title="注册阿里云账号，并登陆"></a>注册阿里云账号，并登陆</h3><p><img src="/images/docker/%E9%98%BF%E9%87%8C%E4%BA%91%E7%99%BB%E5%BD%95.png" alt="阿里云登录.png"></p>
<h3 id="选择容器镜像服务"><a href="#选择容器镜像服务" class="headerlink" title="选择容器镜像服务"></a>选择容器镜像服务</h3><p><img src="/images/docker/%E9%95%9C%E5%83%8F%E6%9C%8D%E5%8A%A1.png" alt="镜像服务.png"></p>
<h3 id="选择如下目录，并将截图命令在centos系统上执行"><a href="#选择如下目录，并将截图命令在centos系统上执行" class="headerlink" title="选择如下目录，并将截图命令在centos系统上执行"></a>选择如下目录，并将截图命令在centos系统上执行</h3><p><img src="/images/docker/%E8%AE%BE%E7%BD%AE%E9%95%9C%E5%83%8F%E5%9C%B0%E5%9D%80.png" alt="设置镜像地址.png"></p>
<h3 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a>下载镜像</h3><p>此时使用 docker pull 命令下载镜像就会默认使用阿里云了。非常快。下载如下Nginx，大概用了不到5秒钟。<br><img src="/images/docker/%E4%B8%8B%E8%BD%BDnginx.png" alt="下载nginx.png"></p>
<h2 id="推送自定义docker镜像到阿里云"><a href="#推送自定义docker镜像到阿里云" class="headerlink" title="推送自定义docker镜像到阿里云"></a>推送自定义docker镜像到阿里云</h2><p>我们在上面设置了阿里云的镜像库，接下来演示如何将自定义的镜像推送到自己的阿里云镜像库中，这样就可以对外提供下载了。</p>
<h3 id="阿里云创建一个命名空间"><a href="#阿里云创建一个命名空间" class="headerlink" title="阿里云创建一个命名空间"></a>阿里云创建一个命名空间</h3><p><img src="/images/docker/%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4.png" alt="命名空间.png"></p>
<h3 id="准备一个可用来打包的容器"><a href="#准备一个可用来打包的容器" class="headerlink" title="准备一个可用来打包的容器"></a>准备一个可用来打包的容器</h3><p>先docker pull 一个Tomcat 镜像，并以此启动一个Tomcat 容器 ,  通过 <a href="http://192.168.230.129:8080/" target="_blank" rel="noopener">http://192.168.230.129:8080/</a> 可以看到Tomcat容器已经启动。<br><img src="/images/docker/tomcat%E5%AE%B9%E5%99%A8.png" alt="tomcat容器.png"></p>
<h3 id="将上一步的-gaoyp-tomcat-容器打包成为一个新的镜像"><a href="#将上一步的-gaoyp-tomcat-容器打包成为一个新的镜像" class="headerlink" title="将上一步的 gaoyp-tomcat 容器打包成为一个新的镜像"></a>将上一步的 gaoyp-tomcat 容器打包成为一个新的镜像</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker commit -m&#x3D;“提交的描述信息” -a&#x3D;“作者” 容器ID 要创建的目标镜像名:[标签名]</span></pre></td></tr></table></figure>
<p>此处定义的镜像为 gaoyp/tomcat ,标签为 v1.0<br><img src="/images/docker/%E5%88%9B%E5%BB%BA%E6%9C%AC%E5%9C%B0%E9%95%9C%E5%83%8F.png" alt="创建本地镜像.png"></p>
<h3 id="创建镜像仓库"><a href="#创建镜像仓库" class="headerlink" title="创建镜像仓库"></a>创建镜像仓库</h3><p><img src="/images/docker/%E5%88%9B%E5%BB%BA%E9%95%9C%E5%83%8F%E4%BB%93%E5%BA%93.png" alt="创建镜像仓库.png"></p>
<p>点击下一步，创建镜像仓库</p>
<p><img src="/images/docker/%E8%87%AA%E5%AE%9A%E4%B9%89tomcat%E9%95%9C%E5%83%8F.png" alt="自定义tomcat镜像.png"></p>
<p>点击管理可以看到镜像信息：<br><img src="/images/docker/%E9%95%9C%E5%83%8F%E4%BF%A1%E6%81%AF.png" alt="镜像信息.png"></p>
<h3 id="推送镜像（参考上图第三步）"><a href="#推送镜像（参考上图第三步）" class="headerlink" title="推送镜像（参考上图第三步）"></a>推送镜像（参考上图第三步）</h3><p><img src="/images/docker/%E6%8E%A8%E9%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E9%95%9C%E5%83%8F.png" alt="推送自定义镜像.png"></p>
<h2 id="拉取自定义镜像"><a href="#拉取自定义镜像" class="headerlink" title="拉取自定义镜像"></a>拉取自定义镜像</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull registry.cn-beijing.aliyuncs.com&#x2F;gaoyipeng&#x2F;gaoyp-tomcat:v1.0</span></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>spring security oauth2 SSO 单点登录及自定义令牌配置</title>
    <url>/2019/12/14/spring-security-oauth2-03/</url>
    <content><![CDATA[<p>上一节 <a href="https://blog.gaoyp.cn/2019/12/10/spring-security-oauth2-02/">spring security oauth2 授权码模式、密码模式代码实践</a> 介绍了spring security oauth2 的3种模式。<br>本节我们将在上一节的基础上实现SSO单点登录，及自定义自定义令牌配置。SSO单点登录的概念就不做解释了，请自行百度。</p>
<h2 id="自定义令牌配置"><a href="#自定义令牌配置" class="headerlink" title="自定义令牌配置"></a>自定义令牌配置</h2><p>上一节我们在认证服务器 spring-security-oauth2 的资源配置类 KikiAuthorizationServerConfigurer 中定义了 ClientDetails：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span></pre></td></tr><tr><td class="code"><pre><span class="line">public void configure(ClientDetailsServiceConfigurer clients) throws Exception &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    clients.inMemory()</span></pre></td></tr><tr><td class="code"><pre><span class="line">            .withClient(&quot;kiki&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            .secret(passwordEncoder.encode(&quot;123456&quot;))</span></pre></td></tr><tr><td class="code"><pre><span class="line">            .authorizedGrantTypes(&quot;password&quot;, &quot;refresh_token&quot;,&quot;authorization_code&quot;,&quot;client_credentials&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            .autoApprove(true)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            .scopes(&quot;all&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            .redirectUris(&quot;http:&#x2F;&#x2F;localhost:8001&#x2F;getCode&quot;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>指定了 client-id为kiki ，client-secret为123456，scopes范围为all,以及redirectUris。并且配置了它支持的认证类型：</p>
<ul>
<li>“authorization_code”：授权码模式</li>
<li>“password”：密码模式</li>
<li>client_credentials:客户端模式</li>
<li>“refresh_token”：刷新token</li>
</ul>
<p>现在我们修改认证服务器 KikiAuthorizationServerConfigurer如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">clients.inMemory()</span></pre></td></tr><tr><td class="code"><pre><span class="line">            .withClient(&quot;kiki&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            .secret(passwordEncoder.encode(&quot;123456&quot;))</span></pre></td></tr><tr><td class="code"><pre><span class="line">            .authorizedGrantTypes(&quot;password&quot;, &quot;refresh_token&quot;,&quot;authorization_code&quot;,&quot;client_credentials&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            .autoApprove(true)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            .scopes(&quot;all&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            .redirectUris(&quot;http:&#x2F;&#x2F;localhost:8001&#x2F;getCode&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            .resourceIds(&quot;kiki-resource&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        .and()</span></pre></td></tr><tr><td class="code"><pre><span class="line">            .withClient(&quot;client1&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            .secret(passwordEncoder.encode(&quot;123456&quot;))</span></pre></td></tr><tr><td class="code"><pre><span class="line">            .authorizedGrantTypes(&quot;authorization_code&quot;, &quot;password&quot;,&quot;refresh_token&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            .autoApprove(true)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            .scopes(&quot;read&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            .redirectUris(&quot;http:&#x2F;&#x2F;localhost:8002&#x2F;one&#x2F;login&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            .resourceIds(&quot;client1-resource&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        .and()</span></pre></td></tr><tr><td class="code"><pre><span class="line">            .withClient(&quot;client2&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            .secret(passwordEncoder.encode(&quot;123456&quot;))</span></pre></td></tr><tr><td class="code"><pre><span class="line">            .authorizedGrantTypes(&quot;authorization_code&quot;,&quot;password&quot;, &quot;refresh_token&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            .autoApprove(true)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            .scopes(&quot;read&quot;,&quot;write&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            .redirectUris(&quot;http:&#x2F;&#x2F;localhost:8003&#x2F;two&#x2F;login&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            .resourceIds(&quot;client2-resource&quot;);</span></pre></td></tr></table></figure>

<p>可以看到，我们新增了2个 Client，分别为client1，client2.并指定它们的认证类型为：”authorization_code”,”password”, “refresh_token”。</p>
<ul>
<li>autoApprove(true)：表示在授权码模式中，用户无需进入授权页面手动点击授权按钮（Authorize）,直接返回code。</li>
<li>scopes：指定了Client所能访问的范围。client1可以访问带有@PreAuthorize(“#oauth2.hasScope(‘read’)”)的资源，client2可以访问带有@PreAuthorize(“#oauth2.hasScope(‘read’)”)和<br>@PreAuthorize(“#oauth2.hasScope(‘write’)”)的资源。如果没有@PreAuthorize，则都可以访问。</li>
<li>redirectUris：配置了重定向URL，否则授权码模式输入用户名密码后会报错：error=”invalid_request”, error_description=”At least one redirect_uri must be registered with the client.”</li>
<li>resourceIds：指定了Client 所能访问的资源ID。client1可以访问带有resourceId为client1-resource的资源，client2可以访问带有resourceId为client2-resource的资源，</li>
</ul>
<p>对于scopes和resourceIds不熟悉的，可以参考 <a href="https://blog.gaoyp.cn/2019/12/08/spring-security-oauth2-01/">https://blog.gaoyp.cn/2019/12/08/spring-security-oauth2-01/</a></p>
<h2 id="新建2个资源服务器"><a href="#新建2个资源服务器" class="headerlink" title="新建2个资源服务器"></a>新建2个资源服务器</h2><p>为了实现功能，我们需要新建2个资源服务器。现约定如下（于认证服务器的clients配置相对应）：</p>
<table>
<thead>
<tr>
<th align="center">系统名称</th>
<th align="center">端口</th>
<th align="center">client-id</th>
<th align="center">client-secret</th>
</tr>
</thead>
<tbody><tr>
<td align="center">sso-resource-one</td>
<td align="center">8002</td>
<td align="center">client1</td>
<td align="center">123456</td>
</tr>
<tr>
<td align="center">sso-resource-two</td>
<td align="center">8003</td>
<td align="center">client2</td>
<td align="center">123456</td>
</tr>
</tbody></table>
<h3 id="新建资源服务器sso-resource-one："><a href="#新建资源服务器sso-resource-one：" class="headerlink" title="新建资源服务器sso-resource-one："></a>新建资源服务器sso-resource-one：</h3><p>新建一个module，pom.xml如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 https:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;parent&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;groupId&gt;com.sxdx&lt;&#x2F;groupId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;artifactId&gt;spring-all&lt;&#x2F;artifactId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;relativePath&gt;..&#x2F;spring-all&#x2F;pom.xml&lt;&#x2F;relativePath&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;&#x2F;parent&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;groupId&gt;com.sxdx&lt;&#x2F;groupId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;artifactId&gt;sso-resource-one&lt;&#x2F;artifactId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;name&gt;sso-resource-one&lt;&#x2F;name&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;description&gt;资源服务器和sso客户端&lt;&#x2F;description&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;properties&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;java.version&gt;1.8&lt;&#x2F;java.version&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;&#x2F;properties&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;dependencies&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;&#x2F;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;&#x2F;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &lt;artifactId&gt;spring-cloud-starter&lt;&#x2F;artifactId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;&#x2F;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &lt;artifactId&gt;spring-cloud-starter-oauth2&lt;&#x2F;artifactId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;&#x2F;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &lt;artifactId&gt;spring-cloud-starter-security&lt;&#x2F;artifactId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;&#x2F;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &lt;groupId&gt;org.apache.commons&lt;&#x2F;groupId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &lt;artifactId&gt;commons-lang3&lt;&#x2F;artifactId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;&#x2F;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &lt;artifactId&gt;spring-boot-starter-actuator&lt;&#x2F;artifactId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;&#x2F;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &lt;scope&gt;test&lt;&#x2F;scope&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;&#x2F;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;&#x2F;dependencies&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;build&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;plugins&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &lt;plugin&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &lt;&#x2F;plugin&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;&#x2F;plugins&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;&#x2F;build&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;&#x2F;project&gt;</span></pre></td></tr></table></figure>

<p>再贴出sso-resource-one的application.yaml：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  port: 8002</span></pre></td></tr><tr><td class="code"><pre><span class="line">  servlet:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    context-path: &#x2F;one</span></pre></td></tr><tr><td class="code"><pre><span class="line">    session:</span></pre></td></tr><tr><td class="code"><pre><span class="line">      cookie:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        name: ONESESSION</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">security:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  oauth2:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    client:</span></pre></td></tr><tr><td class="code"><pre><span class="line">      client-id: client1 #指定了客户端id</span></pre></td></tr><tr><td class="code"><pre><span class="line">      client-secret: 123456 # 指定了客户端密码</span></pre></td></tr><tr><td class="code"><pre><span class="line">      user-authorization-uri: http:&#x2F;&#x2F;127.0.0.1:8001&#x2F;oauth&#x2F;authorize #指定为认证服务器的&#x2F;oauth&#x2F;authorize地址</span></pre></td></tr><tr><td class="code"><pre><span class="line">      access-token-uri: http:&#x2F;&#x2F;127.0.0.1:8001&#x2F;oauth&#x2F;token # 指定认证服务器的&#x2F;oauth&#x2F;token地址</span></pre></td></tr><tr><td class="code"><pre><span class="line">    resource:</span></pre></td></tr><tr><td class="code"><pre><span class="line">      token-info-uri: http:&#x2F;&#x2F;127.0.0.1:8001&#x2F;oauth&#x2F;check_token #sso客户端token验证，资源服务器就是通过这个向认证服务器校验token是否有效，是否可以访问本resource资源</span></pre></td></tr><tr><td class="code"><pre><span class="line">      user-info-uri: http:&#x2F;&#x2F;127.0.0.1:8001&#x2F;authentication #sso客户端获取当前用户信息</span></pre></td></tr></table></figure>

<h4 id="添加-EnableOAuth2Sso"><a href="#添加-EnableOAuth2Sso" class="headerlink" title="添加@EnableOAuth2Sso"></a>添加@EnableOAuth2Sso</h4><p>在启动类上添加@EnableOAuth2Sso，表面这是一个SSO客户端，开启SSO的支持。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.sxdx.sso.resource.one;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.boot.SpringApplication;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.boot.autoconfigure.SpringBootApplication;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.boot.autoconfigure.security.oauth2.client.EnableOAuth2Sso;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">@EnableOAuth2Sso</span></pre></td></tr><tr><td class="code"><pre><span class="line">@SpringBootApplication</span></pre></td></tr><tr><td class="code"><pre><span class="line">public class SsoResourceOneApplication &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public static void main(String[] args) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        SpringApplication.run(SsoResourceOneApplication.class, args);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h4 id="新建WebSecurity配置类"><a href="#新建WebSecurity配置类" class="headerlink" title="新建WebSecurity配置类"></a>新建WebSecurity配置类</h4><p>新建config包，在新建config包下新建WebSecurityConfigurer类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.sxdx.sso.resource.one.config;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.context.annotation.Configuration;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.core.annotation.Order;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.security.config.annotation.method.configuration.EnableGlobalMethodSecurity;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.security.config.annotation.web.builders.HttpSecurity;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">@Order(101)</span></pre></td></tr><tr><td class="code"><pre><span class="line">@Configuration</span></pre></td></tr><tr><td class="code"><pre><span class="line">@EnableGlobalMethodSecurity(prePostEnabled &#x3D; true)</span></pre></td></tr><tr><td class="code"><pre><span class="line">public class WebSecurityConfigurer extends WebSecurityConfigurerAdapter &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Override</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public void configure(HttpSecurity http) throws Exception &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        http.requestMatchers()</span></pre></td></tr><tr><td class="code"><pre><span class="line">                .antMatchers(&quot;&#x2F;**&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                .and()</span></pre></td></tr><tr><td class="code"><pre><span class="line">                .authorizeRequests()</span></pre></td></tr><tr><td class="code"><pre><span class="line">                .antMatchers(&quot;&#x2F;**&quot;).authenticated()</span></pre></td></tr><tr><td class="code"><pre><span class="line">                .and()</span></pre></td></tr><tr><td class="code"><pre><span class="line">                .csrf().disable()</span></pre></td></tr><tr><td class="code"><pre><span class="line">                .formLogin().permitAll();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<ul>
<li>设置了资源服务的WebSecurity配置，所有请求均需要认证后才可访问。此处配置了 @Order(101)，否则会报错</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Caused by: java.lang.IllegalStateException: @Order on WebSecurityConfigurers must be unique. Order of 100 was already used on com.sxdx.sso.resource.one.config.WebSecurityConfigurer$$EnhancerBySpringCGLIB$$2b177f7a@48bc2fce, so it cannot be used on org.springframework.boot.autoconfigure.security.oauth2.client.OAuth2SsoDefaultConfiguration$$EnhancerBySpringCGLIB$$ff13e17c@1eca3ea7 too.</span></pre></td></tr><tr><td class="code"><pre><span class="line">	at org.springframework.security.config.annotation.web.configuration.WebSecurityConfiguration.setFilterChainProxySecurityConfigurer(WebSecurityConfiguration.java:148) ~[spring-security-config-5.1.5.RELEASE.jar:5.1.5.RELEASE]</span></pre></td></tr><tr><td class="code"><pre><span class="line">	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.8.0_171]</span></pre></td></tr><tr><td class="code"><pre><span class="line">	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:1.8.0_171]</span></pre></td></tr><tr><td class="code"><pre><span class="line">	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.8.0_171]</span></pre></td></tr><tr><td class="code"><pre><span class="line">	at java.lang.reflect.Method.invoke(Method.java:498) ~[na:1.8.0_171]</span></pre></td></tr><tr><td class="code"><pre><span class="line">	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredMethodElement.inject(AutowiredAnnotationBeanPostProcessor.java:708) ~[spring-beans-5.1.8.RELEASE.jar:5.1.8.RELEASE]</span></pre></td></tr><tr><td class="code"><pre><span class="line">	at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:90) ~[spring-beans-5.1.8.RELEASE.jar:5.1.8.RELEASE]</span></pre></td></tr><tr><td class="code"><pre><span class="line">	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessProperties(AutowiredAnnotationBeanPostProcessor.java:374) ~[spring-beans-5.1.8.RELEASE.jar:5.1.8.RELEASE]</span></pre></td></tr><tr><td class="code"><pre><span class="line">	... 17 common frames omitted</span></pre></td></tr></table></figure>
<p>这是因为认证服务器的WebSecurityConfigurers已经默认使用了@Order(100)，其实我们在认证服务器中已经改为 @Order(2)，但这里还是不能使用 @Order(100)。具体原因不明。反正改为@Order(101)就好了。</p>
<ul>
<li>@EnableGlobalMethodSecurity(prePostEnabled = true)，开启权限注解，否则无法使用@PreAuthorize。</li>
</ul>
<h4 id="新建ResourceServerConfig资源配置类"><a href="#新建ResourceServerConfig资源配置类" class="headerlink" title="新建ResourceServerConfig资源配置类"></a>新建ResourceServerConfig资源配置类</h4><p>在config包下，新建ResourceServerConfig：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.sxdx.sso.resource.one.config;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.context.annotation.Configuration;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.core.annotation.Order;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.security.config.annotation.web.builders.HttpSecurity;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.security.oauth2.config.annotation.web.configuration.EnableResourceServer;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.security.oauth2.config.annotation.web.configuration.ResourceServerConfigurerAdapter;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.security.oauth2.config.annotation.web.configurers.ResourceServerSecurityConfigurer;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">@Configuration</span></pre></td></tr><tr><td class="code"><pre><span class="line">@EnableResourceServer</span></pre></td></tr><tr><td class="code"><pre><span class="line">public class ResourceServerConfig extends ResourceServerConfigurerAdapter&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Override</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public void configure(ResourceServerSecurityConfigurer resources) throws Exception &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        resources.resourceId(&quot;client1-resource&quot;).stateless(true); &#x2F;&#x2F;重点，设置资源id</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    public void configure(HttpSecurity http) throws Exception &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        http.requestMatchers().antMatchers(&quot;&#x2F;**&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                .and()</span></pre></td></tr><tr><td class="code"><pre><span class="line">                .authorizeRequests()</span></pre></td></tr><tr><td class="code"><pre><span class="line">                .anyRequest().authenticated()</span></pre></td></tr><tr><td class="code"><pre><span class="line">                .antMatchers(&quot;&#x2F;login&#x2F;**&quot;).permitAll();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<ul>
<li>@EnableResourceServer 开启资源服务器配置</li>
<li>定义了本服务的resourceId为client1-resource</li>
<li>定义了资源访问规则。</li>
</ul>
<h4 id="新建测试类"><a href="#新建测试类" class="headerlink" title="新建测试类"></a>新建测试类</h4><p>新建OneController：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.sxdx.sso.resource.one.controller;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.security.access.prepost.PreAuthorize;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.web.bind.annotation.GetMapping;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.web.bind.annotation.RestController;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import java.security.Principal;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import java.util.HashMap;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import java.util.Map;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">@RestController</span></pre></td></tr><tr><td class="code"><pre><span class="line">public class OneController &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    @PreAuthorize(&quot;#oauth2.hasScope(&#39;write&#39;)&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    @GetMapping(&quot;&#x2F;index&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public Map&lt;String,String&gt; index()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Map&lt;String,String&gt; mp &#x3D; new HashMap&lt;&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        mp.put(&quot;key&quot;,&quot;&#x2F;index&quot;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        return mp;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    @PreAuthorize(&quot;hasAuthority(&#39;user:add&#39;) and #oauth2.hasScope(&#39;read&#39;)&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    @GetMapping(&quot;&#x2F;user&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public Principal user(Principal principal) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        return principal;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<ul>
<li>@PreAuthorize(“#oauth2.hasScope(‘read’)”):只有scope包含read才有权访问。</li>
<li>@PreAuthorize(“hasAuthority(‘user:add’) and #oauth2.hasScope(‘read’)”):只有scope包含read，并且用户角色为 user:add 才有权访问。<br>认证服务器中KikiUserDetailService定义了所有登录用户，均有user:add权限</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span></pre></td></tr><tr><td class="code"><pre><span class="line">   public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       KikiSecurityUser user &#x3D; new KikiSecurityUser();</span></pre></td></tr><tr><td class="code"><pre><span class="line">       user.setUsername(username);</span></pre></td></tr><tr><td class="code"><pre><span class="line">       user.setPassword(this.passwordEncoder.encode(&quot;123456&quot;));</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">       return new User(username, user.getPassword(), user.isEnabled(),</span></pre></td></tr><tr><td class="code"><pre><span class="line">               user.isAccountNonExpired(), user.isCredentialsNonExpired(),</span></pre></td></tr><tr><td class="code"><pre><span class="line">               user.isAccountNonLocked(), AuthorityUtils.commaSeparatedStringToAuthorityList(&quot;user:add&quot;));</span></pre></td></tr><tr><td class="code"><pre><span class="line">   &#125;</span></pre></td></tr></table></figure>

<p>至此资源服务器sso-resource-one搭建完成</p>
<h3 id="新建资源服务器module：sso-resource-two"><a href="#新建资源服务器module：sso-resource-two" class="headerlink" title="新建资源服务器module：sso-resource-two"></a>新建资源服务器module：sso-resource-two</h3><p>仿照sso-resource-one,新建sso-resource-two即可。不再贴出代码。</p>
<h2 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h2><h3 id="resourceIds-作用演示"><a href="#resourceIds-作用演示" class="headerlink" title="resourceIds 作用演示"></a>resourceIds 作用演示</h3><p>查询 <a href="http://127.0.0.1:8002/one/user。" target="_blank" rel="noopener">http://127.0.0.1:8002/one/user。</a></p>
<p><img src="/images/oauth2/%E8%8E%B7%E5%8F%96client1%E7%9A%84%E8%B5%84%E6%BA%90.png" alt="获取client1的资源.png"></p>
<p>我们通过postman 密码模式获取token</p>
<p><img src="/images/oauth2/%E8%8E%B7%E5%8F%96client1%E7%9A%84token.png" alt="获取client1的token.png"></p>
<p>点击Send访问，记着添加请求头（client1:123456 base64编码）：</p>
<p><img src="/images/oauth2/client1%E7%9A%84%E8%B5%84%E6%BA%90.png" alt="client1的资源.png"></p>
<p>可以看到可以获取到对应资源。因为client1对应的resourceID为client1-resource。而 <a href="http://127.0.0.1:8002/one/user" target="_blank" rel="noopener">http://127.0.0.1:8002/one/user</a> 就是属于client1-resource的资源。</p>
<p>现在我们再次获取请求资源，不同的是把URl 改为 <a href="http://127.0.0.1:8003/two/user" target="_blank" rel="noopener">http://127.0.0.1:8003/two/user</a> 。来验证client1是否可以获取client2-resource的资源。<br>返回结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &quot;error&quot;: &quot;access_denied&quot;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &quot;error_description&quot;: &quot;Invalid token does not contain resource id (client2-resource)&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>无权访问client2-resource。我们修改client1的resourceIds，并重启服务。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.and()</span></pre></td></tr><tr><td class="code"><pre><span class="line">.withClient(&quot;client1&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">.secret(passwordEncoder.encode(&quot;123456&quot;))</span></pre></td></tr><tr><td class="code"><pre><span class="line">.authorizedGrantTypes(&quot;authorization_code&quot;,&quot;password&quot;, &quot;refresh_token&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">.autoApprove(true)</span></pre></td></tr><tr><td class="code"><pre><span class="line">.scopes(&quot;read&quot;,&quot;write&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">.redirectUris(&quot;http:&#x2F;&#x2F;localhost:8003&#x2F;two&#x2F;login&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">.resourceIds(&quot;client2-resource&quot;,&quot;client1-resource&quot;)</span></pre></td></tr></table></figure>
<p> resourceIds(“client2-resource”,”client1-resource”)表示client1可以访问sso-resource-one和sso-resource-two的资源。</p>
<p> 访问<a href="http://127.0.0.1:8002/one/user" target="_blank" rel="noopener">http://127.0.0.1:8002/one/user</a> ，发现可以获取资源。修改URL为<a href="http://127.0.0.1:8003/two/user.也可以获取到资源。" target="_blank" rel="noopener">http://127.0.0.1:8003/two/user.也可以获取到资源。</a></p>
<h3 id="scopes-作用演示"><a href="#scopes-作用演示" class="headerlink" title="scopes 作用演示"></a>scopes 作用演示</h3><p>再次修改URL为<a href="http://127.0.0.1:8002/one/index" target="_blank" rel="noopener">http://127.0.0.1:8002/one/index</a>,<br>返回：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &quot;error&quot;: &quot;access_denied&quot;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &quot;error_description&quot;: &quot;不允许访问&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>因为client1 的scope为read,而/one/index 需要 write.</p>
<h3 id="SSO-单点登录"><a href="#SSO-单点登录" class="headerlink" title="SSO 单点登录"></a>SSO 单点登录</h3><p>其实上面的演示过程已经实现了单点登录，我们通过token可以同时获取到sso-resource-one和sso-resource-two的资源,不过这个只适合密码模式。<br>浏览器直接访问 <a href="http://127.0.0.1:8002/one/user" target="_blank" rel="noopener">http://127.0.0.1:8002/one/user</a> 会报Full authentication is required to access this resource。</p>
<p>现在我们把sso-resource-one和sso-resource-two的 ResourceServerConfig类的 @EnableResourceServer注解去掉。<br>浏览器访问 <a href="http://127.0.0.1:8002/one/user,浏览器会重定向到" target="_blank" rel="noopener">http://127.0.0.1:8002/one/user,浏览器会重定向到</a> <a href="http://127.0.0.1:8001/login" target="_blank" rel="noopener">http://127.0.0.1:8001/login</a>:</p>
<p><img src="/images/oauth2/SSO%E7%99%BB%E5%BD%95.png" alt="SSO登录.png"> </p>
<p>输入garnett 123456 点击 “Sign in”</p>
<p><img src="/images/oauth2/SSO-client1.png" alt="SSO-client1.png"> </p>
<p>可以看到浏览器返回了<a href="http://127.0.0.1:8002/one/user对应的资源。接下来我们新开一个页面访问" target="_blank" rel="noopener">http://127.0.0.1:8002/one/user对应的资源。接下来我们新开一个页面访问</a> <a href="http://127.0.0.1:8003/two/user" target="_blank" rel="noopener">http://127.0.0.1:8003/two/user</a></p>
<p><img src="/images/oauth2/%E8%AE%BF%E9%97%AEsso-client2.png" alt="访问sso-client2.png"> </p>
<p><img src="/images/oauth2/sso-client2.png" alt="sso-client2.png"> </p>
<p>我们发现，我没要求输入用户名密码，即可获取到对应资源。</p>
<p>我们再访问 <a href="http://127.0.0.1:8002/one/index，会报403异常,不是很理解。发现将client1的" target="_blank" rel="noopener">http://127.0.0.1:8002/one/index，会报403异常,不是很理解。发现将client1的</a> scopes改为 (“read”,”write”)后就可以访问了。<br>哪位知道为啥还请不吝赐教！</p>
<p><img src="/images/oauth2/sso-403.png" alt="sso-403.png"> </p>
<p>访问 <a href="http://127.0.0.1:8003/two/index" target="_blank" rel="noopener">http://127.0.0.1:8003/two/index</a> ，返回结果： {“key”:”/index”}</p>
<p>参考：<br><a href="https://mrbird.cc/Spring-Security-OAuth2-SSO.html" target="_blank" rel="noopener">https://mrbird.cc/Spring-Security-OAuth2-SSO.html</a><br><a href="http://www.it1352.com/983633.html" target="_blank" rel="noopener">http://www.it1352.com/983633.html</a></p>
<hr>
<p>学然后知不足,教然后知困。知不足,然后能自反也;知困,然后能自强也。</p>
]]></content>
      <categories>
        <category>OAuth2</category>
        <category>Spring-Security</category>
      </categories>
      <tags>
        <tag>OAuth2</tag>
        <tag>Spring-Security</tag>
      </tags>
  </entry>
  <entry>
    <title>spring security oauth2 授权码模式、密码模式代码实践</title>
    <url>/2019/12/10/spring-security-oauth2-02/</url>
    <content><![CDATA[<p>上一节 <a href="https://blog.gaoyp.cn/2019/12/08/spring-security-oauth2-01/">spring security oauth2 基础知识</a> 介绍了spring security oauth2 基础知识.</p>
<p>本节实例代码演示,为了之后有一个可供代码实践的环境，本次搭建一个名为 spring-all 的聚合工程，今后不特殊说明，均在此项目下进行演示。</p>
<blockquote>
<p>环境说明：IDEA2019.2 、jdk 1.8 、maven 3.6.2 </p>
</blockquote>
<h2 id="搭建-spring-all"><a href="#搭建-spring-all" class="headerlink" title="搭建 spring-all"></a>搭建 spring-all</h2><h3 id="创建父级-maven项目：-spring-all"><a href="#创建父级-maven项目：-spring-all" class="headerlink" title="创建父级 maven项目： spring-all"></a>创建父级 maven项目： spring-all</h3><p><img src="/images/oauth2/%E5%88%9B%E5%BB%BAspring-all.png" alt="创建spring-all"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   &lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   </span></pre></td></tr><tr><td class="code"><pre><span class="line">       &lt;groupId&gt;com.sxdx&lt;&#x2F;groupId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       &lt;artifactId&gt;spring-all&lt;&#x2F;artifactId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       &lt;packaging&gt;pom&lt;&#x2F;packaging&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   </span></pre></td></tr><tr><td class="code"><pre><span class="line">       &lt;modules&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">           &lt;module&gt;..&#x2F;spring-security-oauth2&lt;&#x2F;module&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       &lt;&#x2F;modules&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   </span></pre></td></tr><tr><td class="code"><pre><span class="line">       &lt;parent&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">           &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">           &lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">           &lt;version&gt;2.1.6.RELEASE&lt;&#x2F;version&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">           &lt;relativePath&#x2F;&gt; &lt;!-- lookup parent from repository --&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       &lt;&#x2F;parent&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   </span></pre></td></tr><tr><td class="code"><pre><span class="line">       &lt;properties&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">           &lt;spring-cloud.version&gt;Greenwich.SR1&lt;&#x2F;spring-cloud.version&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       &lt;&#x2F;properties&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   </span></pre></td></tr><tr><td class="code"><pre><span class="line">       &lt;dependencyManagement&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">           &lt;dependencies&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">               &lt;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                   &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                   &lt;artifactId&gt;spring-cloud-dependencies&lt;&#x2F;artifactId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                   &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;&#x2F;version&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                   &lt;type&gt;pom&lt;&#x2F;type&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                   &lt;scope&gt;import&lt;&#x2F;scope&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">               &lt;&#x2F;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">           &lt;&#x2F;dependencies&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       &lt;&#x2F;dependencyManagement&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   &lt;&#x2F;project&gt;</span></pre></td></tr></table></figure>

<blockquote>
<p>指定 packaging为pom，表示这是一个纯聚合模块，无需打包为jar或者war。指定spring-boot版本：2.1.6.RELEASE，spring-cloud版本：Greenwich.SR1</p>
</blockquote>
<p>它们的对应关系：</p>
<table>
<thead>
<tr>
<th align="center">spring boot</th>
<th align="center">spring cloud</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Hoxton</td>
<td align="center">2.2.x</td>
</tr>
<tr>
<td align="center">Greenwich</td>
<td align="center">2.1.x</td>
</tr>
<tr>
<td align="center">Finchley</td>
<td align="center">2.0.x</td>
</tr>
<tr>
<td align="center">Edgware</td>
<td align="center">1.5.x</td>
</tr>
<tr>
<td align="center">Dalston</td>
<td align="center">1.5.x</td>
</tr>
</tbody></table>
<h3 id="创建一个-module项目：-spring-security-oauth2"><a href="#创建一个-module项目：-spring-security-oauth2" class="headerlink" title="创建一个 module项目： spring-security-oauth2"></a>创建一个 module项目： spring-security-oauth2</h3><p><img src="/images/oauth2/%E5%88%9B%E5%BB%BAsecurity-oauth2.png" alt="创建security-oauth2.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 https:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;parent&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;groupId&gt;com.sxdx&lt;&#x2F;groupId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;artifactId&gt;spring-all&lt;&#x2F;artifactId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;relativePath&gt;..&#x2F;spring-all&#x2F;pom.xml&lt;&#x2F;relativePath&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;&#x2F;parent&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;groupId&gt;com.sxdx&lt;&#x2F;groupId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;artifactId&gt;spring-security-oauth2&lt;&#x2F;artifactId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;name&gt;spring-security-oauth2&lt;&#x2F;name&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;description&gt;spring-security-oauth2 Demo&lt;&#x2F;description&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;properties&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;java.version&gt;1.8&lt;&#x2F;java.version&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;&#x2F;properties&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;dependencies&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">         &lt;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;&#x2F;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;&#x2F;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &lt;artifactId&gt;spring-cloud-starter&lt;&#x2F;artifactId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;&#x2F;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &lt;artifactId&gt;spring-cloud-starter-oauth2&lt;&#x2F;artifactId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;&#x2F;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &lt;artifactId&gt;spring-cloud-starter-security&lt;&#x2F;artifactId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;&#x2F;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &lt;groupId&gt;org.apache.commons&lt;&#x2F;groupId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &lt;artifactId&gt;commons-lang3&lt;&#x2F;artifactId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;&#x2F;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &lt;scope&gt;test&lt;&#x2F;scope&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;&#x2F;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;&#x2F;dependencies&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;build&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;plugins&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &lt;plugin&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &lt;&#x2F;plugin&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;&#x2F;plugins&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;&#x2F;build&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;&#x2F;project&gt;</span></pre></td></tr></table></figure>

<blockquote>
<p>lombok说明：因为项目里使用了Lombok注解,除引用lombok jar包外，我们还需要在IDEA里安装Lombok插件。<a href="https://www.cnblogs.com/pcheng/p/10945476.html" target="_blank" rel="noopener">https://www.cnblogs.com/pcheng/p/10945476.html</a></p>
</blockquote>
<h3 id="授权码模式（authorization-code）"><a href="#授权码模式（authorization-code）" class="headerlink" title="授权码模式（authorization code）"></a>授权码模式（authorization code）</h3><h4 id="创建一个实体类"><a href="#创建一个实体类" class="headerlink" title="创建一个实体类"></a>创建一个实体类</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.sxdx.spring.security.oauth2.entity;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">import lombok.Data;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.security.core.GrantedAuthority;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import java.io.Serializable;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import java.util.Set;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">@Data</span></pre></td></tr><tr><td class="code"><pre><span class="line">public class KikiSecurityUser implements Serializable &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    private static final long serialVersionUID &#x3D; 3191927289420949930L;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    private String password;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    private String username;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    private Set&lt;GrantedAuthority&gt; authorities;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    private boolean accountNonExpired &#x3D; true;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    private boolean accountNonLocked &#x3D; true;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    private boolean credentialsNonExpired &#x3D; true;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    private boolean enabled &#x3D; true;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h4 id="创建用户名密码校验类"><a href="#创建用户名密码校验类" class="headerlink" title="创建用户名密码校验类"></a>创建用户名密码校验类</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.sxdx.spring.security.oauth2.service;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">import com.sxdx.spring.security.oauth2.entity.KikiSecurityUser;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.security.core.authority.AuthorityUtils;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.security.core.userdetails.User;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.security.core.userdetails.UserDetails;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.security.core.userdetails.UserDetailsService;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.security.core.userdetails.UsernameNotFoundException;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.security.crypto.password.PasswordEncoder;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.stereotype.Service;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;**</span></pre></td></tr><tr><td class="code"><pre><span class="line"> * 校验用户名密码</span></pre></td></tr><tr><td class="code"><pre><span class="line"> *&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">@Service</span></pre></td></tr><tr><td class="code"><pre><span class="line">public class KikiUserDetailService implements UserDetailsService &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Autowired</span></pre></td></tr><tr><td class="code"><pre><span class="line">    private PasswordEncoder passwordEncoder;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Override</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        KikiSecurityUser user &#x3D; new KikiSecurityUser();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        user.setUsername(username);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        user.setPassword(this.passwordEncoder.encode(&quot;123456&quot;));</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        return new User(username, user.getPassword(), user.isEnabled(),</span></pre></td></tr><tr><td class="code"><pre><span class="line">                user.isAccountNonExpired(), user.isCredentialsNonExpired(),</span></pre></td></tr><tr><td class="code"><pre><span class="line">                user.isAccountNonLocked(), AuthorityUtils.commaSeparatedStringToAuthorityList(&quot;user:add&quot;));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>KikiUserDetailService实现了UserDetailsService接口的loadUserByUsername方法。定义登录逻辑：用户名任意，密码为123456 即可通过spring-security登录。loadUserByUsername方法返回一个UserDetails对象，该对象也是一个接口，<br>包含一些用于描述用户信息的方法，源码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface UserDetails extends Serializable &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Collection&lt;? extends GrantedAuthority&gt; getAuthorities();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    String getPassword();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    String getUsername();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    boolean isAccountNonExpired();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    boolean isAccountNonLocked();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    boolean isCredentialsNonExpired();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    boolean isEnabled();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>这些字段的含义如下：</p>
<ul>
<li>getAuthorities获取用户包含的权限，返回权限集合，权限是一个继承了GrantedAuthority的对象；</li>
<li>getPassword和getUsername用于获取密码和用户名；</li>
<li>isAccountNonExpired方法返回boolean类型，用于判断账户是否未过期，未过期返回true反之返回false；</li>
<li>isAccountNonLocked方法用于判断账户是否未锁定；</li>
<li>isCredentialsNonExpired用于判断用户凭证是否没过期，即密码是否未过期；</li>
<li>isEnabled方法用于判断用户是否可用。</li>
</ul>
<h4 id="创建一个通用返回类"><a href="#创建一个通用返回类" class="headerlink" title="创建一个通用返回类"></a>创建一个通用返回类</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.sxdx.spring.security.oauth2.entity;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">import java.io.Serializable;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import java.util.HashMap;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">public class KikiResponse extends HashMap&lt;String, Object&gt; implements Serializable &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    private static final long serialVersionUID &#x3D; 967397361339698151L;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public KikiResponse message(String message) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        this.put(&quot;message&quot;, message);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        return this;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    public KikiResponse data(Object data) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        this.put(&quot;data&quot;, data);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        return this;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Override</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public KikiResponse put(String key, Object value) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        super.put(key, value);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        return this;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    public String getMessage() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        return String.valueOf(get(&quot;message&quot;));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    public Object getData() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        return get(&quot;data&quot;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h4 id="创建Security配置类"><a href="#创建Security配置类" class="headerlink" title="创建Security配置类"></a>创建Security配置类</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.sxdx.spring.security.oauth2.config;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.context.annotation.Bean;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.security.crypto.password.PasswordEncoder;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">@EnableWebSecurity</span></pre></td></tr><tr><td class="code"><pre><span class="line">public class KikiSecurityConfig extends WebSecurityConfigurerAdapter &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;**</span></pre></td></tr><tr><td class="code"><pre><span class="line">     * Spring Security内部实现好的 BCryptPasswordEncoder。</span></pre></td></tr><tr><td class="code"><pre><span class="line">     * BCryptPasswordEncoder的特点就是，对于一个相同的密码，每次加密出来的加密串都不同</span></pre></td></tr><tr><td class="code"><pre><span class="line">     *&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Bean</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public PasswordEncoder passwordEncoder() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        return new BCryptPasswordEncoder();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<blockquote>
<p>KikiSecurityConfig类添加了@EnableWebSecurity注解。并且定义了spring-Security密码验证方式 BCryptPasswordEncoder。</p>
</blockquote>
<h4 id="创建认证服务器配置类"><a href="#创建认证服务器配置类" class="headerlink" title="创建认证服务器配置类"></a>创建认证服务器配置类</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.sxdx.spring.security.oauth2.config;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.context.annotation.Configuration;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.security.crypto.password.PasswordEncoder;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.security.oauth2.config.annotation.configurers.ClientDetailsServiceConfigurer;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.security.oauth2.config.annotation.web.configuration.AuthorizationServerConfigurerAdapter;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.security.oauth2.config.annotation.web.configuration.EnableAuthorizationServer;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;**</span></pre></td></tr><tr><td class="code"><pre><span class="line"> * 认证服务器配置</span></pre></td></tr><tr><td class="code"><pre><span class="line"> *&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">@Configuration</span></pre></td></tr><tr><td class="code"><pre><span class="line">@EnableAuthorizationServer</span></pre></td></tr><tr><td class="code"><pre><span class="line">public class KikiAuthorizationServerConfigurer extends AuthorizationServerConfigurerAdapter &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Autowired</span></pre></td></tr><tr><td class="code"><pre><span class="line">    private PasswordEncoder passwordEncoder;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Override</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public void configure(ClientDetailsServiceConfigurer clients) throws Exception &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        clients.inMemory()</span></pre></td></tr><tr><td class="code"><pre><span class="line">                .withClient(&quot;kiki&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                .secret(passwordEncoder.encode(&quot;123456&quot;))</span></pre></td></tr><tr><td class="code"><pre><span class="line">                .authorizedGrantTypes(&quot;password&quot;, &quot;refresh_token&quot;,&quot;authorization_code&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                .scopes(&quot;all&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                .redirectUris(&quot;http:&#x2F;&#x2F;localhost:8001&#x2F;getCode&quot;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>添加了 @EnableAuthorizationServer来开启认证服务器功能。</p>
<p>重写了 configure(ClientDetailsServiceConfigurer clients) 方法。该方法主要配置了：</p>
<ul>
<li>客户端从认证服务器获取令牌的时候，必须使用client_id为 kiki，client_secret为123456的标识来获取；</li>
<li>该client_id支持 password、authorization_code 模式获取令牌，并且可以通过refresh_token来获取新的令牌；</li>
<li>在获取client_id为kiki的令牌的时候，scope需指定为all，否则将获取失败；</li>
<li>配置了redirectUris，指定了获取code时的重定向地址；</li>
</ul>
<p>如果需要指定多个client，可以继续使用withClient配置。</p>
<h4 id="创建-KikiOauthController-来获取-code"><a href="#创建-KikiOauthController-来获取-code" class="headerlink" title="创建 KikiOauthController 来获取 code"></a>创建 KikiOauthController 来获取 code</h4><blockquote>
<p>就是定义一个方法供 redirectUris 重定向访问</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.sxdx.spring.security.oauth2.controller;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">import com.sxdx.spring.security.oauth2.entity.KikiResponse;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.security.core.Authentication;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.web.bind.annotation.GetMapping;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.web.bind.annotation.RestController;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import javax.servlet.http.HttpServletRequest;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import javax.servlet.http.HttpServletResponse;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">@RestController</span></pre></td></tr><tr><td class="code"><pre><span class="line">public class KikiOauthController &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    @GetMapping(value &#x3D; &quot;&#x2F;getCode&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public KikiResponse getCode(HttpServletRequest request, HttpServletResponse response)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        return new KikiResponse()</span></pre></td></tr><tr><td class="code"><pre><span class="line">                .put(&quot;code&quot;,request.getParameter(&quot;code&quot;))</span></pre></td></tr><tr><td class="code"><pre><span class="line">                .put(&quot;state&quot;,request.getParameter(&quot;state&quot;));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    @GetMapping(&quot;&#x2F;authentication&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public Object authentication(Authentication authentication)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        return authentication;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h4 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h4><p>1、 浏览器访问如下地址（参数说明参考上一节博客）<br><a href="http://localhost:8001/oauth/authorize?response_type=code&amp;client_id=kiki&amp;redirect_uri=http://localhost:8001/getCode&amp;state=state" target="_blank" rel="noopener">http://localhost:8001/oauth/authorize?response_type=code&amp;client_id=kiki&amp;redirect_uri=http://localhost:8001/getCode&amp;state=state</a><br>访问后页面如下：</p>
<p><img src="/images/oauth2/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%99%BB%E5%BD%95.png" alt="浏览器登录.png"></p>
<p>2、 输入任意用户名，密码为 123456，规则在KikiUserDetailService中已经定义。点击 sign in。</p>
<p><img src="/images/oauth2/%E6%8E%88%E6%9D%83%E7%A0%81%E6%A8%A1%E5%BC%8F-%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BA%BA%E5%B7%A5%E6%8E%88%E6%9D%83.png" alt="授权码模式-浏览器人工授权.png"></p>
<p>3、 选择 Approve ，点击Authorize按钮。</p>
<p><img src="/images/oauth2/%E6%8E%88%E6%9D%83%E7%A0%81-%E8%BF%94%E5%9B%9Ecode.png" alt="授权码-返回code.png"></p>
<p>发现我们已经获取到了code，其中state参数，没有具体意义，在浏览器访问时输入，返回code时原样一同返回。</p>
<p>4、 通过code，获取token。使用postman发送如下请求POST请求 localhost:8001/oauth/token</p>
<p><img src="/images/oauth2/%E6%8E%88%E6%9D%83%E7%A0%81-%E8%8E%B7%E5%8F%96token.png" alt="授权码-获取token.png"></p>
<p>填入获取的code 参数，grant_type为固定值，redirect_uri需要与第1步相同，其余参数在KikiAuthorizationServerConfigurer已经定义。</p>
<p>除此之外还需要设置请求头</p>
<p><img src="/images/oauth2/%E6%8E%88%E6%9D%83%E7%A0%81-%E8%AF%B7%E6%B1%82%E5%A4%B4.png" alt="授权码-请求头.png"></p>
<p>key为Authorization，value为Basic加上client_id:client_secret经过base64加密后的值（可以使用<a href="http://tool.chinaz.com/Tools/Base64.aspx）" target="_blank" rel="noopener">http://tool.chinaz.com/Tools/Base64.aspx）</a></p>
<p><img src="/images/oauth2/%E6%8E%88%E6%9D%83%E7%A0%81-%E5%8A%A0%E5%AF%86%E8%AF%B7%E6%B1%82%E5%A4%B4.png" alt="授权码-加密请求头.png"></p>
<p>5、 发送请求，获取token</p>
<p><img src="/images/oauth2/%E6%8E%88%E6%9D%83%E7%A0%81-%E8%BF%94%E5%9B%9Etoken.png" alt="授权码-返回token.png"></p>
<p>至此，授权码模式已经结束，可通过获取到的token访问资源服务器。一个授权码只能获取一次token，再次访问将会报错。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &quot;error&quot;: &quot;invalid_grant&quot;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &quot;error_description&quot;: &quot;Invalid authorization code: a8VfVM&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>6、通过token获取资源</p>
<p><img src="/images/oauth2/token%E8%8E%B7%E5%8F%96%E8%B5%84%E6%BA%90401.png" alt="token获取资源401.png"></p>
<p>虽然令牌是正确的，但是无法访问/authentication，所以我们必须配置资源服务器，让客户端可以通过合法的令牌来获取资源。<br>资源服务器的配置也很简单，只需要在配置类上使用@EnableResourceServer注解标注即可：</p>
<p>新建资源服务器配置类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.sxdx.spring.security.oauth2.config;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.context.annotation.Configuration;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.security.config.annotation.web.builders.HttpSecurity;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.security.oauth2.config.annotation.web.configuration.EnableResourceServer;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.security.oauth2.config.annotation.web.configuration.ResourceServerConfigurerAdapter;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">@Configuration</span></pre></td></tr><tr><td class="code"><pre><span class="line">@EnableResourceServer</span></pre></td></tr><tr><td class="code"><pre><span class="line">public class KikiResourceServerConfig extends ResourceServerConfigurerAdapter &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>但在添加资源服务器后重启服务，再次重复请求过程，返回：</p>
<p><img src="/images/oauth2/%E9%85%8D%E7%BD%AEOrder.png" alt="配置Order.png"></p>
<p>这是因为security配置服务器与资源服务器有加载优先级，需要确保security配置服务器先于资源服务器加载。我们按Ctrl点击 @EnableResourceServer，再点击 @Import(ResourceServerConfiguration.class)<br>可以看到资源服务器默认Order是3</p>
<p><img src="/images/oauth2/%E8%B5%84%E6%BA%90%E6%9C%8D%E5%8A%A1%E5%99%A8Order.png" alt="资源服务器Order.png"></p>
<p>所以我们在 KikiSecurityConfig 上添加@Order(2)即可。spring 中数字越小说明优先级越高。完整的 KikiSecurityConfig 如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.sxdx.spring.security.oauth2.config;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.context.annotation.Bean;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.core.annotation.Order;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.security.crypto.password.PasswordEncoder;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">@Order(2)</span></pre></td></tr><tr><td class="code"><pre><span class="line">@EnableWebSecurity</span></pre></td></tr><tr><td class="code"><pre><span class="line">public class KikiSecurityConfig extends WebSecurityConfigurerAdapter &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;**</span></pre></td></tr><tr><td class="code"><pre><span class="line">     * Spring Security内部实现好的 BCryptPasswordEncoder。</span></pre></td></tr><tr><td class="code"><pre><span class="line">     * BCryptPasswordEncoder的特点就是，对于一个相同的密码，每次加密出来的加密串都不同</span></pre></td></tr><tr><td class="code"><pre><span class="line">     *&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Bean</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public PasswordEncoder passwordEncoder() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        return new BCryptPasswordEncoder();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>再次重复以上步骤：</p>
<p><img src="/images/oauth2/authentication%E8%AF%B7%E6%B1%82.png" alt="authentication请求.png"></p>
<h3 id="密码模式（resource-owner-password-credentials）"><a href="#密码模式（resource-owner-password-credentials）" class="headerlink" title="密码模式（resource owner password credentials）"></a>密码模式（resource owner password credentials）</h3><p> 密码模式比起授权码模式来说，相对简单些。我们在postman中请求：localhost:8001/oauth/token?grant_type=password&amp;username=garnett&amp;password=123456</p>
<p> <img src="/images/oauth2/unsupported_grant_type.png" alt="unsupported_grant_type.png"></p>
<p> 这是因为密码模式需要用到 AuthenticationManager。</p>
<h4 id="注入AuthenticationManager"><a href="#注入AuthenticationManager" class="headerlink" title="注入AuthenticationManager"></a>注入AuthenticationManager</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.sxdx.spring.security.oauth2.config;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.context.annotation.Bean;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.core.annotation.Order;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.security.authentication.AuthenticationManager;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.security.crypto.password.PasswordEncoder;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">@Order(2)</span></pre></td></tr><tr><td class="code"><pre><span class="line">@EnableWebSecurity</span></pre></td></tr><tr><td class="code"><pre><span class="line">public class KikiSecurityConfig extends WebSecurityConfigurerAdapter &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;**</span></pre></td></tr><tr><td class="code"><pre><span class="line">     * Spring Security内部实现好的 BCryptPasswordEncoder。</span></pre></td></tr><tr><td class="code"><pre><span class="line">     * BCryptPasswordEncoder的特点就是，对于一个相同的密码，每次加密出来的加密串都不同</span></pre></td></tr><tr><td class="code"><pre><span class="line">     *&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Bean</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public PasswordEncoder passwordEncoder() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        return new BCryptPasswordEncoder();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;**</span></pre></td></tr><tr><td class="code"><pre><span class="line">     * 密码模式需要用到</span></pre></td></tr><tr><td class="code"><pre><span class="line">     * @return</span></pre></td></tr><tr><td class="code"><pre><span class="line">     * @throws Exception</span></pre></td></tr><tr><td class="code"><pre><span class="line">     *&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Bean</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public AuthenticationManager authenticationManagerBean() throws Exception &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        return super.authenticationManagerBean();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<blockquote>
<p>注入了authenticationManagerBean 对象。</p>
</blockquote>
<h4 id="修改认证服务器"><a href="#修改认证服务器" class="headerlink" title="修改认证服务器"></a>修改认证服务器</h4><p>接下来修改KikiAuthorizationServerConfigurer认证服务器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.sxdx.spring.security.oauth2.config;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">import com.sxdx.spring.security.oauth2.service.KikiUserDetailService;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.context.annotation.Configuration;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.core.annotation.Order;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.security.authentication.AuthenticationManager;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.security.crypto.password.PasswordEncoder;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.security.oauth2.config.annotation.configurers.ClientDetailsServiceConfigurer;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.security.oauth2.config.annotation.web.configuration.AuthorizationServerConfigurerAdapter;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.security.oauth2.config.annotation.web.configuration.EnableAuthorizationServer;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.security.oauth2.config.annotation.web.configurers.AuthorizationServerEndpointsConfigurer;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;**</span></pre></td></tr><tr><td class="code"><pre><span class="line"> * 认证服务器配置</span></pre></td></tr><tr><td class="code"><pre><span class="line"> *&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">@EnableAuthorizationServer</span></pre></td></tr><tr><td class="code"><pre><span class="line">@Configuration</span></pre></td></tr><tr><td class="code"><pre><span class="line">public class KikiAuthorizationServerConfigurer extends AuthorizationServerConfigurerAdapter &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Autowired</span></pre></td></tr><tr><td class="code"><pre><span class="line">    private PasswordEncoder passwordEncoder;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Autowired</span></pre></td></tr><tr><td class="code"><pre><span class="line">    private AuthenticationManager authenticationManager;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Autowired</span></pre></td></tr><tr><td class="code"><pre><span class="line">    private KikiUserDetailService userDetailService;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Override</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public void configure(AuthorizationServerEndpointsConfigurer endpoints)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            throws Exception &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        endpoints.authenticationManager(authenticationManager).</span></pre></td></tr><tr><td class="code"><pre><span class="line">        userDetailsService(userDetailService);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Override</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public void configure(ClientDetailsServiceConfigurer clients) throws Exception &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        clients.inMemory()</span></pre></td></tr><tr><td class="code"><pre><span class="line">                .withClient(&quot;kiki&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                .secret(passwordEncoder.encode(&quot;123456&quot;))</span></pre></td></tr><tr><td class="code"><pre><span class="line">                .authorizedGrantTypes(&quot;password&quot;, &quot;refresh_token&quot;,&quot;authorization_code&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                .scopes(&quot;all&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                .redirectUris(&quot;http:&#x2F;&#x2F;localhost:8001&#x2F;getCode&quot;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<blockquote>
<p>重写了configure(AuthorizationServerEndpointsConfigurer endpoints) 。</p>
</blockquote>
<h4 id="演示-1"><a href="#演示-1" class="headerlink" title="演示"></a>演示</h4><p>重启服务，再次获取token：</p>
<p> <img src="/images/oauth2/%E5%AF%86%E7%A0%81%E6%A8%A1%E5%BC%8F-%E8%8E%B7%E5%8F%96token.png" alt="密码模式-获取token.png"></p>
<p> 通过token获取资源：</p>
<p>  <img src="/images/oauth2/%E5%AF%86%E7%A0%81%E6%A8%A1%E5%BC%8F-token%E8%8E%B7%E5%8F%96%E8%B5%84%E6%BA%90.png" alt="密码模式-token获取资源.png"></p>
<p>在这里发现一个问题，就是上面密码模式获取到了对应的资源，我一开始以为万事大吉了。<br>当再次启动服务并先通过密码模式获取token，继而通过token获取资源/authentication时发现再次报401错误了。多次试验发现规律：<br>先用密码模式的token获取资源就会报401。<br>先用授权码模式获取的token来请求资源没问题，这个之后再通过密码模式获取资源就也变正常了。</p>
<p>解决方法：在KikiSecurityConfig中添加如下配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span></pre></td></tr><tr><td class="code"><pre><span class="line">protected void configure(HttpSecurity http) throws Exception &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    http.requestMatchers()</span></pre></td></tr><tr><td class="code"><pre><span class="line">            .antMatchers(&quot;&#x2F;oauth&#x2F;**&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            .and()</span></pre></td></tr><tr><td class="code"><pre><span class="line">            .authorizeRequests()</span></pre></td></tr><tr><td class="code"><pre><span class="line">            .antMatchers(&quot;&#x2F;oauth&#x2F;**&quot;).authenticated()</span></pre></td></tr><tr><td class="code"><pre><span class="line">            .and()</span></pre></td></tr><tr><td class="code"><pre><span class="line">            .csrf().disable();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>至此，密码模式介绍完毕！</p>
<p>不过添加这个后申请授权码页面会报403，所以需要确认下授权码模式和密码模式是否可以共存。待研究后再更新文章。</p>
<p>关于上面的问题，各种尝试后终于解决：修改ikiSecurityConfig中添加如下配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http.requestMatchers()</span></pre></td></tr><tr><td class="code"><pre><span class="line">                .antMatchers(&quot;&#x2F;oauth&#x2F;**&quot;,&quot;&#x2F;login&#x2F;**&quot;,&quot;&#x2F;logout&#x2F;**&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                .and()</span></pre></td></tr><tr><td class="code"><pre><span class="line">                .authorizeRequests()</span></pre></td></tr><tr><td class="code"><pre><span class="line">                .antMatchers(&quot;&#x2F;oauth&#x2F;**&quot;).authenticated()</span></pre></td></tr><tr><td class="code"><pre><span class="line">                .and()</span></pre></td></tr><tr><td class="code"><pre><span class="line">                .csrf().disable()</span></pre></td></tr><tr><td class="code"><pre><span class="line">                .formLogin().permitAll();</span></pre></td></tr></table></figure>

<p>至此，我们的项目已经同时支持授权码模式、密码模式了。</p>
<h3 id="客户端模式（client-credentials）"><a href="#客户端模式（client-credentials）" class="headerlink" title="客户端模式（client credentials）"></a>客户端模式（client credentials）</h3><p>这里简单介绍下客户端模式：这种模式直接根据client的id和密钥即可获取token，无需用户参与。这种模式比较合适消费api的后端服务，不支持refresh token。</p>
<p>我们修改KikiAuthorizationServerConfigurer 的configure(ClientDetailsServiceConfigurer clients)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">clients.inMemory()</span></pre></td></tr><tr><td class="code"><pre><span class="line">        .withClient(&quot;kiki&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        .secret(passwordEncoder.encode(&quot;123456&quot;))</span></pre></td></tr><tr><td class="code"><pre><span class="line">        .authorizedGrantTypes(&quot;password&quot;, &quot;refresh_token&quot;,&quot;authorization_code&quot;,&quot;client_credentials&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        .autoApprove(true)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        .scopes(&quot;all&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        .redirectUris(&quot;http:&#x2F;&#x2F;localhost:8001&#x2F;getCode&quot;)</span></pre></td></tr></table></figure>
<p>添加kiki这个client对client_credentials的支持，但是注意：client_credentials和refresh_token是互斥的。以下演示可以证明：</p>
<h4 id="演示-2"><a href="#演示-2" class="headerlink" title="演示"></a>演示</h4><p>通过postman获取token：<a href="http://localhost:8001/oauth/token?grant_type=client_credentials&amp;client_id=kiki&amp;state=state" target="_blank" rel="noopener">http://localhost:8001/oauth/token?grant_type=client_credentials&amp;client_id=kiki&amp;state=state</a></p>
<p><img src="/images/oauth2/%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%A8%A1%E5%BC%8F%E8%8E%B7%E5%8F%96token.png" alt="客户端模式获取token.png"></p>
<p>（别忘记添加Authorization请求头）其中 grant_type 固定为 client_credentials，返回的token信息与授权码、密码模式获取的比较发现少了refresh_token。<br>这也证明了client_credentials模式不支持refresh_token。</p>
<p>接下来通过token获取资源：</p>
<p><img src="/images/oauth2/%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%A8%A1%E5%BC%8Ftoken%E8%8E%B7%E5%8F%96%E8%B5%84%E6%BA%90.png" alt="客户端模式token获取资源.png"></p>
<h3 id="授权码模式扩展"><a href="#授权码模式扩展" class="headerlink" title="授权码模式扩展"></a>授权码模式扩展</h3><h4 id="使用自定义登录页"><a href="#使用自定义登录页" class="headerlink" title="使用自定义登录页"></a>使用自定义登录页</h4><h4 id=""><a href="#" class="headerlink" title=""></a></h4><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>现在我们的项目就同时支持授权码模式、密码模式以及客户端模式了。一般来说，安全性最好的是授权码模式<br>即外部系统访问我们的系统使用授权码模式（无需提供给他们用户名密码），内部可信系统直接使用密码模式、或者客户端模式即可。</p>
<h2 id="postman-oauth2-调试使用技巧"><a href="#postman-oauth2-调试使用技巧" class="headerlink" title="postman oauth2 调试使用技巧"></a>postman oauth2 调试使用技巧</h2><p>在授权码调试过程中，我们需要用到浏览器和postman。来回切换十分麻烦。其实postman提供了很好的调试方法：</p>
<p><img src="/images/oauth2/postman-oauth2-%E6%8E%88%E6%9D%83%E7%A0%811.png" alt="postman-oauth2-授权码1.png"></p>
<p>点击 Get New Access Token 按钮配置获取授权码获取token。</p>
<p><img src="/images/oauth2/postman-oauth2-%E6%8E%88%E6%9D%83%E7%A0%812.png" alt="postman-oauth2-授权码2.png"></p>
<p>按引导操作即可模拟操作。这个稍微研究下就会了，密码模式大同小异，不再演示了。</p>
<p>参考链接：<br><a href="https://mrbird.cc/Spring-Security-OAuth2-Guide.html" target="_blank" rel="noopener">https://mrbird.cc/Spring-Security-OAuth2-Guide.html</a><br><a href="http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html</a></p>
]]></content>
      <categories>
        <category>OAuth2</category>
        <category>Spring-Security</category>
      </categories>
      <tags>
        <tag>OAuth2</tag>
        <tag>Spring-Security</tag>
      </tags>
  </entry>
  <entry>
    <title>spring security oauth2 基础知识</title>
    <url>/2019/12/08/spring-security-oauth2-01/</url>
    <content><![CDATA[<div class="note info">
            <p>OAuth（开放授权）是一个开放标准，允许用户授权第三方移动应用访问他们存储在另外的服务提供者上的信息，而不需要将用户名和密码提供给第三方移动应用或分享他们数据的所有内容，OAuth2.0是OAuth协议的延续版本，但不向后兼容OAuth 1.0即完全废止了OAuth1.0。</p>
          </div>

<div class="note info">
            <p>OAuth是一种用来规范令牌（Token）发放的授权机制，主要包含了四种授权模式：授权码模式、简化模式、密码模式和客户端模式。Spring Security OAuth2对这四种授权模式进行了实现.</p>
          </div>

<h2 id="名词定义"><a href="#名词定义" class="headerlink" title="名词定义"></a>名词定义</h2><p>（1）Third-party application：第三方应用程序，本文中又称”客户端”（client）。<br>（2）HTTP service：HTTP服务提供商，本文中简称”服务提供商”。<br>（3）Resource Owner：资源所有者。<br>（4）User Agent：用户代理，本文中就是指浏览器。<br>（5）Authorization server：认证服务器，即服务提供商专门用来处理认证的服务器。<br>（6）Resource server：资源服务器，即服务提供商存放用户生成的资源的服务器。它与认证服务器，可以是同一台服务器，也可以是不同的服务器。</p>
<p>目前只用到过授权码模式、密码模式。另外两种不怎么常见。</p>
<h2 id="授权码模式"><a href="#授权码模式" class="headerlink" title="授权码模式"></a>授权码模式</h2><p>授权码模式（authorization code）是功能最完整、流程最严密的授权模式。它的特点就是通过客户端的后台服务器，与”服务提供商”的认证服务器进行互动。</p>
<p><img src="/images/oauth2/%E6%8E%88%E6%9D%83%E7%A0%81%E6%A8%A1%E5%BC%8F.png" alt="授权码模式"> </p>
<p>*步骤如下：<br>（A）用户打开客户端以后，客户端要求用户给予授权。<br>（B）用户同意给予客户端授权。<br>（C）客户端使用上一步获得的授权，向认证服务器申请令牌。<br>（D）认证服务器对客户端进行认证以后，确认无误，同意发放令牌。<br>（E）客户端使用令牌，向资源服务器申请获取资源。<br>（F）资源服务器确认令牌无误，同意向客户端开放资源。</p>
<ol>
<li>A步骤中，客户端申请认证的URI，包含以下参数：</li>
</ol>
<ul>
<li>response_type：表示授权类型，必选项，此处的值固定为”code”</li>
<li>client_id：表示客户端的ID，必选项</li>
<li>redirect_uri：表示重定向URI，可选项</li>
<li>scope：表示申请的权限范围，可选项</li>
<li>state：表示客户端的当前状态，可以指定任意值，认证服务器会原封不动地返回这个值。</li>
</ul>
<ol start="2">
<li>C步骤中，服务器回应客户端的URI，包含以下参数：</li>
</ol>
<ul>
<li>code：表示授权码，必选项。该码的有效期应该很短，通常设为10分钟，客户端只能使用该码一次，否则会被授权服务器拒绝。该码与客户端ID和重定向URI，是一 一对应关系。</li>
<li>state：如果客户端的请求中包含这个参数，认证服务器的回应也必须一模一样包含这个参数。</li>
</ul>
<ol start="3">
<li>D步骤中，客户端向认证服务器申请令牌的HTTP请求，包含以下参数：</li>
</ol>
<ul>
<li>grant_type：表示使用的授权模式，必选项，此处的值固定为”authorization_code”。</li>
<li>code：表示上一步获得的授权码，必选项。</li>
<li>redirect_uri：表示重定向URI，必选项，且必须与A步骤中的该参数值保持一致。</li>
<li>client_id：表示客户端ID，必选项。</li>
<li>client_id：表示客户端ID，必选项。</li>
</ul>
<h2 id="密码模式"><a href="#密码模式" class="headerlink" title="密码模式"></a>密码模式</h2><p>   密码模式（Resource Owner Password Credentials Grant）中，用户向客户端提供自己的用户名和密码。客户端使用这些信息，向认证服务器索要授权。</p>
<p><img src="/images/oauth2/%E5%AF%86%E7%A0%81%E6%A8%A1%E5%BC%8F.png" alt="密码模式"></p>
<p>步骤如下：<br>（A）用户向客户端提供用户名和密码。<br>（B）客户端将用户名和密码发给认证服务器，向后者请求令牌。<br>（C）认证服务器确认无误后，向客户端提供访问令牌。</p>
<p>B步骤中，客户端发出的HTTP请求，包含以下参数：</p>
<ul>
<li>grant_type：表示授权类型，此处的值固定为”password”，必选项。</li>
<li>username：表示用户名，必选项。</li>
<li>password：表示用户的密码，必选项。</li>
<li>scope：表示权限范围，可选项。</li>
</ul>
<h2 id="客户端模式"><a href="#客户端模式" class="headerlink" title="客户端模式"></a>客户端模式</h2><p> 这种模式直接根据client的id和密钥即可获取token，无需用户参与。这种模式比较合适消费api的后端服务，不支持refresh token</p>
<h2 id="简化模式（implicit）"><a href="#简化模式（implicit）" class="headerlink" title="简化模式（implicit）"></a>简化模式（implicit）</h2><p> 这种模式比授权码模式少了code环节，回调url直接携带token，这种模式的使用场景是基于浏览器的应用<br> 这种模式基于安全性考虑，建议把token时效设置短一些，不支持refresh token</p>
<h2 id="Spring-Security-OAuth2"><a href="#Spring-Security-OAuth2" class="headerlink" title="Spring Security OAuth2"></a>Spring Security OAuth2</h2><p>Spring框架对OAuth2协议进行了实现，<br>Spring Security OAuth2主要包含认证服务器和资源服务器这两大块的实现：</p>
<p><img src="/images/oauth2/spring-security-oauth2.png" alt="spring-security-oauth2"></p>
<p>认证服务器主要包含了四种授权模式的实现和Token的生成与存储；<br>资源服务器主要是在Spring Security的过滤器链上加了OAuth2AuthenticationProcessingFilter过滤器，即使用OAuth2协议发放令牌认证的方式来保护我们的资源。</p>
<h2 id="补充知识：关于scope参数的说明（小黄人语录）"><a href="#补充知识：关于scope参数的说明（小黄人语录）" class="headerlink" title="补充知识：关于scope参数的说明（小黄人语录）"></a>补充知识：关于scope参数的说明（小黄人语录）</h2><div class="note success">
            <p>a服务 resourceId ： a<br>b服务 resourceId ： b</p><p>Client1：clientid: client1 ,scopse: read,      resourceId:a,b<br>Client2：clientid: client2 ,scopse: read,write,resourceId:a,b</p><p>a服务 某个方法加 @PreAuthorize(“#oauth2.hasScope(‘read’)”)<br>b服务 某个方法加 @PreAuthorize(“#oauth2.hasScope(‘write’)”)</p><p>那么: client1这个客户端就只能访问a服务和b服务的加了read标识的方法<br>      client2这个client就能同时访问加了read 和 write的方法</p><p>每个服务都应该有个 resourceId，新建 clientDetails 的时候也可以指定 resourceId，不指定就能访问所有，指定了只能访问指定的，访问其他的就会抛异常</p>
          </div>


<p><em>下一章演示代码实例</em></p>
<p>参考链接：<br><a href="https://mrbird.cc/Spring-Security-OAuth2-Guide.html" target="_blank" rel="noopener">https://mrbird.cc/Spring-Security-OAuth2-Guide.html</a><br><a href="http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html</a></p>
]]></content>
      <categories>
        <category>OAuth2</category>
        <category>Spring-Security</category>
      </categories>
      <tags>
        <tag>OAuth2</tag>
        <tag>Spring-Security</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown基础语法</title>
    <url>/2019/11/29/markdown-study/</url>
    <content><![CDATA[<h1 id="MarkDown基础语法"><a href="#MarkDown基础语法" class="headerlink" title="MarkDown基础语法"></a>MarkDown基础语法</h1><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">用法:</span></pre></td></tr><tr><td class="code"><pre><span class="line"># 一级标题</span></pre></td></tr><tr><td class="code"><pre><span class="line">## 二级标题</span></pre></td></tr></table></figure>



<h2 id="段落及区块引用"><a href="#段落及区块引用" class="headerlink" title="段落及区块引用"></a>段落及区块引用</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">用法:</span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt; 高亮练习...</span></pre></td></tr></table></figure>

<p>效果如下:</p>
<blockquote>
<p>高亮练习…</p>
</blockquote>
<a id="more"></a>

<h2 id="链接和图片"><a href="#链接和图片" class="headerlink" title="链接和图片"></a>链接和图片</h2> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">用法:</span></pre></td></tr><tr><td class="code"><pre><span class="line">1、打开一个页面</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&lt;a href&#x3D;&quot;https:&#x2F;&#x2F;www.cnblogs.com&#x2F;&quot; target&#x3D;&quot;_blank&quot;&gt;新页面跳转到博客园&lt;&#x2F;a&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">2、当前页面打开</span></pre></td></tr><tr><td class="code"><pre><span class="line">	[当前页面跳转到博客园](https:&#x2F;&#x2F;www.cnblogs.com&#x2F;&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">3、图片</span></pre></td></tr><tr><td class="code"><pre><span class="line">	![图片](https:&#x2F;&#x2F;upload-images.jianshu.io&#x2F;upload_images&#x2F;703764-605e3cc2ecb664f6.jpg?imageMogr2&#x2F;auto-orient&#x2F;strip%7CimageView2&#x2F;2&#x2F;w&#x2F;1240)</span></pre></td></tr></table></figure>
<p> 效果如下:</p>
<p> <a href="https://www.cnblogs.com/" target="_blank">新页面跳转到博客园</a></p>
<p><a href="https://www.cnblogs.com/" target="_blank" rel="noopener">当前页面跳转到博客园</a></p>
<p><img src="https://upload-images.jianshu.io/upload_images/703764-605e3cc2ecb664f6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片"></p>
<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">用法:(*或+或-标识)</span></pre></td></tr><tr><td class="code"><pre><span class="line">*	段落1</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	&gt;段落2沙发士大夫撒旦</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	暗示法法师</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">*	段落2</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	&gt; sdfsasfa</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">* 	段落3</span></pre></td></tr></table></figure>

<ul>
<li><p>段落1</p>
<blockquote>
<p>段落2沙发士大夫撒旦</p>
</blockquote>
<p>暗示法法师</p>
</li>
<li><p>段落2</p>
<blockquote>
<p>sdfsasfa</p>
</blockquote>
</li>
<li><p>段落3</p>
</li>
</ul>
<h3 id="有序列表练习"><a href="#有序列表练习" class="headerlink" title="有序列表练习:"></a>有序列表练习:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">用法:</span></pre></td></tr><tr><td class="code"><pre><span class="line">1. 1</span></pre></td></tr><tr><td class="code"><pre><span class="line">2. 2</span></pre></td></tr><tr><td class="code"><pre><span class="line">3. 3</span></pre></td></tr></table></figure>

<ol>
<li>1</li>
<li>2</li>
<li>3</li>
</ol>
<h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">用法:</span></pre></td></tr><tr><td class="code"><pre><span class="line">*** </span></pre></td></tr><tr><td class="code"><pre><span class="line">或者</span></pre></td></tr><tr><td class="code"><pre><span class="line">---</span></pre></td></tr></table></figure>

<p>效果如下:</p>
<hr>
<h2 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h2><blockquote>
<p>使用*或_包裹即可。使用单一符号标记的效果是斜体，使用两个符号标记的效果是加粗</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">用法:</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">*这里是斜体*</span></pre></td></tr><tr><td class="code"><pre><span class="line">_这里是斜体_</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">**这里是加粗**</span></pre></td></tr><tr><td class="code"><pre><span class="line">__这里是加粗__</span></pre></td></tr></table></figure>
<p>效果如下:</p>
<p><em>这里是斜体</em><br><em>这里是斜体</em></p>
<p><strong>这里是加粗</strong><br><strong>这里是加粗</strong></p>
<h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><blockquote>
<p>使用反引号 `</p>
</blockquote>
<p>一行代码:</p>
<p><code>source.registerCorsConfiguration(&quot;/**&quot;, cors);</code></p>
<p>多行代码:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Bean</span></pre></td></tr><tr><td class="code"><pre><span class="line">   public CorsWebFilter corsFilter() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       UrlBasedCorsConfigurationSource source &#x3D; new UrlBasedCorsConfigurationSource(new PathPatternParser());</span></pre></td></tr><tr><td class="code"><pre><span class="line">       CorsConfiguration cors &#x3D; new CorsConfiguration();</span></pre></td></tr><tr><td class="code"><pre><span class="line">       cors.setAllowCredentials(true);</span></pre></td></tr><tr><td class="code"><pre><span class="line">       cors.addAllowedOrigin(CorsConfiguration.ALL);</span></pre></td></tr><tr><td class="code"><pre><span class="line">       cors.addAllowedHeader(CorsConfiguration.ALL);</span></pre></td></tr><tr><td class="code"><pre><span class="line">       cors.addAllowedMethod(CorsConfiguration.ALL);</span></pre></td></tr><tr><td class="code"><pre><span class="line">       source.registerCorsConfiguration(&quot;&#x2F;**&quot;, cors);</span></pre></td></tr><tr><td class="code"><pre><span class="line">       return new CorsWebFilter(source);</span></pre></td></tr><tr><td class="code"><pre><span class="line">   &#125;</span></pre></td></tr></table></figure>
<h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">用法</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">|序号(左对齐)|姓名(居中)|年龄(右对齐)|</span></pre></td></tr><tr><td class="code"><pre><span class="line">|:---|:---:|---:|</span></pre></td></tr><tr><td class="code"><pre><span class="line">|1   |张三  |23 |</span></pre></td></tr><tr><td class="code"><pre><span class="line">|2   |李四  |33 |</span></pre></td></tr></table></figure>

<blockquote>
<p>说明:默认居左,对中间使用几个-没有要求</p>
</blockquote>
<p>:--- 表示文字居左</p>
<p>---: 表示文字居右</p>
<p>:---: 表示文字居中。</p>
<table>
<thead>
<tr>
<th align="left">序号(左对齐)</th>
<th align="center">姓名(居中)</th>
<th align="right">年龄(右对齐)</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="center">张三</td>
<td align="right">23</td>
</tr>
<tr>
<td align="left">2</td>
<td align="center">李四</td>
<td align="right">33</td>
</tr>
</tbody></table>
<h2 id="特殊字符-使用时需要在前面加转义字符"><a href="#特殊字符-使用时需要在前面加转义字符" class="headerlink" title="特殊字符:使用时需要在前面加转义字符 \"></a>特殊字符:使用时需要在前面加转义字符 \</h2><p>需要处理的特殊字符有:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\   反斜线</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#96;   反引号</span></pre></td></tr><tr><td class="code"><pre><span class="line">*   星号</span></pre></td></tr><tr><td class="code"><pre><span class="line">_   底线</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;&#125;  花括号</span></pre></td></tr><tr><td class="code"><pre><span class="line">[]  方括号</span></pre></td></tr><tr><td class="code"><pre><span class="line">()  括弧</span></pre></td></tr><tr><td class="code"><pre><span class="line">#   井字号</span></pre></td></tr><tr><td class="code"><pre><span class="line">+   加号</span></pre></td></tr><tr><td class="code"><pre><span class="line">-   减号</span></pre></td></tr><tr><td class="code"><pre><span class="line">.   英文句点</span></pre></td></tr><tr><td class="code"><pre><span class="line">!   惊叹号</span></pre></td></tr></table></figure>

<p>例如:</p>
<p>\ 需要 写为 \\</p>
<p>* 需要 写为 \*</p>
<blockquote>
<p>参考:<a href="https://www.jianshu.com/p/335db5716248" target="_blank" rel="noopener">https://www.jianshu.com/p/335db5716248</a></p>
</blockquote>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
</search>
