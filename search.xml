<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>数据库索引</title>
    <url>/2020/02/27/database-index-01/</url>
    <content><![CDATA[<div class="note info">
            <p>MySQL官方对索引的定义为：索引（Index）是帮助MySQL高效获取数据的数据结构。即索引的本质：索引是数据结构。<br>但方法都是有利有弊，索引在方便你查询的时候，也要牺牲磁盘的空间为代价。<br>数据库索引可以协助快速查询,更新数据库中表的数据.索引的实现通常使用B树和变种的B+树(mysql常用的索引就是B+树)</p>
          </div>

<h2 id="索引结构分类"><a href="#索引结构分类" class="headerlink" title="索引结构分类"></a>索引结构分类</h2><p>Mysql目前主要有以下几种索引结构：HASH，BTREE，RTREE</p>
<ul>
<li><p>BTREE<br>BTREE索引就是一种将索引值按一定的算法，存入一个树形的数据结构中（二叉树），每次查询都是从树的入口root开始，依次遍历node，获取leaf。<br><label style="color:red">BTREE是MySQL里默认和最常用的索引类型</label></p>
</li>
<li><p>HASH<br>由于HASH的唯一（几乎100%的唯一）及类似键值对的形式，很适合作为索引。<br>HASH索引可以一次定位，不需要像树形索引那样逐层查找,因此具有极高的效率。但是，这种高效是有条件的，即只在“=”和“in”条件下高效，对于范围查询、排序及组合索引仍然效率不高。</p>
</li>
<li><p>RTREE<br>RTREE在MySQL很少使用，仅支持geometry数据类型，支持该类型的存储引擎只有MyISAM、BDb、InnoDb、NDb、Archive几种。<br>相对于BTREE，RTREE的优势在于范围查找。</p>
</li>
</ul>
<h2 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h2><p>mysql 索引有2种分类标准</p>
<ol>
<li>从物理存储角度分为：聚簇索引、非聚簇索引</li>
<li>从逻辑存储角度分为：普通索引、唯一索引、主键索引、组合索引、全文索引</li>
</ol>
<h3 id="聚簇索引和非聚簇索引"><a href="#聚簇索引和非聚簇索引" class="headerlink" title="聚簇索引和非聚簇索引"></a>聚簇索引和非聚簇索引</h3><ul>
<li><p>聚簇索引：是对磁盘上实际数据重新组织以按指定的一个或多个列的值排序的算法。特点是存储数据的顺序和索引顺序一致。<br><label style="color:red">一个表只能有一个聚簇索引。主键索引一般都是聚簇索引</label></p>
</li>
<li><p>非聚簇索引：表数据存储顺序与索引顺序无关。对于非聚簇索引，叶结点包含索引字段值及指向数据页数据行的逻辑指针，其行数量与数据表行数据量一致。非聚簇索引记录的物理顺序与逻辑顺序没有必然的联系，与数据的存储物理结构没有关系；一个表对应的非聚簇索引可以有多条，根据不同列的约束可以建立不同要求的非聚簇索引；</p>
</li>
</ul>
<p>建立聚簇索引的语句：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE CLUSTER INDEX index_name ON table_name(column_name1,...);</span></pre></td></tr></table></figure>

<h4 id="聚簇索引-VS-非聚簇索引"><a href="#聚簇索引-VS-非聚簇索引" class="headerlink" title="聚簇索引 VS 非聚簇索引"></a>聚簇索引 VS 非聚簇索引</h4><ul>
<li>聚簇索引的叶子节点就是数据节点（Innodb的B+树的主键对应的数据节点），非聚簇索引的叶子节点仍然是索引节点，只不过有指向对应数据块的指针。</li>
<li>聚簇索引主键的插入速度要比非聚簇索引主键的插入速度慢很多。聚簇索引适合排序，非聚簇索引不适合用在排序的场合。因为聚簇索引本身已经是按照物理顺序放置的，排序很快。非聚簇索引则没有按序存放，需要额外消耗资源来排序。</li>
</ul>
<h3 id="普通索引、唯一索引、主键索引、组合索引、全文索引"><a href="#普通索引、唯一索引、主键索引、组合索引、全文索引" class="headerlink" title="普通索引、唯一索引、主键索引、组合索引、全文索引"></a>普通索引、唯一索引、主键索引、组合索引、全文索引</h3><h4 id="普通索引（NORMAL）"><a href="#普通索引（NORMAL）" class="headerlink" title="普通索引（NORMAL）"></a>普通索引（NORMAL）</h4><blockquote>
<p>仅加速查询,无限制</p>
</blockquote>
<h4 id="唯一索引（UNIQUE）"><a href="#唯一索引（UNIQUE）" class="headerlink" title="唯一索引（UNIQUE）"></a>唯一索引（UNIQUE）</h4><blockquote>
<p>加速查询 + 列值唯一（可以有null）,如果是组合索引，则列值的组合必须唯一</p>
</blockquote>
<h4 id="主键索引-PRIMARY-KEY"><a href="#主键索引-PRIMARY-KEY" class="headerlink" title="主键索引 (PRIMARY KEY)"></a>主键索引 (PRIMARY KEY)</h4><blockquote>
<p>加速查询 + 列值唯一（不可以有null）+ 表中只允许有一个主键索引, 是一种特殊的唯一索引</p>
</blockquote>
<h4 id="组合索引"><a href="#组合索引" class="headerlink" title="组合索引"></a>组合索引</h4><blockquote>
<p>多列值组成一个索引，专门用于组合搜索，其效率大于索引合并（索引合并：使用多个单列索引组合搜索）<br>只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。使用组合索引时遵循最左前缀集合</p>
</blockquote>
<p>eg: 我们新建一张表：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE mytable( ID INT NOT NULL, username VARCHAR(16) NOT NULL, city VARCHAR(50) NOT NULL, age INT NOT NULL );</span></pre></td></tr></table></figure>
<p>为了进一步榨取MySQL的效率，就要考虑建立组合索引。就是将 name, city, age建到一个索引里：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE mytable ADD INDEX name_city_age (name(10),city,age);</span></pre></td></tr></table></figure>
<p>建表时，usernname长度为 16，这里用 10。这是因为一般情况下名字的长度不会超过10，这样会加速索引查询速度，还会减少索引文件的大小，提高INSERT的更新速度。<br>如果分别在 usernname，city，age上建立单列索引，让该表有3个单列索引，查询时和上述的组合索引效率也会大不一样，远远低于我们的组合索引。虽然此时有了三个索引，但MySQL只能用到其中的那个它认为似乎是最有效率的单列索引。</p>
<p>建立这样的组合索引，其实是相当于分别建立了下面三组组合MySQL数据库索引：</p>
<ol>
<li>usernname,city,age</li>
<li>usernname,city</li>
<li>usernname </li>
</ol>
<p>为什么没有 city，age这样的组合索引呢？这是因为MySQL组合索引“最左前缀”的结果。简单的理解就是只从最左面的开始组合。并不是只要包含这三列的查询都会用到该组合索引，下面的几个SQL就会用到这个组合MySQL数据库索引：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM mytable WHREE username&#x3D;&quot;admin&quot; AND city&#x3D;&quot;郑州&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">SELECT * FROM mytable WHREE username&#x3D;&quot;admin&quot;</span></pre></td></tr></table></figure>
<p>而下面几个则不会用到：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM mytable WHREE age&#x3D;20 AND city&#x3D;&quot;郑州&quot; </span></pre></td></tr><tr><td class="code"><pre><span class="line">SELECT * FROM mytable WHREE city&#x3D;&quot;郑州&quot;</span></pre></td></tr></table></figure>


<h4 id="全文索引-FULLTEXT"><a href="#全文索引-FULLTEXT" class="headerlink" title="全文索引 (FULLTEXT)"></a>全文索引 (FULLTEXT)</h4><blockquote>
<p>它能够利用【分词技术】等多种算法智能分析出文本文字中关键词的频率和重要性，然后按照一定的算法规则智能地筛选出我们想要的搜索结果。</p>
</blockquote>
<p>全文索引，以前只有MyISAM引擎支持。Mysql5.6后开始默认使用InnoDb引擎，并且5.6.4版本后的InnoDb引擎开始支持全文索引。<br>目前只有 CHAR、VARCHAR 、TEXT 列上可以创建全文索引。</p>
<p>select * from article where content like ‘%xxx%’;这种写法查询效率非常低。全文索引就是为了高效的解决这种问题产生的。</p>
<p>具体如何使用全文索引呢？</p>
<p>不用全文索引时的写法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM article WHERE content LIKE &#39;%查询字符串%&#39;;</span></pre></td></tr></table></figure>

<p>如果我们在content字段建立了全文索引，那么使用全文索引的写法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM article WHERE MATCH(title,content) AGAINST (&#39;查询字符串&#39;);</span></pre></td></tr></table></figure>

<p>注意：在数据量较大时候，我们应该先将数据放入一个没有全局索引的表中，然后再用CREATE index创建fulltext索引，要比先为一张表建立fulltext然后再将数据写入的查询速度快。</p>
<h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><blockquote>
<p>select的数据列只用从索引中就能够取得，不必读取数据行，换句话说查询列要被所建的索引覆盖</p>
</blockquote>
<p>例如：<br>表 user 中有一个组合索引 idx_name_sex(name,sex)。<br>当我们通过SQL语句：select name from user where name = ‘garnett’;的时候，就可以通过覆盖索引查询.</p>
<h2 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h2><h3 id="需要建立索引的情况"><a href="#需要建立索引的情况" class="headerlink" title="需要建立索引的情况"></a>需要建立索引的情况</h3><ul>
<li>主键自动建立主键索引 (PRIMARY KEY)</li>
<li>频繁作为查询条件的字段</li>
<li>与其他表关联的字段，外键关系创建索引。（eg：user表中的dept_id）</li>
<li>查询中统计或者分组的字段</li>
</ul>
<h3 id="不适合建立索引的情况"><a href="#不适合建立索引的情况" class="headerlink" title="不适合建立索引的情况"></a>不适合建立索引的情况</h3><ul>
<li>表记录太少就别建索引了</li>
<li>频繁更新的字段不要创建索引</li>
<li>数据列重复的字段不需要创建索引，没必要。（eg：性别字段，不是男就是女）</li>
<li>对于那些在查询中很少使用或者参考的列不应该创建索引</li>
</ul>
<h2 id="索引失效情况"><a href="#索引失效情况" class="headerlink" title="索引失效情况"></a>索引失效情况</h2><ul>
<li>果条件中有or，即使其中有条件带索引也不会使用(这也是为什么尽量少用or的原因)。注意：要想使用or，又想让索引生效，只能将or条件中的每个列都加上索引</li>
<li>对于多列索引，不是使用的第一部分，则不会使用索引（即不符合最左前缀原则）</li>
<li>如果列类型是字符串，那一定要在条件中将数据使用引号引用起来,否则不使用索引</li>
</ul>
<h2 id="查看索引的使用情况"><a href="#查看索引的使用情况" class="headerlink" title="查看索引的使用情况"></a>查看索引的使用情况</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show status like ‘Handler_read%’;</span></pre></td></tr></table></figure>

<p><img src="/images/database/handler_read.png" alt="handler_read.png"></p>
<ul>
<li>handler_read_key:这个值越高越好，越高表示使用索引查询到的次数越多</li>
<li>handler_read_rnd_next:这个值越高越不好，说明查询低效</li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>使用docker安装redis哨兵(sentinel)</title>
    <url>/2020/02/11/redis-03/</url>
    <content><![CDATA[<p>上一节我们搭建了redis主从模式，实现了redis的主从复制，读写分离。主从模式保证了数据备份，但是发生故障依然需要运维人员施工。为了解决主从模式的弊端，本节我们搭建redis哨兵模式。</p>
<p>本节我们搭建一主二从三哨兵。</p>
<h2 id="redis哨兵模式"><a href="#redis哨兵模式" class="headerlink" title="redis哨兵模式"></a>redis哨兵模式</h2><p>sentinel 通常翻译成哨兵，用来监控主从节点的健康情况。客户端连接redis主从的时候，先连接 sentinel，sentinel告诉客户端<font color=red>主redis</font>的地址是多少，然后客户端连接上redis并进行后续的操作。</p>
<p>当主节点挂掉的时候，客户端就得不到连接了因而报错了，客户端重新向sentinel询问主master的地址，然后客户端得到了<font color=red>新选举出来的主redis</font>。当原来的主机恢复后，会将其作为新主的从机。</p>
<p>我们直接在上一节的已经搭建好的主从基础上搭建redis哨兵模式，上一节的主从模式节点信息如下：</p>
<table>
<thead>
<tr>
<th align="left">角色</th>
<th align="center">端口</th>
<th align="right">密码</th>
<th align="right">容器名称</th>
</tr>
</thead>
<tbody><tr>
<td align="left">master</td>
<td align="center">6380</td>
<td align="right">123456</td>
<td align="right">redis-6380</td>
</tr>
<tr>
<td align="left">slaver</td>
<td align="center">6381</td>
<td align="right">123456</td>
<td align="right">redis-6381</td>
</tr>
<tr>
<td align="left">slaver</td>
<td align="center">6382</td>
<td align="right">123456</td>
<td align="right">redis-6382</td>
</tr>
</tbody></table>
<p>各容器network信心如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> &quot;Containers&quot;: &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &quot;3729ea952faade7c3bf37467f00f8a8c6676b9a98e27a897582272f1edce2087&quot;: &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &quot;Name&quot;: &quot;redis-6382&quot;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &quot;EndpointID&quot;: &quot;95f9a05d2b6d10c13eb3d8df706a2700f33a6704ddda290bc6840676eebc6676&quot;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &quot;MacAddress&quot;: &quot;02:42:ac:14:00:04&quot;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &quot;IPv4Address&quot;: &quot;172.20.0.4&#x2F;16&quot;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &quot;IPv6Address&quot;: &quot;&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &quot;a7f4ccfa8e8aa87efb697f3ee5fef686e5138ebb0ad5faac282e7850d8cb176f&quot;: &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &quot;Name&quot;: &quot;redis-6380&quot;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &quot;EndpointID&quot;: &quot;71af5cda52f5026aba9b4040890629d5ca560c2a7208b2bc7f0682a97a19d9bf&quot;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &quot;MacAddress&quot;: &quot;02:42:ac:14:00:02&quot;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &quot;IPv4Address&quot;: &quot;172.20.0.2&#x2F;16&quot;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &quot;IPv6Address&quot;: &quot;&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &quot;ff3d51f269c40912a21b2a8686078d963f292b32d32bce6dad089d9008377a36&quot;: &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &quot;Name&quot;: &quot;redis-6381&quot;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &quot;EndpointID&quot;: &quot;405a1e61ea2afae2fca8b0ce31f6ac83b7c03440668b3f7ec42072a0ebff18e3&quot;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &quot;MacAddress&quot;: &quot;02:42:ac:14:00:03&quot;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &quot;IPv4Address&quot;: &quot;172.20.0.3&#x2F;16&quot;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &quot;IPv6Address&quot;: &quot;&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>现在我们约定sentinel哨兵节点信息：</p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="center">端口</th>
</tr>
</thead>
<tbody><tr>
<td align="left">sentinel-26379</td>
<td align="center">26379</td>
</tr>
<tr>
<td align="left">sentinel-26380</td>
<td align="center">26380</td>
</tr>
<tr>
<td align="left">sentinel-26381</td>
<td align="center">26381</td>
</tr>
</tbody></table>
<h3 id="创建工作目录"><a href="#创建工作目录" class="headerlink" title="创建工作目录"></a>创建工作目录</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir -p &#x2F;usr&#x2F;local&#x2F;redis&#x2F;sentinel&#x2F;sentinel-26379&#x2F;conf</span></pre></td></tr><tr><td class="code"><pre><span class="line">mkdir -p &#x2F;usr&#x2F;local&#x2F;redis&#x2F;sentinel&#x2F;sentinel-26379&#x2F;data</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">mkdir -p &#x2F;usr&#x2F;local&#x2F;redis&#x2F;sentinel&#x2F;sentinel-26380&#x2F;conf</span></pre></td></tr><tr><td class="code"><pre><span class="line">mkdir -p &#x2F;usr&#x2F;local&#x2F;redis&#x2F;sentinel&#x2F;sentinel-26380&#x2F;data</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">mkdir -p &#x2F;usr&#x2F;local&#x2F;redis&#x2F;sentinel&#x2F;sentinel-26381&#x2F;conf</span></pre></td></tr><tr><td class="code"><pre><span class="line">mkdir -p &#x2F;usr&#x2F;local&#x2F;redis&#x2F;sentinel&#x2F;sentinel-26381&#x2F;data</span></pre></td></tr></table></figure>
<p>用来存放3个哨兵的配置文件及日志文件。</p>
<h3 id="准备sentinel-conf"><a href="#准备sentinel-conf" class="headerlink" title="准备sentinel.conf"></a>准备sentinel.conf</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget http:&#x2F;&#x2F;download.redis.io&#x2F;redis-stable&#x2F;sentinel.conf</span></pre></td></tr></table></figure>
<p>将sentinel.conf复制3份，分别存放到这3个目录下，并修改对应内容：</p>
<ul>
<li>/usr/local/redis/sentinel/sentinel-26379/conf<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dir &#x2F;data</span></pre></td></tr><tr><td class="code"><pre><span class="line">logfile &quot;sentinel-26379.log&quot;  # 修改日志文件的路径</span></pre></td></tr><tr><td class="code"><pre><span class="line">sentinel monitor mymaster redis-6380 6379 2 # redis-6380表示 master 节点地址，最后一个2表示，两个sentinel判定master被动下线后，就进行failover(故障转移)</span></pre></td></tr><tr><td class="code"><pre><span class="line">sentinel auth-pass mymaster 123456 # 设置master的密码</span></pre></td></tr></table></figure></li>
<li>/usr/local/redis/sentinel/sentinel-26380/conf<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dir &#x2F;data</span></pre></td></tr><tr><td class="code"><pre><span class="line">logfile &quot;sentinel-26380.log&quot;  # 修改日志文件的路径</span></pre></td></tr><tr><td class="code"><pre><span class="line">sentinel monitor mymaster redis-6380 6379 2 # redis-6380表示 master 节点地址，最后一个2表示，两个sentinel判定master被动下线后，就进行failover(故障转移)</span></pre></td></tr><tr><td class="code"><pre><span class="line">sentinel auth-pass mymaster 123456 # 设置master的密码</span></pre></td></tr></table></figure></li>
<li>/usr/local/redis/sentinel/sentinel-26381/conf<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dir &#x2F;data</span></pre></td></tr><tr><td class="code"><pre><span class="line">logfile &quot;sentinel-26381.log&quot;  # 修改日志文件的路径</span></pre></td></tr><tr><td class="code"><pre><span class="line">sentinel monitor mymaster redis-6380 6379 2 # redis-6380表示 master 节点地址，最后一个2表示，两个sentinel判定master被动下线后，就进行failover(故障转移)</span></pre></td></tr><tr><td class="code"><pre><span class="line">sentinel auth-pass mymaster 123456 # 设置master的密码</span></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost sentinel]# tree</span></pre></td></tr><tr><td class="code"><pre><span class="line">.</span></pre></td></tr><tr><td class="code"><pre><span class="line">├── sentinel-26379</span></pre></td></tr><tr><td class="code"><pre><span class="line">│   ├── conf</span></pre></td></tr><tr><td class="code"><pre><span class="line">│   │   └── sentinel.conf</span></pre></td></tr><tr><td class="code"><pre><span class="line">│   └── data</span></pre></td></tr><tr><td class="code"><pre><span class="line">├── sentinel-26380</span></pre></td></tr><tr><td class="code"><pre><span class="line">│   ├── conf</span></pre></td></tr><tr><td class="code"><pre><span class="line">│   │   └── sentinel.conf</span></pre></td></tr><tr><td class="code"><pre><span class="line">│   └── data</span></pre></td></tr><tr><td class="code"><pre><span class="line">└── sentinel-26381</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ├── conf</span></pre></td></tr><tr><td class="code"><pre><span class="line">    │   └── sentinel.conf</span></pre></td></tr><tr><td class="code"><pre><span class="line">    └── data</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">9 directories, 3 files</span></pre></td></tr></table></figure>

<h3 id="创建sentinel容器"><a href="#创建sentinel容器" class="headerlink" title="创建sentinel容器"></a>创建sentinel容器</h3><p>官网建议设置奇数个哨兵，这样才适合选举机制。<br>我们逐个执行下面的启动命令，并查看sentinel.conf文件的变化。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -d -p 26379:26379 --name sentinel-26379 --net&#x3D;redis-master-slaver \</span></pre></td></tr><tr><td class="code"><pre><span class="line">-v &#x2F;usr&#x2F;local&#x2F;redis&#x2F;sentinel&#x2F;sentinel-26379&#x2F;conf&#x2F;sentinel.conf:&#x2F;etc&#x2F;redis&#x2F;sentinel.conf \</span></pre></td></tr><tr><td class="code"><pre><span class="line">-v &#x2F;usr&#x2F;local&#x2F;redis&#x2F;sentinel&#x2F;sentinel-26379&#x2F;data:&#x2F;data redis:5.0.7 \</span></pre></td></tr><tr><td class="code"><pre><span class="line">redis-sentinel &#x2F;etc&#x2F;redis&#x2F;sentinel.conf</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">docker run -d -p 26380:26379 --name sentinel-26380 --net&#x3D;redis-master-slaver \</span></pre></td></tr><tr><td class="code"><pre><span class="line">-v &#x2F;usr&#x2F;local&#x2F;redis&#x2F;sentinel&#x2F;sentinel-26380&#x2F;conf&#x2F;sentinel.conf:&#x2F;etc&#x2F;redis&#x2F;sentinel.conf \</span></pre></td></tr><tr><td class="code"><pre><span class="line">-v &#x2F;usr&#x2F;local&#x2F;redis&#x2F;sentinel&#x2F;sentinel-26380&#x2F;data:&#x2F;data redis:5.0.7 \</span></pre></td></tr><tr><td class="code"><pre><span class="line">redis-sentinel &#x2F;etc&#x2F;redis&#x2F;sentinel.conf</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">docker run -d -p 26381:26379 --name sentinel-26381 --net&#x3D;redis-master-slaver \</span></pre></td></tr><tr><td class="code"><pre><span class="line">-v &#x2F;usr&#x2F;local&#x2F;redis&#x2F;sentinel&#x2F;sentinel-26381&#x2F;conf&#x2F;sentinel.conf:&#x2F;etc&#x2F;redis&#x2F;sentinel.conf \</span></pre></td></tr><tr><td class="code"><pre><span class="line">-v &#x2F;usr&#x2F;local&#x2F;redis&#x2F;sentinel&#x2F;sentinel-26381&#x2F;data:&#x2F;data redis:5.0.7 \</span></pre></td></tr><tr><td class="code"><pre><span class="line">redis-sentinel &#x2F;etc&#x2F;redis&#x2F;sentinel.conf</span></pre></td></tr></table></figure>

<p>我们启动sentinel-26379后，查看/usr/local/redis/sentinel/sentinel-26379/conf/sentinel.conf文件，有了这些变化：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sentinel myid 327716021d2b88790338b362173a34163a855e56</span></pre></td></tr><tr><td class="code"><pre><span class="line">sentinel deny-scripts-reconfig yes</span></pre></td></tr><tr><td class="code"><pre><span class="line">sentinel monitor mymaster 172.20.0.2 6379 2  #自动替换成了redis-6380的ip</span></pre></td></tr><tr><td class="code"><pre><span class="line">sentinel config-epoch mymaster 0</span></pre></td></tr><tr><td class="code"><pre><span class="line">sentinel leader-epoch mymaster 0</span></pre></td></tr><tr><td class="code"><pre><span class="line"># Generated by CONFIG REWRITE</span></pre></td></tr><tr><td class="code"><pre><span class="line">sentinel known-replica mymaster 172.20.0.4 6379</span></pre></td></tr><tr><td class="code"><pre><span class="line">sentinel known-replica mymaster 172.20.0.3 6379</span></pre></td></tr><tr><td class="code"><pre><span class="line">sentinel current-epoch 0</span></pre></td></tr></table></figure>
<p>日志文件（/usr/local/redis/sentinel/sentinel-26379/data/sentinel-26379.log）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost data]# vim sentinel-26379.log </span></pre></td></tr><tr><td class="code"><pre><span class="line">1:X 12 Feb 2020 03:03:09.681 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo</span></pre></td></tr><tr><td class="code"><pre><span class="line">1:X 12 Feb 2020 03:03:09.681 # Redis version&#x3D;5.0.7, bits&#x3D;64, commit&#x3D;00000000, modified&#x3D;0, pid&#x3D;1, just started</span></pre></td></tr><tr><td class="code"><pre><span class="line">1:X 12 Feb 2020 03:03:09.681 # Configuration loaded</span></pre></td></tr><tr><td class="code"><pre><span class="line">1:X 12 Feb 2020 03:03:09.683 * Running mode&#x3D;sentinel, port&#x3D;26379.</span></pre></td></tr><tr><td class="code"><pre><span class="line">1:X 12 Feb 2020 03:03:09.683 # WARNING: The TCP backlog setting of 511 cannot be enforced because &#x2F;proc&#x2F;sys&#x2F;net&#x2F;core&#x2F;somaxconn is set to the lower value of 128.</span></pre></td></tr><tr><td class="code"><pre><span class="line">1:X 12 Feb 2020 03:03:09.687 # Sentinel ID is 327716021d2b88790338b362173a34163a855e56</span></pre></td></tr><tr><td class="code"><pre><span class="line">1:X 12 Feb 2020 03:03:09.687 # +monitor master mymaster 172.20.0.2 6379 quorum 2</span></pre></td></tr><tr><td class="code"><pre><span class="line">1:X 12 Feb 2020 03:03:09.689 * +slave slave 172.20.0.3:6379 172.20.0.3 6379 @ mymaster 172.20.0.2 6379</span></pre></td></tr><tr><td class="code"><pre><span class="line">1:X 12 Feb 2020 03:03:09.690 * +slave slave 172.20.0.4:6379 172.20.0.4 6379 @ mymaster 172.20.0.2 6379</span></pre></td></tr><tr><td class="code"><pre><span class="line">1:X 12 Feb 2020 03:06:10.373 * +fix-slave-config slave 172.20.0.4:6379 172.20.0.4 6379 @ mymaster 172.20.0.2 6379</span></pre></td></tr><tr><td class="code"><pre><span class="line">1:X 12 Feb 2020 03:06:10.374 * +fix-slave-config slave 172.20.0.3:6379 172.20.0.3 6379 @ mymaster 172.20.0.2 6379</span></pre></td></tr></table></figure>
<p>可以看到它已经检测到了master和2个slave.</p>
<p>我们接下来启动sentinel-26380和sentinel-26381，查看/usr/local/redis/sentinel/sentinel-26379/conf/sentinel.conf文件,新增了2行记录，表示监测到了新的哨兵</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sentinel known-sentinel mymaster 172.20.0.7 26379 90137df24fb27cb5821c3a3372c2101379b75018</span></pre></td></tr><tr><td class="code"><pre><span class="line">sentinel known-sentinel mymaster 172.20.0.6 26379 d88c61fe5d93be0aaaaff6629196f0034683bb58</span></pre></td></tr></table></figure>

<h3 id="验证效果"><a href="#验证效果" class="headerlink" title="验证效果"></a>验证效果</h3><p>此时master节点是redis-6380<br><img src="/images/redis/sentinel-master-6380.png" alt="sentinel-master-6380.png"></p>
<p>我们关掉redis-6380，模式master节点故障情况。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker stop redis-6380</span></pre></td></tr></table></figure>
<p>我们查看日志sentinel-26379.log<br><img src="/images/redis/sentinel-new-master-log.png" alt="sentinel-new-master-log.png"></p>
<p>我们可以看到选举过程，现在选定了172.20.0.4这个节点为新的master，即redis-6382,我们来验证一下：<br><img src="/images/redis/sentinel-new-master.png" alt="sentinel-new-master.png"></p>
<p>可以看到符合我们的预期。</p>
<p>此时我们再次启动redis-6380,并查看redis-6380信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker start redis-6380</span></pre></td></tr></table></figure>
<p><img src="/images/redis/sentinel-failer-link-master.png" alt="sentinel-failer-link-master.png"></p>
<p>可以看到，redis-6380变为了slave,但是没有连接上新的master。</p>
<p>这是因为我们在上一节主从模式时，在redis-6380的redis.conf中未配置密码的原因。<br>修改/usr/local/redis/master-slaver/master/conf/redis.conf,添加</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">masterauth 123456</span></pre></td></tr></table></figure>
<p>我们重启redis-6380,并查看redis-6380信息<br><img src="/images/redis/sentinel-success-link-master.png" alt="sentinel-success-link-master.png"></p>
<p>OK，新启动的redis-6380已经成为的新master的从节点。</p>
<p>我们搭建的是伪哨兵模式，真实环境下，这 3个redis节点应该分别部署在3台服务器上，每台服务器都布置一个sentinel哨兵。</p>
<p>至此，redis一主二从三哨兵搭建完成，哨兵模式主要解决了高可用问题（HA），保证特殊情况故障自动切换，哨兵盯着你的“redis主从集群”，如果主库死了，它会告诉你新的老大是谁。</p>
<p>参考：<br><a href="https://www.cnblogs.com/demingblog/p/10295236.html#redis-cluster" target="_blank" rel="noopener">https://www.cnblogs.com/demingblog/p/10295236.html#redis-cluster</a><br><a href="https://blog.csdn.net/cyfblog/article/details/100340640" target="_blank" rel="noopener">https://blog.csdn.net/cyfblog/article/details/100340640</a></p>
]]></content>
      <categories>
        <category>docker</category>
        <category>redis</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>使用docker安装redis主从模式</title>
    <url>/2020/02/09/redis-02/</url>
    <content><![CDATA[<h2 id="redis主从复制"><a href="#redis主从复制" class="headerlink" title="redis主从复制"></a>redis主从复制</h2><p>前一节我们搭建了单体redis应用，假设我们生产环境使用了一台redis，redis挂了怎么办？<br><font color=red>redis主从复制</font>：是备份关系，我们操作主库，数据会同步到从库。</p>
<p>那么redis主从复制有什么作用呢？</p>
<ul>
<li>故障恢复：当主节点故障时，可以由从节点提供服务，快速的故障转移</li>
<li>负载均衡：可以在主从复制的基础上，配合读写分离，由主节点负责写，从节点负责读取数据，从而分担服务器的负载压力，大大提高redis的并发量。</li>
</ul>
<p>本节我们搭建redis 一主二从，读写分离。redis主从是实现redis集群和redis哨兵高可用的基础.</p>
<h3 id="创建工作目录"><a href="#创建工作目录" class="headerlink" title="创建工作目录"></a>创建工作目录</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir -p &#x2F;usr&#x2F;local&#x2F;redis&#x2F;master-slaver&#x2F;master&#x2F;conf</span></pre></td></tr><tr><td class="code"><pre><span class="line">mkdir -p &#x2F;usr&#x2F;local&#x2F;redis&#x2F;master-slaver&#x2F;master&#x2F;data</span></pre></td></tr><tr><td class="code"><pre><span class="line">mkdir -p &#x2F;usr&#x2F;local&#x2F;redis&#x2F;master-slaver&#x2F;slaver&#x2F;conf</span></pre></td></tr><tr><td class="code"><pre><span class="line">mkdir -p &#x2F;usr&#x2F;local&#x2F;redis&#x2F;master-slaver&#x2F;slaver&#x2F;data</span></pre></td></tr><tr><td class="code"><pre><span class="line">mkdir -p &#x2F;usr&#x2F;local&#x2F;redis&#x2F;master-slaver&#x2F;slaver1&#x2F;conf</span></pre></td></tr><tr><td class="code"><pre><span class="line">mkdir -p &#x2F;usr&#x2F;local&#x2F;redis&#x2F;master-slaver&#x2F;slaver1&#x2F;data</span></pre></td></tr></table></figure>

<h3 id="端口约定"><a href="#端口约定" class="headerlink" title="端口约定"></a>端口约定</h3><table>
<thead>
<tr>
<th align="left">角色</th>
<th align="center">端口</th>
<th align="right">密码</th>
<th align="right">容器名称</th>
</tr>
</thead>
<tbody><tr>
<td align="left">master</td>
<td align="center">6380</td>
<td align="right">123456</td>
<td align="right">redis-6380</td>
</tr>
<tr>
<td align="left">slaver</td>
<td align="center">6381</td>
<td align="right">123456</td>
<td align="right">redis-6381</td>
</tr>
<tr>
<td align="left">slaver</td>
<td align="center">6382</td>
<td align="right">123456</td>
<td align="right">redis-6382</td>
</tr>
</tbody></table>
<h3 id="准备redis-conf"><a href="#准备redis-conf" class="headerlink" title="准备redis.conf"></a>准备redis.conf</h3><ol>
<li>准备一份redis.conf文件 <a href="https://redis.io/download" target="_blank" rel="noopener">https://redis.io/download</a>。复制3份，分别存放到：<br>/usr/local/redis/master-slave/master/conf<br>/usr/local/redis/master-slave/slaver/conf<br>/usr/local/redis/master-slave/slaver/conf</li>
</ol>
<p>2.创建自定义网桥</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker network inspect redis-master-slaver</span></pre></td></tr></table></figure>
<p>这样我们容器间就可以使用容器名来通信了，避免出现ip变化后主从容器无法通信问题。</p>
<ol start="3">
<li>分别修改这3份redis.conf的以下内容<br>master:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">requirepass 123456 #给redis设置密码</span></pre></td></tr><tr><td class="code"><pre><span class="line">bind 0.0.0.0 # 表示任意ip可连</span></pre></td></tr><tr><td class="code"><pre><span class="line">appendonly yes #开启redis aof持久化</span></pre></td></tr></table></figure>
slaver:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">requirepass 123456 #给redis设置密码</span></pre></td></tr><tr><td class="code"><pre><span class="line">bind 0.0.0.0 # 表示任意ip可连</span></pre></td></tr><tr><td class="code"><pre><span class="line">appendonly yes #开启redis aof持久化</span></pre></td></tr><tr><td class="code"><pre><span class="line">slaveof redis-6380 6379 #master容器内的ip端口</span></pre></td></tr><tr><td class="code"><pre><span class="line">masterauth 123456 #master节点的密码</span></pre></td></tr></table></figure>
slaver1:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">requirepass 123456 #给redis设置密码</span></pre></td></tr><tr><td class="code"><pre><span class="line">bind 0.0.0.0 # 表示任意ip可连</span></pre></td></tr><tr><td class="code"><pre><span class="line">appendonly yes #开启redis aof持久化</span></pre></td></tr><tr><td class="code"><pre><span class="line">slaveof redis-6380 6379 #master容器内的ip端口</span></pre></td></tr><tr><td class="code"><pre><span class="line">masterauth 123456 #master节点的密码</span></pre></td></tr></table></figure>
注意：</li>
</ol>
<ul>
<li>slaveof redis-6380 6379 这里指定的master端口6379是容器内的端口，不能指定为6380，否则slaver无法连接master。</li>
<li>daemonize 不能设置为yes，否则无法启动。参考:<a href="https://blog.csdn.net/Mr_Yang__/article/details/81906691" target="_blank" rel="noopener">https://blog.csdn.net/Mr_Yang__/article/details/81906691</a></li>
</ul>
<h3 id="创建redis容器"><a href="#创建redis容器" class="headerlink" title="创建redis容器"></a>创建redis容器</h3><ul>
<li>master 主库<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -d -p 6380:6379 --name redis-6380 --net&#x3D;redis-master-slaver \</span></pre></td></tr><tr><td class="code"><pre><span class="line">-v &#x2F;usr&#x2F;local&#x2F;redis&#x2F;master-slaver&#x2F;master&#x2F;conf&#x2F;redis.conf:&#x2F;etc&#x2F;redis&#x2F;redis.conf \</span></pre></td></tr><tr><td class="code"><pre><span class="line">-v &#x2F;usr&#x2F;local&#x2F;redis&#x2F;master-slaver&#x2F;master&#x2F;data:&#x2F;data redis:5.0.7 \</span></pre></td></tr><tr><td class="code"><pre><span class="line">redis-server &#x2F;etc&#x2F;redis&#x2F;redis.conf</span></pre></td></tr></table></figure></li>
<li>slaver 从库<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -d -p 6381:6379 --name redis-6381 --net&#x3D;redis-master-slaver \</span></pre></td></tr><tr><td class="code"><pre><span class="line">-v &#x2F;usr&#x2F;local&#x2F;redis&#x2F;master-slaver&#x2F;slaver&#x2F;conf&#x2F;redis.conf:&#x2F;etc&#x2F;redis&#x2F;redis.conf \</span></pre></td></tr><tr><td class="code"><pre><span class="line">-v &#x2F;usr&#x2F;local&#x2F;redis&#x2F;master-slaver&#x2F;slaver&#x2F;data:&#x2F;data redis:5.0.7 \</span></pre></td></tr><tr><td class="code"><pre><span class="line">redis-server &#x2F;etc&#x2F;redis&#x2F;redis.conf</span></pre></td></tr></table></figure></li>
<li>slaver1 从库<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -d -p 6382:6379 --name redis-6382 --net&#x3D;redis-master-slaver \</span></pre></td></tr><tr><td class="code"><pre><span class="line">-v &#x2F;usr&#x2F;local&#x2F;redis&#x2F;master-slaver&#x2F;slaver1&#x2F;conf&#x2F;redis.conf:&#x2F;etc&#x2F;redis&#x2F;redis.conf \</span></pre></td></tr><tr><td class="code"><pre><span class="line">-v &#x2F;usr&#x2F;local&#x2F;redis&#x2F;master-slaver&#x2F;slaver1&#x2F;data:&#x2F;data redis:5.0.7 \</span></pre></td></tr><tr><td class="code"><pre><span class="line">redis-server &#x2F;etc&#x2F;redis&#x2F;redis.conf</span></pre></td></tr></table></figure>
<h3 id="检验功能"><a href="#检验功能" class="headerlink" title="检验功能"></a>检验功能</h3><h4 id="查看master容器"><a href="#查看master容器" class="headerlink" title="查看master容器"></a>查看master容器</h4><img src="/images/redis/redis-6380-info.png" alt="redis-6380-info.png"></li>
</ul>
<p>可以看到role:master，以及2个slaver。我们添加一个String 类型的键值对</p>
<h4 id="查看slaver1容器"><a href="#查看slaver1容器" class="headerlink" title="查看slaver1容器"></a>查看slaver1容器</h4><p><img src="/images/redis/redis-6381-info.png" alt="redis-6381-info.png"></p>
<p>可以看到role:slave，可以看到master节点信息。<br>通过 get s1 命令可以获取到1234qwer ,说明我们同步了master主节点数据。<br>通过 set s2 123 时，报(error) READONLY You can’t write against a read only replica.说明从节点是只读的。</p>
<h4 id="查看slaver1容器-1"><a href="#查看slaver1容器-1" class="headerlink" title="查看slaver1容器"></a>查看slaver1容器</h4><p><img src="/images/redis/redis-6382-info.png" alt="redis-6382-info.png"><br>slaver2和slaver1相同。</p>
<h3 id="树结构"><a href="#树结构" class="headerlink" title="树结构"></a>树结构</h3><p>我们来查看一下目前的树结构,可以看到主从3个redis容器的配置文件，及产生的持久化文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost master-slaver]# tree</span></pre></td></tr><tr><td class="code"><pre><span class="line">.</span></pre></td></tr><tr><td class="code"><pre><span class="line">├── master</span></pre></td></tr><tr><td class="code"><pre><span class="line">│   ├── conf</span></pre></td></tr><tr><td class="code"><pre><span class="line">│   │   └── redis.conf</span></pre></td></tr><tr><td class="code"><pre><span class="line">│   └── data</span></pre></td></tr><tr><td class="code"><pre><span class="line">│       ├── appendonly.aof</span></pre></td></tr><tr><td class="code"><pre><span class="line">│       └── dump.rdb</span></pre></td></tr><tr><td class="code"><pre><span class="line">├── slaver</span></pre></td></tr><tr><td class="code"><pre><span class="line">│   ├── conf</span></pre></td></tr><tr><td class="code"><pre><span class="line">│   │   └── redis.conf</span></pre></td></tr><tr><td class="code"><pre><span class="line">│   └── data</span></pre></td></tr><tr><td class="code"><pre><span class="line">│       ├── appendonly.aof</span></pre></td></tr><tr><td class="code"><pre><span class="line">│       └── dump.rdb</span></pre></td></tr><tr><td class="code"><pre><span class="line">└── slaver1</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ├── conf</span></pre></td></tr><tr><td class="code"><pre><span class="line">    │   └── redis.conf</span></pre></td></tr><tr><td class="code"><pre><span class="line">    └── data</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ├── appendonly.aof</span></pre></td></tr><tr><td class="code"><pre><span class="line">        └── dump.rdb</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">9 directories, 9 files</span></pre></td></tr></table></figure>
<h3 id="异常情况"><a href="#异常情况" class="headerlink" title="异常情况"></a>异常情况</h3><p>我们这里模拟下可能发生的异常情况。</p>
<h4 id="master节点损坏"><a href="#master节点损坏" class="headerlink" title="master节点损坏"></a>master节点损坏</h4><p>我们关掉master：redis-6380，模式主节点损坏情况，此时运维人员准备先将redis-6381，设置为主节点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker stop redis-6380</span></pre></td></tr></table></figure>
<p>修改redis-6381的redis.conf文件,注释掉下面2行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># slaveof redis-6380 6379 </span></pre></td></tr><tr><td class="code"><pre><span class="line"># masterauth 123456</span></pre></td></tr></table></figure>
<p>此时我们修改redis-6382的redis.conf文件的以下内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">slaveof redis-6381 6379</span></pre></td></tr></table></figure>
<p>重新启动redis-6381、redis-6382</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker restart redis-6381</span></pre></td></tr><tr><td class="code"><pre><span class="line">docker restart redis-6382</span></pre></td></tr></table></figure>
<h4 id="查看redis-6381"><a href="#查看redis-6381" class="headerlink" title="查看redis-6381"></a>查看redis-6381</h4><p><img src="/images/redis/master-6381-info.png" alt="master-6381-info.png"></p>
<p>可以看到redis-6381已经升级为 master节点。</p>
<h4 id="查看redis-6382"><a href="#查看redis-6382" class="headerlink" title="查看redis-6382"></a>查看redis-6382</h4><p><img src="/images/redis/slaver-6382-info.png" alt="slaver-6382-info.png"></p>
<p>这样我们就实现了redis主从复制，读写分离。主从模式保证了数据备份，发生故障依然需要运维人员施工。</p>
<p>参考：<br><a href="https://blog.csdn.net/qq_28804275/article/details/80907796" target="_blank" rel="noopener">https://blog.csdn.net/qq_28804275/article/details/80907796</a><br><a href="https://www.cnblogs.com/demingblog/p/10295236.html" target="_blank" rel="noopener">https://www.cnblogs.com/demingblog/p/10295236.html</a></p>
]]></content>
      <categories>
        <category>docker</category>
        <category>redis</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>使用docker安装单点redis</title>
    <url>/2020/02/08/redis-01/</url>
    <content><![CDATA[<h2 id="安装单个redis"><a href="#安装单个redis" class="headerlink" title="安装单个redis"></a>安装单个redis</h2><ol>
<li>拉取镜像,我使用的是5.0.7版本。<a href="https://hub.docker.com/_/redis/?tab=tags" target="_blank" rel="noopener">https://hub.docker.com/_/redis/?tab=tags</a><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull redis:5.0.7</span></pre></td></tr></table></figure></li>
<li>准备一份redis.conf文件 <a href="https://redis.io/download" target="_blank" rel="noopener">https://redis.io/download</a>，使用 xftp 上传到 /usr/local/redis/conf下。</li>
</ol>
<p>注意：默认docker运行的redis是不存在配置文件的，即无配置启动.<br>另外还可以通过wget下载redis.conf：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget http:&#x2F;&#x2F;download.redis.io&#x2F;redis-stable&#x2F;redis.conf</span></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir &#x2F;usr&#x2F;local&#x2F;redis&#x2F;data</span></pre></td></tr><tr><td class="code"><pre><span class="line">mkdir &#x2F;usr&#x2F;local&#x2F;redis&#x2F;conf</span></pre></td></tr></table></figure>
<p>上传时发现一直报错，因为我是使用admin登录的，传输到虚拟机（服务器）的文件夹（目的地的文件夹）的权限不够。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod 777 &#x2F;usr&#x2F;local&#x2F;redis&#x2F;conf</span></pre></td></tr></table></figure>
<p>再次上传,然后把权限改回来，777权限很危险，尽量不要这么设置。</p>
<p>修改redis.conf中的以下内容</p>
<ul>
<li>requirepass 123456 #给redis设置密码</li>
<li>bind 127.0.0.1 # 注释掉这部分，表示任意ip可连</li>
<li>appendonly yes #开启redis aof持久化</li>
</ul>
<ol start="3">
<li>创建redis容器</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -d -p 6379:6379 --name redis-6379 -v &#x2F;usr&#x2F;local&#x2F;redis&#x2F;conf&#x2F;redis.conf:&#x2F;etc&#x2F;redis&#x2F;redis.conf -v &#x2F;usr&#x2F;local&#x2F;redis&#x2F;data:&#x2F;data redis:5.0.7 redis-server &#x2F;etc&#x2F;redis&#x2F;redis.conf</span></pre></td></tr></table></figure>
<p><img src="/images/redis/docker-redis-single.png" alt="docker-redis-single"></p>
<ul>
<li>-p 6379:6379:把容器内的6379端口映射到宿主机6379端口</li>
<li>-v /usr/local/redis/conf/redis.conf:/etc/redis/redis.conf:把宿主机配置好的redis.conf放到容器内的这个位置中</li>
<li>-v /usr/local/redis/data:/data:把redis持久化的数据在宿主机内显示，做数据备份</li>
<li>redis-server /etc/redis/redis.conf：这个是关键配置，让redis不是无配置启动，而是按照这个redis.conf的配置启动</li>
<li>–appendonly yes：redis启动后数据持久化</li>
</ul>
<p>使用redis-Desktop连接<br><img src="/images/redis/redis-Desktop-single.png" alt="redis-Desktop-single.png"></p>
<p>我们使用命令向redis中插入几个String类型的值，再次查看/usr/local/redis/data目录,发现已经生成了持久化文件。</p>
<p><img src="/images/redis/single-data.png" alt="single-data.png"></p>
<p>单体redis较为简单，完工！</p>
]]></content>
      <categories>
        <category>docker</category>
        <category>redis</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>docker 数据存储笔记</title>
    <url>/2020/02/04/docker-06/</url>
    <content><![CDATA[<p>Docker容器在运行的时候会产生数据，为了不让这些数据随着容器的删除而删除，Docker支持数据持久化。</p>
<p>Docker数据持久化主要有三种种方式：volume, bind mounts, tmpfs mounts</p>
<p><img src="/images/docker/types-of-mounts-volume.png" alt="types-of-mounts-volume.png"></p>
<p>这张图很好的说明了三者的关系:</p>
<ul>
<li>volume 使用volume数据将持久化在Docker管理的volume中（保存在宿主机 /var/lib/docker/volumes目录下）</li>
<li>bind mount是直接挂载的宿主机的文件目录，将宿主机的目录映射到容器中；</li>
<li>tmpfs mount是将数据写入缓存，容器停止后就会被清理。这种模式不太常用，不做太多介绍。</li>
</ul>
<p>使用bind mount，数据将持久化在我们指定的宿主机的某个目录中。挂载宿主机目录时数据覆盖有两个规则：</p>
<ul>
<li>如果宿主机目录下内容为空，容器映射目录有数据，则会把容器数据复制到宿主机目录</li>
<li>如果宿主机目录下内容不为空，则会把宿主机目录下内容映射到容器里，并且容器原数据会隐藏。</li>
</ul>
<h2 id="volume方式"><a href="#volume方式" class="headerlink" title="volume方式"></a>volume方式</h2><p>Linux环境下，docker 默认在主机上会有一个特定的区域（/var/lib/docker/volumes/ ），该区域用来存放 volume。</p>
<pre><code>volume 可以通过 docker volume 进行管理，如创建、删除等操作。
volume 在生成的时候如果不指定名称，便会随机生成。</code></pre><p>我们使用docker创建一个mysql容器来验证一下，首先我们看一下mysql:5.7.29的 <a href="https://hub.docker.com/layers/mysql/library/mysql/5.7.29/images/sha256-5e443fc090c75413ffc20665ed1880c7961bc6af8ae8997510fdd7e69d8557ad" target="_blank" rel="noopener">Dockerfile</a>内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">......</span></pre></td></tr><tr><td class="code"><pre><span class="line">VOLUME [&#x2F;var&#x2F;lib&#x2F;mysql]</span></pre></td></tr><tr><td class="code"><pre><span class="line">......</span></pre></td></tr><tr><td class="code"><pre><span class="line">EXPOSE 3306 33060</span></pre></td></tr><tr><td class="code"><pre><span class="line">CMD [&quot;mysqld&quot;]</span></pre></td></tr></table></figure>

<p>其中的 <font color=red>VOLUME [/var/lib/mysql]</font> 表示在Docker创建MySQL容器时，Docker会自动创建一个volume，将MySQL容器中/var/lib/mysql目录下的内容将同步到这个volume中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull mysql:5.7.29</span></pre></td></tr><tr><td class="code"><pre><span class="line">docker run -d --name mysql-5.7.29 --restart&#x3D;always -p 3306:3306 -e MYSQL_ROOT_PASSWORD&#x3D;gaoyipeng  mysql:5.7.29</span></pre></td></tr></table></figure>
<p>然后就可以看到我们已经创建好了mysql-5.7.29，以及创建的卷信息<br><img src="/images/docker/mysql-volume.png" alt="mysql-volume.png"></p>
<p>volume 在生成的时候如果不指定名称，便会随机生成（eg:09f037735adf1….）很长不好理解。我们也可以指定名称。<br>我们删除这个容器，使用如下的命令再次创建，指定volume名称为mysql</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -d --name mysql-5.7.29 --restart&#x3D;always -p 3306:3306 -e MYSQL_ROOT_PASSWORD&#x3D;gaoyipeng -v mysql:&#x2F;var&#x2F;lib&#x2F;mysql mysql:5.7.29</span></pre></td></tr></table></figure>
<p><img src="/images/docker/volume-mysql.png" alt="volume-mysql.png"><br>我们使用Navicat链接这个mysql，并创建一个名为docker-volume的数据库。<br><img src="/images/docker/navicat-mysql.png" alt="navicat-mysql"><br><img src="/images/docker/docker-volume.png" alt="docker-volume.png"></p>
<p>然后我们删除这个容器，使用上面的命令再次创建</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker stop mysql-5.7.29</span></pre></td></tr><tr><td class="code"><pre><span class="line">docker rm mysql-5.7.29</span></pre></td></tr><tr><td class="code"><pre><span class="line">docker run -d --name mysql-5.7.29 --restart&#x3D;always -p 3306:3306 -e MYSQL_ROOT_PASSWORD&#x3D;gaoyipeng -v mysql:&#x2F;var&#x2F;lib&#x2F;mysql mysql:5.7.29</span></pre></td></tr></table></figure>
<p>使用navacat 再次链接，发现之前创建的docker-volume数据库依然存在，说明数据持久化成功。</p>
<h2 id="bind-mount方式"><a href="#bind-mount方式" class="headerlink" title="bind mount方式"></a>bind mount方式</h2><p>是直接挂载的宿主机的文件目录，将宿主机的目录映射到容器中；和volume方式的区别就是保存容器数据的宿主机目录需要自行指定，不是docker来管理。</p>
<p>我们修改mysql容器创建命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -d --name mysql-5.7.29 --restart&#x3D;always -p 3306:3306 -e MYSQL_ROOT_PASSWORD&#x3D;gaoyipeng -v &#x2F;usr&#x2F;local&#x2F;mysql:&#x2F;var&#x2F;lib&#x2F;mysql mysql:5.7.29</span></pre></td></tr></table></figure>
<p>这样，容器卷的位置就被指到了宿主机的/usr/local/mysql目录下，而不是/var/lib/docker/volumes。bind mount方式更为灵活。<br><img src="/images/docker/bind-volume-mysql.png" alt="bind-volume-mysql.png"></p>
<p>我们可以看到宿主机/usr/local/mysql目录下，生成了持久化文件。</p>
<p><img src="/images/docker/navicat-no-volume.png" alt="navicat-no-volume.png"></p>
<p>再次使用Navacat连接，发现docker-volume数据库是不存在的，符合预期。</p>
<p>完工！！！</p>
<p>参考：<br><a href="https://docs.docker.com/storage/volumes/" target="_blank" rel="noopener">https://docs.docker.com/storage/volumes/</a><br><a href="https://deepzz.com/post/the-docker-volumes-basic.html" target="_blank" rel="noopener">https://deepzz.com/post/the-docker-volumes-basic.html</a><br><a href="https://mrbird.cc/Docker-Volume.html" target="_blank" rel="noopener">https://mrbird.cc/Docker-Volume.html</a></p>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>系统镜像下载地址</title>
    <url>/2020/02/02/system/</url>
    <content><![CDATA[<ol>
<li><p>windows镜像 下载地址：<a href="https://msdn.itellyou.cn/" target="_blank" rel="noopener">https://msdn.itellyou.cn/</a></p>
</li>
<li><p>linux镜像 下载地址：<a href="http://archive.kernel.org/centos-vault/7.0.1406/isos/x86_64/" target="_blank" rel="noopener">http://archive.kernel.org/centos-vault/7.0.1406/isos/x86_64/</a> </p>
</li>
</ol>
<p>此处贴出常用的CentOS 7的地址，其他linux发行版在这个网站也可以找到 <a href="http://archive.kernel.org" target="_blank" rel="noopener">http://archive.kernel.org</a></p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title>docker网络配置笔记</title>
    <url>/2020/01/27/docker-05/</url>
    <content><![CDATA[<h2 id="docker网络模式"><a href="#docker网络模式" class="headerlink" title="docker网络模式"></a>docker网络模式</h2><p>Docker自身拥有4种默认的网络模式，另外我们还可以自定义网络。</p>
<p>在安装Docker时，会在宿主机上创建一个新的网络接口，名字是docker0。docker0是一个虚拟的以太网桥，它专门用于连接容器和本地宿主机网络.<br>每个Docker容器都会在这个接口上分配一个IP地址，接口本身的地址是172.17.0.1，子网掩码是255.255.0.0，也就是说Docker会默认使用172.17.X.X作为子网地址。</p>
<p><img src="/images/docker/docker0.png" alt="docker0"></p>
<h3 id="四种默认网络模式"><a href="#四种默认网络模式" class="headerlink" title="四种默认网络模式"></a>四种默认网络模式</h3><ol>
<li><p>bridge模式（默认模式）：使用--net=bridge指定</p>
<p>此模式会为每一个容器分配、设置IP等，并将容器连接到一个docker0虚拟网桥，通过docker0网桥以及Iptables nat表配置与宿主机通信。</p>
</li>
<li><p>Host模式：使用--net=host指定</p>
<p>容器和宿主机共享Network namespace。容器将不会虚拟出自己的网卡，配置自己的IP等，而是使用宿主机的IP和端口。使用host模式的容器可以直接使用宿主机的IP地址与外界通信，容器内部的服务端口也可以使用宿主机的端口，不需要进行NAT。</p>
<p>host模式的优势就是网络性能比较好，但是docker host上已经使用的端口就不能再用了，网络的隔离性不好。</p>
</li>
<li><p>Container模式：使用--net=container:NAME_or_ID指定</p>
<p>容器和另外一个容器共享Network namespace。新创建的容器不会创建自己的网卡，配置自己的 IP，而是和一个指定的容器共享 IP、端口范围等。</p>
</li>
<li><p>None模式（默认模式）：使用--net=none指定</p>
<p>容器有独立的Network namespace，但并没有对其进行任何网络设置，如分配veth pair 和网桥连接，配置IP等。</p>
<p>注意：这种类型的网络没有办法联网，封闭的网络能很好的保证容器的安全性。</p>
</li>
</ol>
<h2 id="bridge模式（重点）"><a href="#bridge模式（重点）" class="headerlink" title="bridge模式（重点）"></a>bridge模式（重点）</h2><pre><code>我们先来创建2个busybox容器。
docker run -itd --name busybox1 busybox
docker run -itd --name busybox2 busybox</code></pre><p>我们使用 docker network inspect bridge 可以查看bridge网络的详情<br><img src="/images/docker/bridge%E8%AF%A6%E6%83%85.png" alt="bridge详情.png"></p>
<p>可以看到容器名称，IP地址，Container Id 信息。</p>
<p>我们进入busybox1容器</p>
<pre><code>docker exec -it busybox1 sh</code></pre><p>我们看下在 busybox1 容器内部是否可以ping通busybox2的IP。再尝试下是否可以ping通busybox2的 Container Name<br><img src="/images/docker/ping-ip-busybox2.png" alt="ping-ip-busybox2.png"></p>
<p>我们发现busybox1和busybox2可以通过IP互通，但是无法通知container name通讯。所以默认bridge只支持ip互通。</p>
<h3 id="link"><a href="#link" class="headerlink" title="-- link"></a>-- link</h3><p>如果我们想让bridge模式的Container之间支持通过Container Name通讯。我们可以使用--link 的方式。<br>我们删除busybox2容器。重新创建busybox2容器，并且让其和busybox1建立网络映射关系。</p>
<pre><code>docker stop busybox2
docker rm busybox2
docker run -itd --name busybox2 --link busybox1 busybox</code></pre><p><img src="/images/docker/busybox2-ping-busybox1.png" alt="busybox2-ping-busybox1.png"></p>
<p>busybox2 容器内部可以通过container name ping通busybox1<br>然而反过来busybox1 容器内部 <strong>不可以</strong> 通过 container name ping通busybox2。</p>
<p>我们删除busybox1容器。重新创建busybox1容器，并且让其和busybox2建立网络映射关系。</p>
<pre><code>docker stop busybox1
docker rm busybox1
docker run -itd --name busybox1 --link busybox2 busybox</code></pre><p><img src="/images/docker/busybox1-ping-busybox2.png" alt="busybox1-ping-busybox2.png"></p>
<p>这样就可以了.</p>
<p>总结一下: --link方式可以在容器间建立映射关系。如果想容器间互相通过container name 通信，则容器间都需要 --link 链接。</p>
<h2 id="自定义网络（重点）"><a href="#自定义网络（重点）" class="headerlink" title="自定义网络（重点）"></a>自定义网络（重点）</h2><p>除了--link 可以实现容器间 container name 通信，还有自定义网桥这个方式。</p>
<p>命令：</p>
<pre><code>docker network create -d &lt;bridge|host|container|none&gt; network_name</code></pre><p>下面我们命名一个my-bridge的自定义网络。通常情况下使用如下命令即可创建。</p>
<pre><code>docker network create -d bridge my-bridge</code></pre><p>模式选择的是默认的bridge。</p>
<p>使用docker network ls即可查看网络列表<br><img src="/images/docker/my-bridge.png" alt="my-bridge.png"></p>
<p>使用docker run 创建容器时，添加--net=my-bridge即可配置使用自定义网络。</p>
<p>如果是已经创建好的容器，通过以下命令可以连接到自定义网络上：<br>    docker network connect my-bridge busybox1<br><img src="/images/docker/my-bridge-box1.png" alt="my-bridge-box1.png"></p>
<p>那么如何在docker-compose.yml中配置自定义网络呢？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">version: &#39;3&#39;</span></pre></td></tr><tr><td class="code"><pre><span class="line">services:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  elasticsearch:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    image: elasticsearch:6.4.1</span></pre></td></tr><tr><td class="code"><pre><span class="line">    container_name: elasticsearch</span></pre></td></tr><tr><td class="code"><pre><span class="line">    environment:</span></pre></td></tr><tr><td class="code"><pre><span class="line">      - &quot;cluster.name&#x3D;elasticsearch&quot; #集群名称为elasticsearch</span></pre></td></tr><tr><td class="code"><pre><span class="line">      - &quot;discovery.type&#x3D;single-node&quot; #单节点启动</span></pre></td></tr><tr><td class="code"><pre><span class="line">      - &quot;ES_JAVA_OPTS&#x3D;-Xms512m -Xmx512m&quot; #jvm内存分配为512MB</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    ......</span></pre></td></tr><tr><td class="code"><pre><span class="line">    networks:</span></pre></td></tr><tr><td class="code"><pre><span class="line">      - my-bridge  </span></pre></td></tr><tr><td class="code"><pre><span class="line">networks:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  my-bridge:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    driver: bridge</span></pre></td></tr></table></figure>

<p>以上docker-compose.yml同样可以创建my-bridge自定义网络。并且创建的elasticsearch容器会配置使用my-bridge自定义网络。<br><img src="/images/docker/docker-network.png" alt="docker-network.png"></p>
<p>我们发现自动给my-bridge添加了elk前缀，变为了elk_my-bridge ，elk是docker-compose.yml文件的目录名。感觉是为了避免重名吧，不太清楚了！！</p>
<p>我们查看下elk_my-bridge详情<br>    docker network inspect elk_my-bridge </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker network inspect elk_my-bridge </span></pre></td></tr><tr><td class="code"><pre><span class="line">[</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &quot;Name&quot;: &quot;elk_my-bridge&quot;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &quot;Id&quot;: &quot;d28de6a1cda8b97a282bdab80a10eeae6ac75acb27c3992f51799dad49f0c98c&quot;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &quot;Created&quot;: &quot;2020-01-27T22:10:46.179450229+08:00&quot;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &quot;Scope&quot;: &quot;local&quot;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &quot;Driver&quot;: &quot;bridge&quot;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &quot;EnableIPv6&quot;: false,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &quot;IPAM&quot;: &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &quot;Driver&quot;: &quot;default&quot;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &quot;Options&quot;: null,</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &quot;Config&quot;: [</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    &quot;Subnet&quot;: &quot;172.19.0.0&#x2F;16&quot;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    &quot;Gateway&quot;: &quot;172.19.0.1&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ]</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &quot;Internal&quot;: false,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &quot;Attachable&quot;: true,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &quot;Ingress&quot;: false,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &quot;ConfigFrom&quot;: &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &quot;Network&quot;: &quot;&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &quot;ConfigOnly&quot;: false,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &quot;Containers&quot;: &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &quot;4dbffe4469778db7574198a4336b3637653c434a541c102728b9dcf321824c85&quot;: &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &quot;Name&quot;: &quot;kibana&quot;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &quot;EndpointID&quot;: &quot;1dc354be523cc7cbb944545be273d4b0c0b85e0e9b00463213b412a7879a7390&quot;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &quot;MacAddress&quot;: &quot;02:42:ac:13:00:04&quot;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &quot;IPv4Address&quot;: &quot;172.19.0.4&#x2F;16&quot;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &quot;IPv6Address&quot;: &quot;&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &quot;71607bb793ed6ee0faf9e9d26967c8588abc8076a2cdf6cf1822fb0f321c2c0c&quot;: &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &quot;Name&quot;: &quot;elasticsearch&quot;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &quot;EndpointID&quot;: &quot;e873552071bd5cf9dd86bc564be568ff37ca74ab51c59d1a68d8b416b1cb0da3&quot;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &quot;MacAddress&quot;: &quot;02:42:ac:13:00:02&quot;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &quot;IPv4Address&quot;: &quot;172.19.0.2&#x2F;16&quot;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &quot;IPv6Address&quot;: &quot;&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &quot;e5c7736099fe779d7718f35557161a05ba2ba03ddcbf20c73a4146794fbb7df8&quot;: &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &quot;Name&quot;: &quot;logstash&quot;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &quot;EndpointID&quot;: &quot;5e8821f7e67780468664b7947be64fdb0bf2de3e8b2b2f73d675dd8e29ee0878&quot;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &quot;MacAddress&quot;: &quot;02:42:ac:13:00:03&quot;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &quot;IPv4Address&quot;: &quot;172.19.0.3&#x2F;16&quot;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &quot;IPv6Address&quot;: &quot;&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &quot;Options&quot;: &#123;&#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &quot;Labels&quot;: &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &quot;com.docker.compose.network&quot;: &quot;my-bridge&quot;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &quot;com.docker.compose.project&quot;: &quot;elk&quot;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &quot;com.docker.compose.version&quot;: &quot;1.22.0&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">]</span></pre></td></tr></table></figure>

<p>可以看到elk_my-bridge网桥的详情，而且发现容器的IP变为了172.19.X.X不再是默认docker 网段172.17.X.X。应该是自定义网桥的原因吧。<br>elasticsearch，logstash，kibana之间是可以通过容器名来通信的。</p>
<p>OK，今天就到这吧，2020年春节，冠状病毒肺炎疫情很严峻，闷在家里总结下以前的知识点。愿这次的疫情尽早解决吧，武汉加油！湖北加油！！中国加油！！！</p>
<p>参考：<br><a href="https://www.cnblogs.com/kaye/p/10508800.html" target="_blank" rel="noopener">https://www.cnblogs.com/kaye/p/10508800.html</a><br><a href="https://blog.csdn.net/wucong60/article/details/83757813" target="_blank" rel="noopener">https://blog.csdn.net/wucong60/article/details/83757813</a><br><a href="https://www.cnblogs.com/zuxing/articles/8780661.html" target="_blank" rel="noopener">https://www.cnblogs.com/zuxing/articles/8780661.html</a><br><a href="https://www.jianshu.com/p/22a7032bb7bd" target="_blank" rel="noopener">https://www.jianshu.com/p/22a7032bb7bd</a><br><a href="https://mrbird.cc/Docker-network.html" target="_blank" rel="noopener">https://mrbird.cc/Docker-network.html</a></p>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker Compose笔记</title>
    <url>/2020/01/26/docker-04/</url>
    <content><![CDATA[<p>Docker Compose 是用于定义和运行多容器 Docker 应用程序的工具。微服务架构的应用系统一般包含若干个微服务，每个微服务可能会部署可能需要用到多个Docker容器，比如MySQL，Redis，Nginx等，单独的去管理每个容器可能会比较麻烦。</p>
<p>Docker Compose 可以通过一个yml文件来统一管理这些容器，可以极大简化我们的应用部署过程。</p>
<h2 id="安装Docker-Compose"><a href="#安装Docker-Compose" class="headerlink" title="安装Docker Compose"></a>安装Docker Compose</h2><p>可以参考我的博客：<a href="http://blog.gaoyp.cn/2019/12/26/docker-01/">linux（centos7）安装docker</a></p>
<h2 id="Docker-Compose-配置指令"><a href="#Docker-Compose-配置指令" class="headerlink" title="Docker Compose 配置指令"></a>Docker Compose 配置指令</h2><p>我们先来看一个docker-compose.yml文件，这个是直接抄鸟哥的，感谢鸟哥。鸟哥博客：<a href="https://mrbird.cc/" target="_blank" rel="noopener">https://mrbird.cc/</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">version: &#39;3&#39;</span></pre></td></tr><tr><td class="code"><pre><span class="line">services:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  elasticsearch:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    image: elasticsearch:6.4.1</span></pre></td></tr><tr><td class="code"><pre><span class="line">    container_name: elasticsearch</span></pre></td></tr><tr><td class="code"><pre><span class="line">    environment:</span></pre></td></tr><tr><td class="code"><pre><span class="line">      - &quot;cluster.name&#x3D;elasticsearch&quot; #集群名称为elasticsearch</span></pre></td></tr><tr><td class="code"><pre><span class="line">      - &quot;discovery.type&#x3D;single-node&quot; #单节点启动</span></pre></td></tr><tr><td class="code"><pre><span class="line">      - &quot;ES_JAVA_OPTS&#x3D;-Xms512m -Xmx512m&quot; #jvm内存分配为512MB</span></pre></td></tr><tr><td class="code"><pre><span class="line">    volumes:</span></pre></td></tr><tr><td class="code"><pre><span class="line">      - &#x2F;kiki&#x2F;elasticsearch&#x2F;plugins:&#x2F;usr&#x2F;share&#x2F;elasticsearch&#x2F;plugins</span></pre></td></tr><tr><td class="code"><pre><span class="line">      - &#x2F;kiki&#x2F;elasticsearch&#x2F;data:&#x2F;usr&#x2F;share&#x2F;elasticsearch&#x2F;data</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ports:</span></pre></td></tr><tr><td class="code"><pre><span class="line">      - 9200:9200</span></pre></td></tr><tr><td class="code"><pre><span class="line">    networks:</span></pre></td></tr><tr><td class="code"><pre><span class="line">      - my-bridge  </span></pre></td></tr><tr><td class="code"><pre><span class="line">kibana:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    image: kibana:6.4.1</span></pre></td></tr><tr><td class="code"><pre><span class="line">    container_name: kibana</span></pre></td></tr><tr><td class="code"><pre><span class="line">    links:</span></pre></td></tr><tr><td class="code"><pre><span class="line">      - elasticsearch:es #配置elasticsearch域名为es</span></pre></td></tr><tr><td class="code"><pre><span class="line">    depends_on:</span></pre></td></tr><tr><td class="code"><pre><span class="line">      - elasticsearch</span></pre></td></tr><tr><td class="code"><pre><span class="line">    environment:</span></pre></td></tr><tr><td class="code"><pre><span class="line">      - &quot;elasticsearch.hosts&#x3D;http:&#x2F;&#x2F;es:9200&quot; #因为上面配置了域名，所以这里可以简写为http:&#x2F;&#x2F;es:9200</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ports:</span></pre></td></tr><tr><td class="code"><pre><span class="line">      - 5601:5601</span></pre></td></tr><tr><td class="code"><pre><span class="line">    networks:</span></pre></td></tr><tr><td class="code"><pre><span class="line">      - my-bridge</span></pre></td></tr><tr><td class="code"><pre><span class="line">  logstash:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    image: logstash:6.4.1</span></pre></td></tr><tr><td class="code"><pre><span class="line">    container_name: logstash</span></pre></td></tr><tr><td class="code"><pre><span class="line">    volumes:</span></pre></td></tr><tr><td class="code"><pre><span class="line">      - &#x2F;kiki&#x2F;logstash&#x2F;logstash-febs.conf:&#x2F;usr&#x2F;share&#x2F;logstash&#x2F;pipeline&#x2F;logstash.conf</span></pre></td></tr><tr><td class="code"><pre><span class="line">    depends_on:</span></pre></td></tr><tr><td class="code"><pre><span class="line">      - elasticsearch</span></pre></td></tr><tr><td class="code"><pre><span class="line">    links:</span></pre></td></tr><tr><td class="code"><pre><span class="line">      - elasticsearch:es</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ports:</span></pre></td></tr><tr><td class="code"><pre><span class="line">      - 4560:4560</span></pre></td></tr><tr><td class="code"><pre><span class="line">    networks:</span></pre></td></tr><tr><td class="code"><pre><span class="line">      - my-bridge</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">networks:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  my-bridge:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    driver: bridge</span></pre></td></tr></table></figure>
<p>以上是一个ELK日志分析系统的docker-compose.yml文件。我们通过这个为例介绍常用的 Docker Compose 配置指令</p>
<ol>
<li><p>version：指定本 yml 依从的 compose 哪个版本制定的<br> compose与docker版本对应可以查看<a href="https://docs.docker.com/compose/compose-file/" target="_blank" rel="noopener">https://docs.docker.com/compose/compose-file/</a><br> 使用 docker version 可以查看docker版本，我虚拟机docker版本是 19.03.5,目前为止 version 3.7 及以下均可。<br> <img src="/images/docker/dockercompose%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB.png" alt="dockercompose对应关系.png"></p>
</li>
<li><p>services：多个容器集合。一个service代表一个container，可以通过image创建，也可以通过本地的dockerfile来创建。上栗就创建了3个container。</p>
</li>
<li><p>image：使用指定容器运行的镜像</p>
</li>
<li><p>container_name：指定自定义容器名称，而不是生成的默认名称。</p>
</li>
<li><p>volumes：将主机的数据卷或着文件挂载到容器里。<br> 格式：<br> - 主机主机的数据卷或着文件：容器数据卷或着文件</p>
</li>
<li><p>depends_on：设置依赖关系：使用docker-compose up 启动时elasticsearch启动后 kibana和logstash才会启动。关闭时反过来</p>
</li>
<li><p>environment：添加环境变量。您可以使用数组或字典、任何布尔值，布尔值需要用引号引起来</p>
</li>
<li><p>ports：进行端口映射</p>
</li>
<li><p>networks： 配置容器连接的网络,此处设置可名为my-bridge的bridge类型的网络。关于docker 网络，我们下一节再介绍。</p>
</li>
<li><p>links： 服务之间可以使用服务名称相互访问，links 允许定义一个别名，从而使用该别名访问其它服务.上面我们设置elasticsearch别名为es。 kibana和logstash可以使用elasticsearch或es访问elasticsearch容器。</p>
</li>
<li><p>command: 覆盖容器启动的默认命令</p>
</li>
<li><p>build：与image效果相同。不过build是利用Dockerfile构建，Compose 会利用它自动构建镜像，该值可以是一个路径，也可以是一个对象，用于指定 Dockerfile 参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">version: &quot;3.7&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">services:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  webapp:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    build: .&#x2F;dir</span></pre></td></tr></table></figure>
<p>指定上下文路径为 ./dir ，及使用./dir下的Dockerfile文件构建镜像。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">version: &quot;3.7&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">services:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  webapp:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    build:</span></pre></td></tr><tr><td class="code"><pre><span class="line">      context: .&#x2F;dir</span></pre></td></tr><tr><td class="code"><pre><span class="line">      dockerfile: Dockerfile-alternate</span></pre></td></tr><tr><td class="code"><pre><span class="line">      args:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        buildno: 1</span></pre></td></tr><tr><td class="code"><pre><span class="line">      labels:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        - &quot;com.example.description&#x3D;Accounting webapp&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        - &quot;com.example.department&#x3D;Finance&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        - &quot;com.example.label-with-empty-value&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      target: prod</span></pre></td></tr></table></figure>
<p>指定上下文路径为 ./dir ，及使用./dir下的Dockerfile文件构建镜像。</p>
<ul>
<li>context：上下文路径。</li>
<li>dockerfile：指定构建镜像的 Dockerfile 文件命。这里指定 Dockerfile-alternate，不是必须命名为 Dockerfile</li>
<li>args：添加构建参数，这是只能在构建过程中访问的环境变量。</li>
<li>labels：设置构建镜像的标签。</li>
<li>target：多层构建，可以指定构建哪一层。</li>
</ul>
</li>
</ol>
<h2 id="DockerCompose常用命令"><a href="#DockerCompose常用命令" class="headerlink" title="DockerCompose常用命令"></a>DockerCompose常用命令</h2><blockquote>
<p>docker-compose up -d</p>
</blockquote>
<p>通过docker-compose.yaml文件创建并启动容器，-d，后台启动</p>
<blockquote>
<p>docker-compose stop</p>
</blockquote>
<p>关闭docker-compose.yaml文件创启动的容器</p>
<blockquote>
<p>docker-compose start</p>
</blockquote>
<p>启动docker-compose stop命令关闭的容器</p>
<blockquote>
<p>docker-compose down</p>
</blockquote>
<p>停止并删除创建的容器（同时删除创建的network，volume，container）</p>
<blockquote>
<p>docker-compose up</p>
</blockquote>
<p>当服务的配置发生更改时，可使用 docker-compose up 命令更新配置.此时，Compose 会删除旧容器并创建新容器，新容器会以不同的 IP 地址加入网络，名称保持不变，任何指向旧容起的连接都会被关闭，重新找到新容器并连接上去</p>
<h2 id="搭建-ELK日志分析系统"><a href="#搭建-ELK日志分析系统" class="headerlink" title="搭建 ELK日志分析系统"></a>搭建 ELK日志分析系统</h2><p>接下来我们实践一下，使用DockerCompose 搭建一个ELK日志分析系统。</p>
<p>ELK:（ELK 由 ElasticSearch 、 Logstash 和 Kiabana 三个开源工具组成）,Elasticsearch用于存储日志信息，Logstash用于收集日志，Kibana用于图形化展示。</p>
<h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><ol>
<li><p>linux Elasticsearch 默认使用 mmapfs目录来存储其索引。操作系统对mmap计数的限制可能太低，这可能会导致内存不足异常。在Linux上，可以通过运行以下命令来增加限制 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sysctl -w vm.max_map_count&#x3D;262144</span></pre></td></tr></table></figure></li>
<li><p>创建数据挂载路径</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir -p &#x2F;usr&#x2F;local&#x2F;kiki&#x2F;elk # 创建ELK Docker Compose文件存储路径</span></pre></td></tr><tr><td class="code"><pre><span class="line">mkdir -p &#x2F;usr&#x2F;local&#x2F;kiki&#x2F;elasticsearch&#x2F;data # 创建Elasticsearch数据挂载路径</span></pre></td></tr><tr><td class="code"><pre><span class="line">mkdir -p &#x2F;usr&#x2F;local&#x2F;kiki&#x2F;elasticsearch&#x2F;plugins # 创建Elasticsearch插件挂载路径</span></pre></td></tr><tr><td class="code"><pre><span class="line">mkdir -p &#x2F;usr&#x2F;local&#x2F;kiki&#x2F;logstash # 创建Logstash配置文件存储路径</span></pre></td></tr></table></figure></li>
<li><p>在/usr/local/kiki/logstash 路径下创建logstash-kiki.conf配置文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">input &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  tcp &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    mode &#x3D;&gt; &quot;server&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    host &#x3D;&gt; &quot;0.0.0.0&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    port &#x3D;&gt; 4560</span></pre></td></tr><tr><td class="code"><pre><span class="line">    codec &#x3D;&gt; json_lines</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">output &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  elasticsearch &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    hosts &#x3D;&gt; &quot;es:9200&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    index &#x3D;&gt; &quot;kiki-logstash-%&#123;+YYYY.MM.dd&#125;&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>logstash-kiki.conf定义了logstash的input和output。</p>
</li>
<li><p>在/usr/local/kiki/elk下创建docker-compose.yml文件，内容如下，</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">version: &#39;3&#39;</span></pre></td></tr><tr><td class="code"><pre><span class="line">services:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  elasticsearch:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    image: elasticsearch:6.4.1</span></pre></td></tr><tr><td class="code"><pre><span class="line">    container_name: elasticsearch</span></pre></td></tr><tr><td class="code"><pre><span class="line">    environment:</span></pre></td></tr><tr><td class="code"><pre><span class="line">      - &quot;cluster.name&#x3D;elasticsearch&quot; #集群名称为elasticsearch</span></pre></td></tr><tr><td class="code"><pre><span class="line">      - &quot;discovery.type&#x3D;single-node&quot; #单节点启动</span></pre></td></tr><tr><td class="code"><pre><span class="line">      - &quot;ES_JAVA_OPTS&#x3D;-Xms512m -Xmx512m&quot; #jvm内存分配为512MB</span></pre></td></tr><tr><td class="code"><pre><span class="line">    volumes:</span></pre></td></tr><tr><td class="code"><pre><span class="line">      - &#x2F;usr&#x2F;local&#x2F;kiki&#x2F;elasticsearch&#x2F;plugins:&#x2F;usr&#x2F;share&#x2F;elasticsearch&#x2F;plugins</span></pre></td></tr><tr><td class="code"><pre><span class="line">      - &#x2F;usr&#x2F;local&#x2F;kiki&#x2F;elasticsearch&#x2F;data:&#x2F;usr&#x2F;share&#x2F;elasticsearch&#x2F;data</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ports:</span></pre></td></tr><tr><td class="code"><pre><span class="line">      - 9200:9200</span></pre></td></tr><tr><td class="code"><pre><span class="line">    networks:</span></pre></td></tr><tr><td class="code"><pre><span class="line">      - my-bridge  </span></pre></td></tr><tr><td class="code"><pre><span class="line">  kibana:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    image: kibana:6.4.1</span></pre></td></tr><tr><td class="code"><pre><span class="line">    container_name: kibana</span></pre></td></tr><tr><td class="code"><pre><span class="line">    links:</span></pre></td></tr><tr><td class="code"><pre><span class="line">      - elasticsearch:es #配置elasticsearch域名为es</span></pre></td></tr><tr><td class="code"><pre><span class="line">    depends_on:</span></pre></td></tr><tr><td class="code"><pre><span class="line">      - elasticsearch</span></pre></td></tr><tr><td class="code"><pre><span class="line">    environment:</span></pre></td></tr><tr><td class="code"><pre><span class="line">      - &quot;elasticsearch.hosts&#x3D;http:&#x2F;&#x2F;es:9200&quot; #因为上面配置了域名，所以这里可以简写为http:&#x2F;&#x2F;es:9200</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ports:</span></pre></td></tr><tr><td class="code"><pre><span class="line">      - 5601:5601</span></pre></td></tr><tr><td class="code"><pre><span class="line">    networks:</span></pre></td></tr><tr><td class="code"><pre><span class="line">      - my-bridge</span></pre></td></tr><tr><td class="code"><pre><span class="line">  logstash:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    image: logstash:6.4.1</span></pre></td></tr><tr><td class="code"><pre><span class="line">    container_name: logstash</span></pre></td></tr><tr><td class="code"><pre><span class="line">    volumes:</span></pre></td></tr><tr><td class="code"><pre><span class="line">      - &#x2F;usr&#x2F;local&#x2F;kiki&#x2F;logstash&#x2F;logstash-kiki.conf:&#x2F;usr&#x2F;share&#x2F;logstash&#x2F;pipeline&#x2F;logstash.conf</span></pre></td></tr><tr><td class="code"><pre><span class="line">    depends_on:</span></pre></td></tr><tr><td class="code"><pre><span class="line">      - elasticsearch</span></pre></td></tr><tr><td class="code"><pre><span class="line">    links:</span></pre></td></tr><tr><td class="code"><pre><span class="line">      - elasticsearch:es</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ports:</span></pre></td></tr><tr><td class="code"><pre><span class="line">      - 4560:4560</span></pre></td></tr><tr><td class="code"><pre><span class="line">    networks:</span></pre></td></tr><tr><td class="code"><pre><span class="line">      - my-bridge</span></pre></td></tr><tr><td class="code"><pre><span class="line">networks:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  my-bridge:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    driver: bridge</span></pre></td></tr></table></figure>

<p>实际操作如图：<br><img src="/images/docker/elk%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C.png" alt="elk准备工作.png"></p>
<h4 id="启动ELK"><a href="#启动ELK" class="headerlink" title="启动ELK"></a>启动ELK</h4><p>切换到/usr/local/kiki/elk 目录下，使用docker-compose up 启动。第一次执行需要下载3个镜像。<br><img src="/images/docker/compose%E5%90%AF%E5%8A%A8elk.png" alt="compose启动elk.png"></p>
<p>使用docker-compose ps查看启动状态<br><img src="/images/docker/compose-ps-elk.png" alt="compose-ps-elk.png"></p>
<p>发现elasticsearch没有启动，这是因为elasticsearch的data目录权限不够。执行 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod 774 &#x2F;usr&#x2F;local&#x2F;kiki&#x2F;elasticsearch&#x2F;data&#x2F;</span></pre></td></tr></table></figure>
<p>再次执行docker-compose up -d,再次查看 docker-compose ps<br><img src="/images/docker/elk-ps.png" alt="elk-ps.png"></p>
<p>logstash-kiki.conf配置文件中用到了json_lines来处理json类型的日志数据。所以我们需要为logstash安装json_lines插件。</p>
<ul>
<li>进入到logstash 容器中：docker exec -it logstash /bin/bash</li>
<li>进入容器的 /bin/ 目录，执行logstash-plugin install logstash-codec-json_lines</li>
</ul>
<p><img src="/images/docker/%E5%AE%89%E8%A3%85json_lines.png" alt="安装json_lines.png"></p>
<p>安装过程很慢，中间报错是因为断网了，再次执行下命令静静等待就行，安装完成后输入exit退出，或者按Ctrl+Q+P 退出。</p>
<p>访问<a href="http://192.168.85.128:5601/" target="_blank" rel="noopener">http://192.168.85.128:5601/</a> ，192.168.85.128是我虚拟机IP，结果如下：<br><img src="/images/docker/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%AE%BF%E9%97%AEelk.png" alt="浏览器访问elk.png"></p>
<h3 id="使用ELK"><a href="#使用ELK" class="headerlink" title="使用ELK"></a>使用ELK</h3><p>我们顺便记录下SpringBoot项目如何接入ELK日志分析系统。</p>
<ol>
<li><p>首先在POM.xml文件中引入logstash,此处springboot项目使用logback作为日志框架</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;groupId&gt;net.logstash.logback&lt;&#x2F;groupId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;artifactId&gt;logstash-logback-encoder&lt;&#x2F;artifactId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;version&gt;6.1&lt;&#x2F;version&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;&#x2F;dependency&gt;</span></pre></td></tr></table></figure></li>
<li><p>在项目的logback-spring.xml配资文件中添加</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--输出到 logstash的 appender--&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;appender name&#x3D;&quot;logstash&quot; class&#x3D;&quot;net.logstash.logback.appender.LogstashTcpSocketAppender&quot;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;destination&gt;192.168.85.128:4560&lt;&#x2F;destination&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;encoder charset&#x3D;&quot;UTF-8&quot; class&#x3D;&quot;net.logstash.logback.encoder.LogstashEncoder&quot;&#x2F;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;&#x2F;appender&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">......</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;root level&#x3D;&quot;info&quot;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ......</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;appender-ref ref&#x3D;&quot;logstash&quot; &#x2F;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;&#x2F;root&gt;</span></pre></td></tr></table></figure></li>
<li><p>168.85.128:4560对应我们刚刚搭建的Logstash地址</p>
</li>
<li><p>配置Kiabana<br>访问<a href="http://192.168.85.128:5601/做一些配置" target="_blank" rel="noopener">http://192.168.85.128:5601/做一些配置</a></p>
</li>
</ol>
<ul>
<li>Kibana管理界面点击左侧Management,点击 Kinaba Index Patterns</li>
<li>在Index pattern里输入我们在logstash配置文件logstash-kiki.conf里output.index指定的值kiki-logstash-*,点击下一步，注意，这里需要检查elasticsearch中是否有匹配数据。<br>所以，需要按上面的步骤创建springboot项目并启动，否则无法点击Next Step。</li>
<li>点击Next Step，在下拉框里选择@timestamp</li>
<li>点击 Create index patterns</li>
</ul>
<p><img src="/images/docker/logstash.gif" alt="logstash"> </p>
<ol start="4">
<li>使用postman调用接口，产生日志数据,代码如下<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.sxdx.sso.resource.one.controller;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import lombok.extern.slf4j.Slf4j;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.security.access.prepost.PreAuthorize;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.web.bind.annotation.GetMapping;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.web.bind.annotation.RestController;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">import java.security.Principal;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import java.util.HashMap;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import java.util.Map;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">@Slf4j</span></pre></td></tr><tr><td class="code"><pre><span class="line">@RestController</span></pre></td></tr><tr><td class="code"><pre><span class="line">public class OneController &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    @GetMapping(&quot;&#x2F;user&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public Principal user(Principal principal) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        log.info(&quot;获取当前登录人信息&quot;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        return principal;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
我的访问接口访问路径为localhost:8002/one/user。查看是否搜集到了日志数据。</li>
</ol>
<p><img src="/images/docker/%E9%AA%8C%E8%AF%81%E6%98%AF%E5%90%A6%E6%90%9C%E9%9B%86%E5%88%B0%E4%BA%86%E6%97%A5%E5%BF%97%E6%95%B0%E6%8D%AE.png" alt="验证是否搜集到了日志数据.png"> </p>
<p>可以看到已经获取到了日志数据。完工！！！</p>
]]></content>
      <categories>
        <category>docker</category>
        <category>ELK</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>ELK</tag>
      </tags>
  </entry>
  <entry>
    <title>docker常用命令及Dockerfile笔记</title>
    <url>/2020/01/19/docker-03/</url>
    <content><![CDATA[<blockquote>
<p>docker主要的3个概念：镜像（image）+容器（container）+仓库（repository）</p>
</blockquote>
<ul>
<li>docker镜像：概念类似虚拟机的镜像，可以用来创建新的容器。</li>
<li>docker仓库：docker仓库概念和git类似。docker仓库是用来包含镜像的位置。</li>
<li>docker容器：是由docker镜像创建的运行实例。docker容器类似虚拟机，可以执行包含启动，停止，删除等。每个容器间是相互隔离的。容器中会运行特定的运用，包含特定应用的代码及所需的依赖文件。可以把容器看作一个简易版的linux环境（包含root用户权限，进程空间，用户空间和网络空间等）和运行在其中的应用程序。</li>
</ul>
<p><img src="/images/docker/%E4%BB%93%E5%BA%93-%E9%95%9C%E5%83%8F-%E5%AE%B9%E5%99%A8%E5%85%B3%E7%B3%BB%E5%9B%BE.png" alt="仓库-镜像-容器关系图.png"></p>
<p>我们在这个过程中熟悉经常使用的命令。</p>
<h2 id="Docker-镜像和容器"><a href="#Docker-镜像和容器" class="headerlink" title="Docker 镜像和容器"></a>Docker 镜像和容器</h2><h3 id="镜像查询"><a href="#镜像查询" class="headerlink" title="镜像查询"></a>镜像查询</h3><p>docker镜像查询地址dockerhub：<a href="https://hub.docker.com/search" target="_blank" rel="noopener">https://hub.docker.com/search</a><br><img src="/images/docker/hub.docker.com.png" alt="hub.docker.com.png"></p>
<p>我们也可以使用docker search:镜像名称  的方式，搜索镜像,这种方式无法查询镜像tags。<br><img src="/images/docker/%E6%90%9C%E7%B4%A2%E9%95%9C%E5%83%8F.png" alt="搜索镜像.png"></p>
<p>各个选项说明:</p>
<ul>
<li>NAME: 镜像仓库源的名称</li>
<li>DESCRIPTION: 镜像的描述</li>
<li>OFFICIAL: 是否 docker 官方发布</li>
<li>stars: 类似 Github 里面的 star，表示点赞、喜欢的意思。</li>
<li>AUTOMATED: 自动构建。</li>
</ul>
<h3 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h3><p>我们以nginx 为例</p>
<ul>
<li>拉取nginx镜像到本地</li>
</ul>
<p>docker pull 镜像名称:镜像tags。如果不加 tags，默认拉取最新镜像（latest）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull nginx:latest</span></pre></td></tr></table></figure>

<p>直接执行命令报：<br>Got permission denied while trying to connect to the Docker daemon socket ….: connect: permission denied</p>
<p>我们使用su root 命令切换到root用户，再次执行docker pull nginx:latest。<br><img src="/images/docker/%E4%B8%8B%E8%BD%BDnginx%E9%95%9C%E5%83%8F.png" alt="下载nginx镜像.png"></p>
<p>使用docker images 命令即可查看已经拥有的镜像。<br><img src="/images/docker/%E6%9F%A5%E7%9C%8B%E5%B7%B2%E4%B8%8B%E8%BD%BDimages.png" alt="查看已下载images.png"></p>
<p>各个选项说明:</p>
<ul>
<li>REPOSITORY：表示镜像的仓库源</li>
<li>TAG：镜像的标签</li>
<li>IMAGE ID：镜像ID</li>
<li>CREATED：镜像创建时间</li>
<li>SIZE：镜像大小</li>
</ul>
<h3 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h3><p>如果不加 :镜像tags，默认删除最新镜像。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker rmi nginx:latest</span></pre></td></tr></table></figure>

<h3 id="创建容器"><a href="#创建容器" class="headerlink" title="创建容器"></a>创建容器</h3><p>使用镜像创建一个 nginx容器</p>
<ol>
<li>创建挂载目录<br>mkdir -p /usr/local/nginx/{conf,html,logs}</li>
<li>在/usr/local/nginx/conf下创建nginx.conf文件，作为外置配置文件使用。这样我们就可以很方便的配置nginx。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">user  nginx;</span></pre></td></tr><tr><td class="code"><pre><span class="line">worker_processes  1;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">error_log  &#x2F;var&#x2F;log&#x2F;nginx&#x2F;error.log warn;</span></pre></td></tr><tr><td class="code"><pre><span class="line">pid        &#x2F;var&#x2F;run&#x2F;nginx.pid;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">events &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    worker_connections  1024;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">http &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    include       &#x2F;etc&#x2F;nginx&#x2F;mime.types;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    default_type  application&#x2F;octet-stream;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                      &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                      &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    access_log  &#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log  main;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    sendfile        on;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    #tcp_nopush     on;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    keepalive_timeout  65;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    #gzip  on;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    include &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;*.conf;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
在/usr/local/nginx/html目录下新建index.html<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;html&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;head&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;meta charset&#x3D;&quot;utf-8&quot;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;title&gt;Docker Nginx&lt;&#x2F;title&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;&#x2F;head&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;body&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;h1&gt;Docker Nginx&lt;&#x2F;h1&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;p&gt; Hello, Nginx.&lt;&#x2F;p&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;&#x2F;body&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;&#x2F;html&gt;</span></pre></td></tr></table></figure>
执行命令：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -d -p 80:80 --name nginx80 --restart&#x3D;always -v &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;html:&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html -v &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;nginx.conf:&#x2F;etc&#x2F;nginx&#x2F;nginx.conf -v &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;logs&#x2F;:&#x2F;var&#x2F;log&#x2F;nginx nginx:latest</span></pre></td></tr></table></figure>

</li>
</ol>
<p>如果返回一长串字符即为成功。使用docker ps 即可看到已启动容器列表：<br><img src="/images/docker/docker-nginx80.png" alt="docker-nginx80.png"></p>
<p>参数说明：</p>
<ul>
<li>-d 后台运行</li>
<li>-p 设置端口映射 宿主机端口：容器端口</li>
<li>--name 设置容器别名</li>
<li>--restart=always 设置容器开机启动</li>
<li>-v 数据卷映射 宿主机目录：容器目录。这样方便我们管理容器配置文件及日志文件</li>
</ul>
<p>最后加上nginx:latest，表示我们是以nginx:latest为模板创建的。</p>
<p>浏览器访问：<a href="http://192.168.85.128/" target="_blank" rel="noopener">http://192.168.85.128/</a> 返回<br><img src="/images/docker/nginx-%E9%A6%96%E9%A1%B5.png" alt="nginx-首页.png"></p>
<h3 id="基于容器构建镜像"><a href="#基于容器构建镜像" class="headerlink" title="基于容器构建镜像"></a>基于容器构建镜像</h3><p>镜像创建有2种方式：</p>
<ul>
<li>从已经创建的容器中更新镜像，并且提交这个镜像</li>
<li>使用 Dockerfile 指令来创建一个新的镜像</li>
</ul>
<p>我们先介绍第一种。<br>在上一步已经创建了一个nginx容器，使用命令docker commit 可创建镜像。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker commit -m&#x3D;&quot;garnett nginx&quot; -a&#x3D;&quot;garnett&quot; nginx80 garnett&#x2F;nginx:1.0</span></pre></td></tr></table></figure>
<p>参数介绍：<br>-m 设置注释<br>-a 设置作者<br>nginx80 容器名称，也可以使用container id<br>garnett/nginx:1.0  设置镜像的仓库源repository和tags</p>
<p>使用docker images 查看镜像列表：<br><img src="/images/docker/%E5%AE%B9%E5%99%A8%E5%88%9B%E5%BB%BA%E9%95%9C%E5%83%8F.png" alt="容器创建镜像.png"></p>
<h3 id="常用命令总结"><a href="#常用命令总结" class="headerlink" title="常用命令总结"></a>常用命令总结</h3><ol>
<li>docker exec -it &lt;容器ID或名字&gt; /bin/bash   进入容器命令，有个交互式 Shell</li>
<li>docker ps -a                查看所有的容器命令</li>
<li>docker stop &lt;容器ID或名字&gt;   停止容器</li>
<li>docker start &lt;容器ID或名字&gt;  启动容器</li>
<li>docker restart &lt;容器ID或名字&gt; 重启容器</li>
<li>docker logs -f &lt;容器ID或名字&gt; 输出容器日志 -f: 让 docker logs 像使用 tail -f 一样来输出容器内部的标准输出。</li>
<li>docker inspect &lt;容器ID或名字&gt; 返回一个 JSON 文件记录着 Docker 容器的配置和状态信息</li>
<li>docker images 查看镜像列表</li>
<li>docker rmi &lt;镜像ID&gt;  删除镜像</li>
<li>docker rm &lt;容器ID或名字&gt;  删除容器</li>
<li>docker pull 镜像名：tags  拉取镜像</li>
<li>docker run … 使用镜像构建容器</li>
<li>docker commit … 使用容器构建镜像</li>
</ol>
<h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><p>我们在上面已经介绍过，Dockerfile可以用来构造镜像，包含了一条条构建镜像所需的指令和说明。</p>
<h3 id="基于Dockerfile构建镜像"><a href="#基于Dockerfile构建镜像" class="headerlink" title="基于Dockerfile构建镜像"></a>基于Dockerfile构建镜像</h3><h4 id="构建nginx的镜像"><a href="#构建nginx的镜像" class="headerlink" title="构建nginx的镜像"></a>构建nginx的镜像</h4><p>我们先构建一个nginx的镜像。然后再介绍Dockerfile语法。<br>新建一个目录： mkdir -p /usr/local/mydockerfile/nginx，我们在这个目录下创建一个nginx的镜像。<br>使用vim 命令新建一个名为 Dockerfile 文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM nginx:latest</span></pre></td></tr><tr><td class="code"><pre><span class="line">RUN echo &#39;这是一个本地构建的nginx镜像&#39; &gt; &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;index.html</span></pre></td></tr></table></figure>
<p>FROM 表示基于nginx:latest 的基础镜像。如果本地没有会使用docker pull 自动下载。<br>RUN 用于执行后面跟着的命令行命令。有以下俩种格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shell 格式：</span></pre></td></tr><tr><td class="code"><pre><span class="line">RUN &lt;命令行命令&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"># &lt;命令行命令&gt; 等同于，在终端操作的 shell 命令。</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">exec 格式：</span></pre></td></tr><tr><td class="code"><pre><span class="line">RUN [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;]</span></pre></td></tr><tr><td class="code"><pre><span class="line"># 例如：</span></pre></td></tr><tr><td class="code"><pre><span class="line"># RUN [&quot;.&#x2F;test.php&quot;, &quot;dev&quot;, &quot;offline&quot;] 等价于 RUN .&#x2F;test.php dev offline</span></pre></td></tr></table></figure>

<p>注意： FROM 、RUN 等指令需要大写。</p>
<p>接下来我们在/usr/local/mydockerfile/nginx目录下执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker build -t nginx:1.1 .</span></pre></td></tr></table></figure>
<p>docker build 命令经常用到-t -f 参数</p>
<p>-t 指定镜像名称及tag<br>-f 指定 Dockerfile文件地址，因为我们是在/usr/local/mydockerfile/nginx目录下执行的，已经包含了Dockerfile 文件，所以上面的命令不需要-f</p>
<p>注意：最后的 . 代表本次执行的上下文路径。上下文路径，是指 docker 在构建镜像，有时候想要使用到本机的文件（比如复制），docker build 命令得知这个路径后，会将路径下的所有内容打包。<br>上下文路径下不要放无用的文件，因为会一起打包发送给 docker 引擎，如果文件过多会造成过程缓慢。</p>
<p>可以看到构建过程及构建好的镜像文件。<br><img src="/images/docker/dockerfile%E6%9E%84%E5%BB%BAnginx%E9%95%9C%E5%83%8F.png" alt="dockerfile构建nginx镜像.png"></p>
<p>我们使用刚才构建好的镜像创建容器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -d -p 82:80 --name nginx82 nginx:1.1</span></pre></td></tr></table></figure>
<p><img src="/images/docker/nginx82.png" alt="nginx82.png">乱码是因为写入容器的/usr/share/nginx/html/index.html 中只包含’这是一个本地构建的nginx镜像’，不是一个正常的html。至此表示我们构建的镜像是可以使用的。</p>
<h3 id="Dockerfile指令详解"><a href="#Dockerfile指令详解" class="headerlink" title="Dockerfile指令详解"></a>Dockerfile指令详解</h3><ol>
<li><p>FROM<br>位于Dockerfile开头，表示基于什么镜像构建</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM nginx:latest</span></pre></td></tr><tr><td class="code"><pre><span class="line">RUN echo &#39;这是一个本地构建的nginx镜像&#39; &gt; &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;index.html</span></pre></td></tr></table></figure>
</li>
<li><p>LABEL<br>Dockerfile的元数据，描述作用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM nginx:latest</span></pre></td></tr><tr><td class="code"><pre><span class="line">LABEL version&#x3D;&quot;1.0&quot; author&#x3D;&quot;garnett&quot; description&#x3D;&quot;nginx port 82&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">RUN echo &#39;这是一个本地构建的nginx镜像&#39; &gt; &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;index.html</span></pre></td></tr></table></figure>
</li>
<li><p>RUN<br>运行命令，每次run都会生成一个图层，所以最好使用 &amp;&amp; 将命令合并</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM nginx:latest</span></pre></td></tr><tr><td class="code"><pre><span class="line">LABEL version&#x3D;&quot;1.0&quot; author&#x3D;&quot;garnett&quot; description&#x3D;&quot;nginx port 82&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">RUN echo &#39;这是一个本地构建的nginx镜像&#39; &gt; &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;index.html</span></pre></td></tr><tr><td class="code"><pre><span class="line">RUN echo &#39;追加。。。&#39; &gt; &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;index.html</span></pre></td></tr></table></figure>

<p>可以修改为：</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM nginx:latest</span></pre></td></tr><tr><td class="code"><pre><span class="line">LABEL version&#x3D;&quot;1.0&quot; author&#x3D;&quot;garnett&quot; description&#x3D;&quot;nginx port 82&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">RUN echo &#39;这是一个本地构建的nginx镜像&#39; &gt; &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;index.html \</span></pre></td></tr><tr><td class="code"><pre><span class="line">&amp;&amp; echo &#39;追加。。。&#39; &gt; &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;index.html</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#96;&#96;&#96;</span></pre></td></tr></table></figure>
<ol start="4">
<li>ADD 和 COPY<br>ADD 和COPY都可以将上下文目录中复制文件或者目录到容器里指定路径。<br>语法：<pre><code>ADD  &lt;源路径1&gt;  &lt;目标路径&gt;
COPY &lt;源路径1&gt;  &lt;目标路径&gt;</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ADD ADD test test&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">COPY ADD test test&#x2F;</span></pre></td></tr></table></figure>
区别：<br>ADD 添加的文件是压缩文件的话，会自动解压。<br>COPY 只能复制构建目录下的文件，ADD可以添加一个构建上下文中的文件或目录，也可以是一个URL，如：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ADD http:&#x2F;&#x2F;wordpress.org&#x2F;latest.zip &#x2F;</span></pre></td></tr></table></figure>

<ol start="5">
<li>CMD<br> 类似于 RUN 指令，用于运行程序，但二者运行的时间点不同:<ul>
<li>CMD 在docker run 时运行。</li>
<li>RUN 是在 docker build。</li>
<li>docker run指定了其他命令，CMD命令会被忽略。</li>
<li>定义了多个CMD，只有最后一个有效。</li>
</ul>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CMD echo &quot;hello docker&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">CMD echo &quot;hello garnett&quot;</span></pre></td></tr></table></figure>
<p>构建镜像并运行docker run<br>输出hello garnett</p>
<p>运行 docker run -it [image] /bin/bash 则没有输出。因为/bin/bash覆盖了CMD 指令。</p>
<ol start="6">
<li>ENTRYPOINT<br> 类似于 CMD 指令，但其不会被 docker run 的命令行参数指定的指令所覆盖<ul>
<li>设置容器启动时运行的命令。</li>
<li>不会被忽略，一定会执行。</li>
<li>一般写一个shell脚本作为ENTRYPOINT。</li>
<li>如果 Dockerfile 中如果存在多个 ENTRYPOINT 指令，仅最后一个生效。</li>
</ul>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM ubuntu</span></pre></td></tr><tr><td class="code"><pre><span class="line">ENTRYPOINT [&quot;&#x2F;bin&#x2F;ls&quot;]</span></pre></td></tr><tr><td class="code"><pre><span class="line">CMD []</span></pre></td></tr></table></figure>

<ol start="7">
<li>ENV<br>环境变量，定义了环境变量，那么在后续的指令中，就可以使用这个环境变量。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ENV MYSQL_VERSION 5.7</span></pre></td></tr><tr><td class="code"><pre><span class="line">RUN apt-get install -y mysql-server&#x3D;&quot;$&#123;MYSQL_VERSION&#125;&quot;</span></pre></td></tr></table></figure>
<ol start="8">
<li>WORKDIR<br>指定工作目录。用 WORKDIR 指定的工作目录，会在构建镜像的每一层中都存在。（WORKDIR 指定的工作目录，必须是提前创建好的）。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM ubuntu</span></pre></td></tr><tr><td class="code"><pre><span class="line">WORKDIR &#x2F;test # 没有则自动创建test目录</span></pre></td></tr><tr><td class="code"><pre><span class="line">WORKDIR demo</span></pre></td></tr><tr><td class="code"><pre><span class="line">RUN pwd</span></pre></td></tr></table></figure>
<p>输出 /test/demo。<br>9. VOLUME<br>定义匿名数据卷。在启动容器时忘记挂载数据卷，会自动挂载到匿名卷。</p>
<ul>
<li>避免重要的数据，因容器重启而丢失，这是非常致命的。</li>
<li>避免容器不断变大。</li>
<li>例如我们用nginx搭建mysql服务，数据文件可以挂到宿主机。以免因容器删除而都是数据</li>
</ul>
<p>格式：<br>VOLUME [“&lt;路径1&gt;”, “&lt;路径2&gt;”…]<br>VOLUME &lt;路径&gt;</p>
<p>在启动容器 docker run 的时候，我们可以通过 -v 参数修改挂载点。</p>
<ol start="10">
<li><p>EXPOSE<br>仅仅只是声明端口。</p>
<ul>
<li>帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射。</li>
<li>在运行时使用随机端口映射时，也就是 docker run -P 时，会自动随机映射 EXPOSE 的端口。<br>格式：<br>EXPOSE &lt;端口1&gt; [&lt;端口2&gt;…]</li>
</ul>
</li>
</ol>
<p>参考链接：<br><a href="https://www.cnblogs.com/baizhanshi/p/9655102.html" target="_blank" rel="noopener">https://www.cnblogs.com/baizhanshi/p/9655102.html</a><br><a href="https://www.runoob.com/docker" target="_blank" rel="noopener">https://www.runoob.com/docker</a></p>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Java8 Lambda表达式</title>
    <url>/2019/12/29/java8-lamada/</url>
    <content><![CDATA[<div class="note info">
            <p> Java 8的Lambda表达式，简化了匿名函数的表达方式。Lambda表达式可以直接以内联的形式为函数式接口的抽象方法提供实现，并把整个表达式作为函数式接口的实例。</p><p>什么是函数式接口？简单来说就是只包含一个抽象方法的接口，允许有默认的实现（使用default关键字描述方法）。函数式接口建议使用@FunctionalInterface注解标注，虽然这不是必须的，但是这样做更符合规范。</p>
          </div>

<p>本节主要记录java8 内置函数式接口的使用。</p>
<h2 id="java8-中常用的函数式接口"><a href="#java8-中常用的函数式接口" class="headerlink" title="java8 中常用的函数式接口"></a>java8 中常用的函数式接口</h2><table>
<thead>
<tr>
<th align="center">函数式接口</th>
<th align="center">函数描述符</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Predicate</td>
<td align="center">T-&gt;boolean</td>
<td align="center">断言：主要作用就是用于判断作用</td>
</tr>
<tr>
<td align="center">Consumer</td>
<td align="center">T-&gt;void</td>
<td align="center">消费者：该函数式接口用于消费一个对象，即接收一个对象，对其执行某些操作，然后没有返回值。</td>
</tr>
<tr>
<td align="center">Supplier</td>
<td align="center">()-&gt;T</td>
<td align="center">供应商：无参数，返回T类型的对象</td>
</tr>
<tr>
<td align="center">Function</td>
<td align="center">T-&gt;R</td>
<td align="center">它接受一个泛型T的对象，并返回一个泛型R的对象</td>
</tr>
</tbody></table>
<h2 id="Predicate-断言"><a href="#Predicate-断言" class="headerlink" title="Predicate 断言"></a>Predicate 断言</h2><p>源码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package java.util.function;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import java.util.Objects;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;**</span></pre></td></tr><tr><td class="code"><pre><span class="line"> * @since 1.8</span></pre></td></tr><tr><td class="code"><pre><span class="line"> *&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">@FunctionalInterface</span></pre></td></tr><tr><td class="code"><pre><span class="line">public interface Predicate&lt;T&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    boolean test(T t);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    default Predicate&lt;T&gt; and(Predicate&lt;? super T&gt; other) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Objects.requireNonNull(other);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        return (t) -&gt; test(t) &amp;&amp; other.test(t);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    default Predicate&lt;T&gt; negate() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        return (t) -&gt; !test(t);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    default Predicate&lt;T&gt; or(Predicate&lt;? super T&gt; other) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Objects.requireNonNull(other);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        return (t) -&gt; test(t) || other.test(t);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    static &lt;T&gt; Predicate&lt;T&gt; isEqual(Object targetRef) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        return (null &#x3D;&#x3D; targetRef)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                ? Objects::isNull</span></pre></td></tr><tr><td class="code"><pre><span class="line">                : object -&gt; targetRef.equals(object);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>java.util.function.Predicate<T>接口定义了一个名叫test的抽象方法，它接受泛型T对象，并返回一个boolean。<br>除了抽象方法外，java.util.function.Predicate<T>接口还定义了三个默认方法：and，negate和or，对应“与”，“非”和“或”操作，这样我们便可以复合Lambda表达式了.</p>
<p>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;**</span></pre></td></tr><tr><td class="code"><pre><span class="line">     * 函数式接口：Predicate</span></pre></td></tr><tr><td class="code"><pre><span class="line">     *&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Predicate&lt;Integer&gt; isEven &#x3D; (i) -&gt; i%2 &#x3D;&#x3D;0 ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F;判断： 是否为偶数</span></pre></td></tr><tr><td class="code"><pre><span class="line">    System.out.println( isEven.test(18) );</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F;判断： 大于10 且 为偶数</span></pre></td></tr><tr><td class="code"><pre><span class="line">    System.out.println( isEven.and((i) -&gt; i&gt;10).test(18) );</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F;判断： 小于10 或 为偶数</span></pre></td></tr><tr><td class="code"><pre><span class="line">    System.out.println( isEven.or((i) -&gt; i&lt;10).test(18) );</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F;判断： 奇数判断</span></pre></td></tr><tr><td class="code"><pre><span class="line">    System.out.println( isEven.negate().test(18) );</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>运行结果为：<br>true<br>true<br>true<br>false</p>
<h2 id="Consumer-消费者，接收参数，无返回值"><a href="#Consumer-消费者，接收参数，无返回值" class="headerlink" title="Consumer 消费者，接收参数，无返回值"></a>Consumer 消费者，接收参数，无返回值</h2><p>源码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package java.util.function;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import java.util.Objects;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">@FunctionalInterface</span></pre></td></tr><tr><td class="code"><pre><span class="line">public interface Consumer&lt;T&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    void accept(T t);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    default Consumer&lt;T&gt; andThen(Consumer&lt;? super T&gt; after) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Objects.requireNonNull(after);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        return (T t) -&gt; &#123; accept(t); after.accept(t); &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>java.util.function.Consumer<T>定义了一个名叫accept的抽象方法，它接受泛型T的对象，没有返回(void)，函数描述符为(T) -&gt; void。<br>其还提供了一个默认方法andThen</p>
<p>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;**</span></pre></td></tr><tr><td class="code"><pre><span class="line">     * 函数式接口：Consumer</span></pre></td></tr><tr><td class="code"><pre><span class="line">     *&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    String str &#x3D; &quot;hello&quot;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Consumer&lt;String&gt; consumer &#x3D; (i) -&gt; System.out.println(i);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F;判断： 输出 &quot;hello&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    consumer.accept(str);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F;判断： 输出&quot;hello&quot; 和 &quot;hello world&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    consumer.andThen((i) -&gt; System.out.println(i+&quot; world&quot;)).accept(str);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h2 id="Supplier-供应商：无参数，返回T类型的对象"><a href="#Supplier-供应商：无参数，返回T类型的对象" class="headerlink" title="Supplier  供应商：无参数，返回T类型的对象"></a>Supplier  供应商：无参数，返回T类型的对象</h2><p>源码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package java.util.function;</span></pre></td></tr><tr><td class="code"><pre><span class="line">@FunctionalInterface</span></pre></td></tr><tr><td class="code"><pre><span class="line">public interface Supplier&lt;T&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    T get();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>java.util.function.Supplier<T>很简单，只定义了一个名叫get的抽象方法，它不接收参数，返回泛型T的对象，函数描述符为() -&gt; T</p>
<p>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;**</span></pre></td></tr><tr><td class="code"><pre><span class="line">     * 函数式接口：Supplier</span></pre></td></tr><tr><td class="code"><pre><span class="line">     *&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Supplier&lt;String&gt; supplier &#x3D; () -&gt; new String(&quot;supplier&quot;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    System.out.println(supplier.get());&#x2F;&#x2F; 返回一个String对象&quot;supplier&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h2 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h2><p>源码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package java.util.function;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import java.util.Objects;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;**</span></pre></td></tr><tr><td class="code"><pre><span class="line"> * @since 1.8</span></pre></td></tr><tr><td class="code"><pre><span class="line"> *&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">@FunctionalInterface</span></pre></td></tr><tr><td class="code"><pre><span class="line">public interface Function&lt;T, R&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    R apply(T t);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    default &lt;V&gt; Function&lt;V, R&gt; compose(Function&lt;? super V, ? extends T&gt; before) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Objects.requireNonNull(before);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        return (V v) -&gt; apply(before.apply(v));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    default &lt;V&gt; Function&lt;T, V&gt; andThen(Function&lt;? super R, ? extends V&gt; after) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Objects.requireNonNull(after);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        return (T t) -&gt; after.apply(apply(t));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    static &lt;T&gt; Function&lt;T, T&gt; identity() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        return t -&gt; t;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>java.util.function.Function&lt;T, R&gt;接口定义了一个叫作apply的方法，它接受一个泛型T的对象，并返回一个泛型R的对象，函数描述符为(T) -&gt; R<br>除了抽象方法外，java.util.function.Function&lt;T, R&gt;接口还定义了三个默认方法：compose，andThen,identity</p>
<p>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;**</span></pre></td></tr><tr><td class="code"><pre><span class="line">     * 函数式接口：Function</span></pre></td></tr><tr><td class="code"><pre><span class="line">     *&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F; 接收一个Integer ,返回一个String</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Function&lt;Integer,String&gt; function &#x3D; (i)-&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        return Integer.toString(i);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F;接收 integer 123 ，返回String &quot;123&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    System.out.println(function.apply(123));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    System.out.println(function.apply(123) instanceof String);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F;compose 过程为：f(g(2))，也就是 (2*2)+1 ,即把g的执行结果当做f的参数</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Function&lt;Integer, Integer&gt; f &#x3D; (x) -&gt; x + 1;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Function&lt;Integer, Integer&gt; g &#x3D; (x) -&gt; x * 2;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    f.compose(g).apply(2); &#x2F;&#x2F; 5</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F;andThen 过程为：g1(f1(2))，也就是(2+1)*2 ，即把f1的执行结果当做g1的参数</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Function&lt;Integer, Integer&gt; f1 &#x3D; (x) -&gt; x + 1;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Function&lt;Integer, Integer&gt; g1 &#x3D; (x) -&gt; x * 2;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    f1.andThen(g1).apply(2); &#x2F;&#x2F; 6</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h2 id="最后附上全部代码"><a href="#最后附上全部代码" class="headerlink" title="最后附上全部代码"></a>最后附上全部代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.sxdx.spring.security.oauth2.controller;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">import java.util.function.Consumer;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import java.util.function.Function;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import java.util.function.Predicate;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import java.util.function.Supplier;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">public class Java8TestController &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    public static void main1(String[] args) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#x2F;**</span></pre></td></tr><tr><td class="code"><pre><span class="line">         * 函数式接口：Predicate</span></pre></td></tr><tr><td class="code"><pre><span class="line">         *&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Predicate&lt;Integer&gt; isEven &#x3D; (i) -&gt; i%2 &#x3D;&#x3D;0 ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#x2F;&#x2F;判断： 是否为偶数</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println( isEven.test(18) );</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#x2F;&#x2F;判断： 大于10 且 为偶数</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println( isEven.and((i) -&gt; i&gt;10).test(18) );</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#x2F;&#x2F;判断： 小于10 或 为偶数</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println( isEven.or((i) -&gt; i&lt;10).test(18) );</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#x2F;&#x2F;判断： 奇数判断</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println( isEven.negate().test(18) );</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public static void main2(String[] args) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#x2F;**</span></pre></td></tr><tr><td class="code"><pre><span class="line">         * 函数式接口：Consumer</span></pre></td></tr><tr><td class="code"><pre><span class="line">         *&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        String str &#x3D; &quot;hello&quot;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Consumer&lt;String&gt; consumer &#x3D; (i) -&gt; System.out.println(i);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#x2F;&#x2F;判断： 输出 &quot;hello&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        consumer.accept(str);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#x2F;&#x2F;判断： 输出&quot;hello&quot; 和 &quot;hello world&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        consumer.andThen((i) -&gt; System.out.println(i+&quot; world&quot;)).accept(str);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    public static void main3(String[] args) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#x2F;**</span></pre></td></tr><tr><td class="code"><pre><span class="line">         * 函数式接口：Supplier</span></pre></td></tr><tr><td class="code"><pre><span class="line">         *&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#x2F;&#x2F; 无参，直接返回一个String字符串</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Supplier&lt;String&gt; supplier &#x3D; () -&gt; new String(&quot;supplier&quot;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(supplier.get());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    public static void main(String[] args) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#x2F;**</span></pre></td></tr><tr><td class="code"><pre><span class="line">         * 函数式接口：Function</span></pre></td></tr><tr><td class="code"><pre><span class="line">         *&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#x2F;&#x2F; 接收一个Integer ,返回一个String</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Function&lt;Integer,String&gt; function &#x3D; (i)-&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            return Integer.toString(i);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#x2F;&#x2F;接收 integer 123 ，返回String &quot;123&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(function.apply(123));</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(function.apply(123) instanceof String);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#x2F;&#x2F;compose 过程为：f(g(2))，也就是 (2*2)+1 ,即把g的执行结果当做f的参数</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Function&lt;Integer, Integer&gt; f &#x3D; (x) -&gt; x + 1;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Function&lt;Integer, Integer&gt; g &#x3D; (x) -&gt; x * 2;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        f.compose(g).apply(2); &#x2F;&#x2F; 5</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#x2F;&#x2F;andThen 过程为：g1(f1(2))，也就是(2+1)*2 ，即把f1的执行结果当做g1的参数</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Function&lt;Integer, Integer&gt; f1 &#x3D; (x) -&gt; x + 1;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Function&lt;Integer, Integer&gt; g1 &#x3D; (x) -&gt; x * 2;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        f1.andThen(g1).apply(2); &#x2F;&#x2F; 6</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>参考文章：<a href="https://mrbird.cc/java8lambda2.html" target="_blank" rel="noopener">https://mrbird.cc/java8lambda2.html</a><br>         <a href="https://www.runoob.com/java/java8-lambda-expressions.html" target="_blank" rel="noopener">https://www.runoob.com/java/java8-lambda-expressions.html</a></p>
]]></content>
      <categories>
        <category>Java8</category>
      </categories>
      <tags>
        <tag>Java8</tag>
      </tags>
  </entry>
  <entry>
    <title>linux（centos7）安装docker</title>
    <url>/2019/12/26/docker-01/</url>
    <content><![CDATA[<div class="note info">
            <p>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中,然后发布到任何流行的Linux机器或Windows 机器上,也可以实现虚拟化,容器是完全使用沙箱机制,相互之间不会有任何接口。</p>
          </div>

<h2 id="检查内核版本"><a href="#检查内核版本" class="headerlink" title="检查内核版本"></a>检查内核版本</h2><blockquote>
<p>centos7 必须是3.10及以上: uname ‐r</p>
</blockquote>
<p><img src="/images/docker/%E7%89%88%E6%9C%AC%E6%A3%80%E6%9F%A5.png" alt="版本检查.png"></p>
<h2 id="安装docker前的准备"><a href="#安装docker前的准备" class="headerlink" title="安装docker前的准备"></a>安装docker前的准备</h2><blockquote>
<p>官网地址：<a href="https://docs.docker.com/install/linux/docker-ce/centos/" target="_blank" rel="noopener">https://docs.docker.com/install/linux/docker-ce/centos/</a></p>
</blockquote>
<h3 id="安装所需的软件包"><a href="#安装所需的软件包" class="headerlink" title="安装所需的软件包"></a>安装所需的软件包</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install -y yum-utils \</span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt;   device-mapper-persistent-data \</span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt;   lvm2</span></pre></td></tr></table></figure>

<p><img src="/images/docker/%E5%AE%89%E8%A3%85%E6%89%80%E9%9C%80%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%8C%85.png" alt="安装所需的软件包.png"></p>
<h3 id="设置存储库"><a href="#设置存储库" class="headerlink" title="设置存储库"></a>设置存储库</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum-config-manager \</span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt;     --add-repo \</span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt;     https:&#x2F;&#x2F;download.docker.com&#x2F;linux&#x2F;centos&#x2F;docker-ce.repo</span></pre></td></tr></table></figure>
<p><img src="/images/docker/%E8%AE%BE%E7%BD%AE%E5%AD%98%E5%82%A8%E5%BA%93.png" alt="设置存储库.png"></p>
<h2 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h2><h3 id="安装最新版本docker"><a href="#安装最新版本docker" class="headerlink" title="安装最新版本docker"></a>安装最新版本docker</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install docker-ce</span></pre></td></tr></table></figure>
<p><img src="/images/docker/%E5%AE%89%E8%A3%85docker.png" alt="安装docker.png"></p>
<h3 id="安装指定版本的docker"><a href="#安装指定版本的docker" class="headerlink" title="安装指定版本的docker"></a>安装指定版本的docker</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install docker-ce-&lt;VERSION_STRING&gt; docker-ce-cli-&lt;VERSION_STRING&gt; containerd.io</span></pre></td></tr></table></figure>
<p>其中<VERSION_STRING>可以通过以下命令查看</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum list docker-ce --showduplicates | sort -r</span></pre></td></tr></table></figure>
<p><img src="/images/docker/%E6%9F%A5%E8%AF%A2docker%E7%89%88%E6%9C%AC.png" alt="查询docker版本.png"></p>
<p>最终命令如下：</p>
<blockquote>
<p>我们以第一个截图第一个为例，以下命令未实践，根据官网说明自己写的，所以没有截图，仅供参考，本人安装的是最新docker</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install docker-ce-19.03.4.ce docker-ce-cli-19.03.4.ce containerd.io</span></pre></td></tr></table></figure>

<h3 id="安装成功确认"><a href="#安装成功确认" class="headerlink" title="安装成功确认"></a>安装成功确认</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker version</span></pre></td></tr></table></figure>
<p><img src="/images/docker/%E7%89%88%E6%9C%AC%E6%9F%A5%E8%AF%A2.png" alt="版本查询.png"></p>
<h3 id="docker启动、关闭"><a href="#docker启动、关闭" class="headerlink" title="docker启动、关闭"></a>docker启动、关闭</h3><p>启动docker</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl start docker</span></pre></td></tr></table></figure>
<p>设置开机启动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl enable docker</span></pre></td></tr></table></figure>
<p><img src="/images/docker/docker%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8.png" alt="docker开机启动.png"></p>
<p>关闭docker</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl stop docker</span></pre></td></tr></table></figure>
<h2 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h2><h3 id="卸载旧版本docker"><a href="#卸载旧版本docker" class="headerlink" title="卸载旧版本docker"></a>卸载旧版本docker</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum remove docker \</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  docker-client \</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  docker-client-latest \</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  docker-common \</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  docker-latest \</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  docker-latest-logrotate \</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  docker-logrotate \</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  docker-engine</span></pre></td></tr></table></figure>
<h3 id="卸载新版本"><a href="#卸载新版本" class="headerlink" title="卸载新版本"></a>卸载新版本</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum remove docker-ce</span></pre></td></tr></table></figure>
<p>删除所有图像，容器和卷</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rm -rf &#x2F;var&#x2F;lib&#x2F;docker</span></pre></td></tr></table></figure>

<h2 id="docker-镜像查看地址：https-hub-docker-com"><a href="#docker-镜像查看地址：https-hub-docker-com" class="headerlink" title="docker 镜像查看地址：https://hub.docker.com"></a>docker 镜像查看地址：<a href="https://hub.docker.com" target="_blank" rel="noopener">https://hub.docker.com</a></h2><p><img src="/images/docker/%E9%95%9C%E5%83%8F%E6%9F%A5%E8%AF%A2.png" alt="镜像查询.png"></p>
<h2 id="安装docker-compose"><a href="#安装docker-compose" class="headerlink" title="安装docker-compose"></a>安装docker-compose</h2><blockquote>
<p>Docker Compose 是一个用来定义和运行复杂应用的 Docker 工具。<br> 使用 Docker Compose 不再需要使用 shell 脚本来启动容器。(通过 docker-compose.yml 配置)</p>
</blockquote>
<h3 id="安装命令"><a href="#安装命令" class="headerlink" title="安装命令"></a>安装命令</h3><p>官网的安装命令太慢，有时无法连接，查阅其他人博客后发现如下安装方式：</p>
<ol>
<li>通过GitHub安装（可以通过修改 URL 中的版本，自定义需要的版本）</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo curl -L https:&#x2F;&#x2F;github.com&#x2F;docker&#x2F;compose&#x2F;releases&#x2F;download&#x2F;1.22.0&#x2F;docker-compose-&#96;uname -s&#96;-&#96;uname -m&#96; -o &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose</span></pre></td></tr><tr><td class="code"><pre><span class="line">sudo chmod +x &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose</span></pre></td></tr></table></figure>

<ol start="2">
<li>通过Daocloud镜像安装（可以通过修改 URL 中的版本，自定义需要的版本）</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -L https:&#x2F;&#x2F;get.daocloud.io&#x2F;docker&#x2F;compose&#x2F;releases&#x2F;download&#x2F;1.22.0&#x2F;docker-compose-&#96;uname -s&#96;-&#96;uname -m&#96; &gt; &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose</span></pre></td></tr><tr><td class="code"><pre><span class="line">chmod +x &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose</span></pre></td></tr></table></figure>

<h3 id="卸载docker-compose"><a href="#卸载docker-compose" class="headerlink" title="卸载docker-compose"></a>卸载docker-compose</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo rm &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose</span></pre></td></tr></table></figure>

<h3 id="docker-compose常用命令"><a href="#docker-compose常用命令" class="headerlink" title="docker-compose常用命令"></a>docker-compose常用命令</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker-compose up -d</span></pre></td></tr></table></figure>

<p>后台启动 docker-compose 中的容器，如果没有容器会根据docker-compose内容创建容器，并启动。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker-compose stop</span></pre></td></tr></table></figure>
<p>停止 docker-compose 中的容器，但不会删除容器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker-compose down</span></pre></td></tr></table></figure>
<p>停止 docker-compose 中的容器并删除容器</p>
<p>参考博客：<a href="https://www.cnblogs.com/morang/p/9501223.html" target="_blank" rel="noopener">https://www.cnblogs.com/morang/p/9501223.html</a></p>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>centos7设置docker阿里云镜像加速器</title>
    <url>/2019/12/26/docker-02/</url>
    <content><![CDATA[<div class="note info">
            <p>国内从 DockerHub 拉取镜像有时会遇到困难，此时可以配置镜像加速器。本节记录如何配置使用阿里云镜像仓库。</p>
          </div>

<h2 id="配置使用阿里云镜像仓库下载镜像"><a href="#配置使用阿里云镜像仓库下载镜像" class="headerlink" title="配置使用阿里云镜像仓库下载镜像"></a>配置使用阿里云镜像仓库下载镜像</h2><h3 id="注册阿里云账号，并登陆"><a href="#注册阿里云账号，并登陆" class="headerlink" title="注册阿里云账号，并登陆"></a>注册阿里云账号，并登陆</h3><p><img src="/images/docker/%E9%98%BF%E9%87%8C%E4%BA%91%E7%99%BB%E5%BD%95.png" alt="阿里云登录.png"></p>
<h3 id="选择容器镜像服务"><a href="#选择容器镜像服务" class="headerlink" title="选择容器镜像服务"></a>选择容器镜像服务</h3><p><img src="/images/docker/%E9%95%9C%E5%83%8F%E6%9C%8D%E5%8A%A1.png" alt="镜像服务.png"></p>
<h3 id="选择如下目录，并将截图命令在centos系统上执行"><a href="#选择如下目录，并将截图命令在centos系统上执行" class="headerlink" title="选择如下目录，并将截图命令在centos系统上执行"></a>选择如下目录，并将截图命令在centos系统上执行</h3><p><img src="/images/docker/%E8%AE%BE%E7%BD%AE%E9%95%9C%E5%83%8F%E5%9C%B0%E5%9D%80.png" alt="设置镜像地址.png"></p>
<h3 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a>下载镜像</h3><p>此时使用 docker pull 命令下载镜像就会默认使用阿里云了。非常快。下载如下Nginx，大概用了不到5秒钟。<br><img src="/images/docker/%E4%B8%8B%E8%BD%BDnginx.png" alt="下载nginx.png"></p>
<h2 id="推送自定义docker镜像到阿里云"><a href="#推送自定义docker镜像到阿里云" class="headerlink" title="推送自定义docker镜像到阿里云"></a>推送自定义docker镜像到阿里云</h2><p>我们在上面设置了阿里云的镜像库，接下来演示如何将自定义的镜像推送到自己的阿里云镜像库中，这样就可以对外提供下载了。</p>
<h3 id="阿里云创建一个命名空间"><a href="#阿里云创建一个命名空间" class="headerlink" title="阿里云创建一个命名空间"></a>阿里云创建一个命名空间</h3><p><img src="/images/docker/%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4.png" alt="命名空间.png"></p>
<h3 id="准备一个可用来打包的容器"><a href="#准备一个可用来打包的容器" class="headerlink" title="准备一个可用来打包的容器"></a>准备一个可用来打包的容器</h3><p>先docker pull 一个Tomcat 镜像，并以此启动一个Tomcat 容器 ,  通过 <a href="http://192.168.230.129:8080/" target="_blank" rel="noopener">http://192.168.230.129:8080/</a> 可以看到Tomcat容器已经启动。<br><img src="/images/docker/tomcat%E5%AE%B9%E5%99%A8.png" alt="tomcat容器.png"></p>
<h3 id="将上一步的-gaoyp-tomcat-容器打包成为一个新的镜像"><a href="#将上一步的-gaoyp-tomcat-容器打包成为一个新的镜像" class="headerlink" title="将上一步的 gaoyp-tomcat 容器打包成为一个新的镜像"></a>将上一步的 gaoyp-tomcat 容器打包成为一个新的镜像</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker commit -m&#x3D;“提交的描述信息” -a&#x3D;“作者” 容器ID 要创建的目标镜像名:[标签名]</span></pre></td></tr></table></figure>
<p>此处定义的镜像为 gaoyp/tomcat ,标签为 v1.0<br><img src="/images/docker/%E5%88%9B%E5%BB%BA%E6%9C%AC%E5%9C%B0%E9%95%9C%E5%83%8F.png" alt="创建本地镜像.png"></p>
<h3 id="创建镜像仓库"><a href="#创建镜像仓库" class="headerlink" title="创建镜像仓库"></a>创建镜像仓库</h3><p><img src="/images/docker/%E5%88%9B%E5%BB%BA%E9%95%9C%E5%83%8F%E4%BB%93%E5%BA%93.png" alt="创建镜像仓库.png"></p>
<p>点击下一步，创建镜像仓库</p>
<p><img src="/images/docker/%E8%87%AA%E5%AE%9A%E4%B9%89tomcat%E9%95%9C%E5%83%8F.png" alt="自定义tomcat镜像.png"></p>
<p>点击管理可以看到镜像信息：<br><img src="/images/docker/%E9%95%9C%E5%83%8F%E4%BF%A1%E6%81%AF.png" alt="镜像信息.png"></p>
<h3 id="推送镜像（参考上图第三步）"><a href="#推送镜像（参考上图第三步）" class="headerlink" title="推送镜像（参考上图第三步）"></a>推送镜像（参考上图第三步）</h3><p><img src="/images/docker/%E6%8E%A8%E9%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E9%95%9C%E5%83%8F.png" alt="推送自定义镜像.png"></p>
<h2 id="拉取自定义镜像"><a href="#拉取自定义镜像" class="headerlink" title="拉取自定义镜像"></a>拉取自定义镜像</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull registry.cn-beijing.aliyuncs.com&#x2F;gaoyipeng&#x2F;gaoyp-tomcat:v1.0</span></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>spring security oauth2 SSO 单点登录及自定义令牌配置</title>
    <url>/2019/12/14/spring-security-oauth2-03/</url>
    <content><![CDATA[<p>上一节 <a href="https://blog.gaoyp.cn/2019/12/10/spring-security-oauth2-02/">spring security oauth2 授权码模式、密码模式代码实践</a> 介绍了spring security oauth2 的3种模式。<br>本节我们将在上一节的基础上实现SSO单点登录，及自定义自定义令牌配置。SSO单点登录的概念就不做解释了，请自行百度。</p>
<h2 id="自定义令牌配置"><a href="#自定义令牌配置" class="headerlink" title="自定义令牌配置"></a>自定义令牌配置</h2><p>上一节我们在认证服务器 spring-security-oauth2 的资源配置类 KikiAuthorizationServerConfigurer 中定义了 ClientDetails：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span></pre></td></tr><tr><td class="code"><pre><span class="line">public void configure(ClientDetailsServiceConfigurer clients) throws Exception &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    clients.inMemory()</span></pre></td></tr><tr><td class="code"><pre><span class="line">            .withClient(&quot;kiki&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            .secret(passwordEncoder.encode(&quot;123456&quot;))</span></pre></td></tr><tr><td class="code"><pre><span class="line">            .authorizedGrantTypes(&quot;password&quot;, &quot;refresh_token&quot;,&quot;authorization_code&quot;,&quot;client_credentials&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            .autoApprove(true)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            .scopes(&quot;all&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            .redirectUris(&quot;http:&#x2F;&#x2F;localhost:8001&#x2F;getCode&quot;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>指定了 client-id为kiki ，client-secret为123456，scopes范围为all,以及redirectUris。并且配置了它支持的认证类型：</p>
<ul>
<li>“authorization_code”：授权码模式</li>
<li>“password”：密码模式</li>
<li>client_credentials:客户端模式</li>
<li>“refresh_token”：刷新token</li>
</ul>
<p>现在我们修改认证服务器 KikiAuthorizationServerConfigurer如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">clients.inMemory()</span></pre></td></tr><tr><td class="code"><pre><span class="line">            .withClient(&quot;kiki&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            .secret(passwordEncoder.encode(&quot;123456&quot;))</span></pre></td></tr><tr><td class="code"><pre><span class="line">            .authorizedGrantTypes(&quot;password&quot;, &quot;refresh_token&quot;,&quot;authorization_code&quot;,&quot;client_credentials&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            .autoApprove(true)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            .scopes(&quot;all&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            .redirectUris(&quot;http:&#x2F;&#x2F;localhost:8001&#x2F;getCode&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            .resourceIds(&quot;kiki-resource&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        .and()</span></pre></td></tr><tr><td class="code"><pre><span class="line">            .withClient(&quot;client1&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            .secret(passwordEncoder.encode(&quot;123456&quot;))</span></pre></td></tr><tr><td class="code"><pre><span class="line">            .authorizedGrantTypes(&quot;authorization_code&quot;, &quot;password&quot;,&quot;refresh_token&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            .autoApprove(true)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            .scopes(&quot;read&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            .redirectUris(&quot;http:&#x2F;&#x2F;localhost:8002&#x2F;one&#x2F;login&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            .resourceIds(&quot;client1-resource&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        .and()</span></pre></td></tr><tr><td class="code"><pre><span class="line">            .withClient(&quot;client2&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            .secret(passwordEncoder.encode(&quot;123456&quot;))</span></pre></td></tr><tr><td class="code"><pre><span class="line">            .authorizedGrantTypes(&quot;authorization_code&quot;,&quot;password&quot;, &quot;refresh_token&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            .autoApprove(true)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            .scopes(&quot;read&quot;,&quot;write&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            .redirectUris(&quot;http:&#x2F;&#x2F;localhost:8003&#x2F;two&#x2F;login&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            .resourceIds(&quot;client2-resource&quot;);</span></pre></td></tr></table></figure>

<p>可以看到，我们新增了2个 Client，分别为client1，client2.并指定它们的认证类型为：”authorization_code”,”password”, “refresh_token”。</p>
<ul>
<li>autoApprove(true)：表示在授权码模式中，用户无需进入授权页面手动点击授权按钮（Authorize）,直接返回code。</li>
<li>scopes：指定了Client所能访问的范围。client1可以访问带有@PreAuthorize(“#oauth2.hasScope(‘read’)”)的资源，client2可以访问带有@PreAuthorize(“#oauth2.hasScope(‘read’)”)和<br>@PreAuthorize(“#oauth2.hasScope(‘write’)”)的资源。如果没有@PreAuthorize，则都可以访问。</li>
<li>redirectUris：配置了重定向URL，否则授权码模式输入用户名密码后会报错：error=”invalid_request”, error_description=”At least one redirect_uri must be registered with the client.”</li>
<li>resourceIds：指定了Client 所能访问的资源ID。client1可以访问带有resourceId为client1-resource的资源，client2可以访问带有resourceId为client2-resource的资源，</li>
</ul>
<p>对于scopes和resourceIds不熟悉的，可以参考 <a href="https://blog.gaoyp.cn/2019/12/08/spring-security-oauth2-01/">https://blog.gaoyp.cn/2019/12/08/spring-security-oauth2-01/</a></p>
<h2 id="新建2个资源服务器"><a href="#新建2个资源服务器" class="headerlink" title="新建2个资源服务器"></a>新建2个资源服务器</h2><p>为了实现功能，我们需要新建2个资源服务器。现约定如下（于认证服务器的clients配置相对应）：</p>
<table>
<thead>
<tr>
<th align="center">系统名称</th>
<th align="center">端口</th>
<th align="center">client-id</th>
<th align="center">client-secret</th>
</tr>
</thead>
<tbody><tr>
<td align="center">sso-resource-one</td>
<td align="center">8002</td>
<td align="center">client1</td>
<td align="center">123456</td>
</tr>
<tr>
<td align="center">sso-resource-two</td>
<td align="center">8003</td>
<td align="center">client2</td>
<td align="center">123456</td>
</tr>
</tbody></table>
<h3 id="新建资源服务器sso-resource-one："><a href="#新建资源服务器sso-resource-one：" class="headerlink" title="新建资源服务器sso-resource-one："></a>新建资源服务器sso-resource-one：</h3><p>新建一个module，pom.xml如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 https:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;parent&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;groupId&gt;com.sxdx&lt;&#x2F;groupId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;artifactId&gt;spring-all&lt;&#x2F;artifactId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;relativePath&gt;..&#x2F;spring-all&#x2F;pom.xml&lt;&#x2F;relativePath&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;&#x2F;parent&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;groupId&gt;com.sxdx&lt;&#x2F;groupId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;artifactId&gt;sso-resource-one&lt;&#x2F;artifactId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;name&gt;sso-resource-one&lt;&#x2F;name&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;description&gt;资源服务器和sso客户端&lt;&#x2F;description&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;properties&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;java.version&gt;1.8&lt;&#x2F;java.version&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;&#x2F;properties&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;dependencies&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;&#x2F;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;&#x2F;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &lt;artifactId&gt;spring-cloud-starter&lt;&#x2F;artifactId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;&#x2F;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &lt;artifactId&gt;spring-cloud-starter-oauth2&lt;&#x2F;artifactId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;&#x2F;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &lt;artifactId&gt;spring-cloud-starter-security&lt;&#x2F;artifactId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;&#x2F;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &lt;groupId&gt;org.apache.commons&lt;&#x2F;groupId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &lt;artifactId&gt;commons-lang3&lt;&#x2F;artifactId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;&#x2F;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &lt;artifactId&gt;spring-boot-starter-actuator&lt;&#x2F;artifactId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;&#x2F;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &lt;scope&gt;test&lt;&#x2F;scope&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;&#x2F;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;&#x2F;dependencies&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;build&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;plugins&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &lt;plugin&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &lt;&#x2F;plugin&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;&#x2F;plugins&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;&#x2F;build&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;&#x2F;project&gt;</span></pre></td></tr></table></figure>

<p>再贴出sso-resource-one的application.yaml：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  port: 8002</span></pre></td></tr><tr><td class="code"><pre><span class="line">  servlet:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    context-path: &#x2F;one</span></pre></td></tr><tr><td class="code"><pre><span class="line">    session:</span></pre></td></tr><tr><td class="code"><pre><span class="line">      cookie:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        name: ONESESSION</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">security:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  oauth2:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    client:</span></pre></td></tr><tr><td class="code"><pre><span class="line">      client-id: client1 #指定了客户端id</span></pre></td></tr><tr><td class="code"><pre><span class="line">      client-secret: 123456 # 指定了客户端密码</span></pre></td></tr><tr><td class="code"><pre><span class="line">      user-authorization-uri: http:&#x2F;&#x2F;127.0.0.1:8001&#x2F;oauth&#x2F;authorize #指定为认证服务器的&#x2F;oauth&#x2F;authorize地址</span></pre></td></tr><tr><td class="code"><pre><span class="line">      access-token-uri: http:&#x2F;&#x2F;127.0.0.1:8001&#x2F;oauth&#x2F;token # 指定认证服务器的&#x2F;oauth&#x2F;token地址</span></pre></td></tr><tr><td class="code"><pre><span class="line">    resource:</span></pre></td></tr><tr><td class="code"><pre><span class="line">      token-info-uri: http:&#x2F;&#x2F;127.0.0.1:8001&#x2F;oauth&#x2F;check_token #sso客户端token验证，资源服务器就是通过这个向认证服务器校验token是否有效，是否可以访问本resource资源</span></pre></td></tr><tr><td class="code"><pre><span class="line">      user-info-uri: http:&#x2F;&#x2F;127.0.0.1:8001&#x2F;authentication #sso客户端获取当前用户信息</span></pre></td></tr></table></figure>

<h4 id="添加-EnableOAuth2Sso"><a href="#添加-EnableOAuth2Sso" class="headerlink" title="添加@EnableOAuth2Sso"></a>添加@EnableOAuth2Sso</h4><p>在启动类上添加@EnableOAuth2Sso，表面这是一个SSO客户端，开启SSO的支持。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.sxdx.sso.resource.one;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.boot.SpringApplication;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.boot.autoconfigure.SpringBootApplication;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.boot.autoconfigure.security.oauth2.client.EnableOAuth2Sso;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">@EnableOAuth2Sso</span></pre></td></tr><tr><td class="code"><pre><span class="line">@SpringBootApplication</span></pre></td></tr><tr><td class="code"><pre><span class="line">public class SsoResourceOneApplication &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public static void main(String[] args) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        SpringApplication.run(SsoResourceOneApplication.class, args);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h4 id="新建WebSecurity配置类"><a href="#新建WebSecurity配置类" class="headerlink" title="新建WebSecurity配置类"></a>新建WebSecurity配置类</h4><p>新建config包，在新建config包下新建WebSecurityConfigurer类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.sxdx.sso.resource.one.config;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.context.annotation.Configuration;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.core.annotation.Order;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.security.config.annotation.method.configuration.EnableGlobalMethodSecurity;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.security.config.annotation.web.builders.HttpSecurity;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">@Order(101)</span></pre></td></tr><tr><td class="code"><pre><span class="line">@Configuration</span></pre></td></tr><tr><td class="code"><pre><span class="line">@EnableGlobalMethodSecurity(prePostEnabled &#x3D; true)</span></pre></td></tr><tr><td class="code"><pre><span class="line">public class WebSecurityConfigurer extends WebSecurityConfigurerAdapter &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Override</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public void configure(HttpSecurity http) throws Exception &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        http.requestMatchers()</span></pre></td></tr><tr><td class="code"><pre><span class="line">                .antMatchers(&quot;&#x2F;**&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                .and()</span></pre></td></tr><tr><td class="code"><pre><span class="line">                .authorizeRequests()</span></pre></td></tr><tr><td class="code"><pre><span class="line">                .antMatchers(&quot;&#x2F;**&quot;).authenticated()</span></pre></td></tr><tr><td class="code"><pre><span class="line">                .and()</span></pre></td></tr><tr><td class="code"><pre><span class="line">                .csrf().disable()</span></pre></td></tr><tr><td class="code"><pre><span class="line">                .formLogin().permitAll();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<ul>
<li>设置了资源服务的WebSecurity配置，所有请求均需要认证后才可访问。此处配置了 @Order(101)，否则会报错</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Caused by: java.lang.IllegalStateException: @Order on WebSecurityConfigurers must be unique. Order of 100 was already used on com.sxdx.sso.resource.one.config.WebSecurityConfigurer$$EnhancerBySpringCGLIB$$2b177f7a@48bc2fce, so it cannot be used on org.springframework.boot.autoconfigure.security.oauth2.client.OAuth2SsoDefaultConfiguration$$EnhancerBySpringCGLIB$$ff13e17c@1eca3ea7 too.</span></pre></td></tr><tr><td class="code"><pre><span class="line">	at org.springframework.security.config.annotation.web.configuration.WebSecurityConfiguration.setFilterChainProxySecurityConfigurer(WebSecurityConfiguration.java:148) ~[spring-security-config-5.1.5.RELEASE.jar:5.1.5.RELEASE]</span></pre></td></tr><tr><td class="code"><pre><span class="line">	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.8.0_171]</span></pre></td></tr><tr><td class="code"><pre><span class="line">	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:1.8.0_171]</span></pre></td></tr><tr><td class="code"><pre><span class="line">	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.8.0_171]</span></pre></td></tr><tr><td class="code"><pre><span class="line">	at java.lang.reflect.Method.invoke(Method.java:498) ~[na:1.8.0_171]</span></pre></td></tr><tr><td class="code"><pre><span class="line">	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredMethodElement.inject(AutowiredAnnotationBeanPostProcessor.java:708) ~[spring-beans-5.1.8.RELEASE.jar:5.1.8.RELEASE]</span></pre></td></tr><tr><td class="code"><pre><span class="line">	at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:90) ~[spring-beans-5.1.8.RELEASE.jar:5.1.8.RELEASE]</span></pre></td></tr><tr><td class="code"><pre><span class="line">	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessProperties(AutowiredAnnotationBeanPostProcessor.java:374) ~[spring-beans-5.1.8.RELEASE.jar:5.1.8.RELEASE]</span></pre></td></tr><tr><td class="code"><pre><span class="line">	... 17 common frames omitted</span></pre></td></tr></table></figure>
<p>这是因为认证服务器的WebSecurityConfigurers已经默认使用了@Order(100)，其实我们在认证服务器中已经改为 @Order(2)，但这里还是不能使用 @Order(100)。具体原因不明。反正改为@Order(101)就好了。</p>
<ul>
<li>@EnableGlobalMethodSecurity(prePostEnabled = true)，开启权限注解，否则无法使用@PreAuthorize。</li>
</ul>
<h4 id="新建ResourceServerConfig资源配置类"><a href="#新建ResourceServerConfig资源配置类" class="headerlink" title="新建ResourceServerConfig资源配置类"></a>新建ResourceServerConfig资源配置类</h4><p>在config包下，新建ResourceServerConfig：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.sxdx.sso.resource.one.config;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.context.annotation.Configuration;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.core.annotation.Order;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.security.config.annotation.web.builders.HttpSecurity;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.security.oauth2.config.annotation.web.configuration.EnableResourceServer;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.security.oauth2.config.annotation.web.configuration.ResourceServerConfigurerAdapter;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.security.oauth2.config.annotation.web.configurers.ResourceServerSecurityConfigurer;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">@Configuration</span></pre></td></tr><tr><td class="code"><pre><span class="line">@EnableResourceServer</span></pre></td></tr><tr><td class="code"><pre><span class="line">public class ResourceServerConfig extends ResourceServerConfigurerAdapter&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Override</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public void configure(ResourceServerSecurityConfigurer resources) throws Exception &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        resources.resourceId(&quot;client1-resource&quot;).stateless(true); &#x2F;&#x2F;重点，设置资源id</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    public void configure(HttpSecurity http) throws Exception &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        http.requestMatchers().antMatchers(&quot;&#x2F;**&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                .and()</span></pre></td></tr><tr><td class="code"><pre><span class="line">                .authorizeRequests()</span></pre></td></tr><tr><td class="code"><pre><span class="line">                .anyRequest().authenticated()</span></pre></td></tr><tr><td class="code"><pre><span class="line">                .antMatchers(&quot;&#x2F;login&#x2F;**&quot;).permitAll();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<ul>
<li>@EnableResourceServer 开启资源服务器配置</li>
<li>定义了本服务的resourceId为client1-resource</li>
<li>定义了资源访问规则。</li>
</ul>
<h4 id="新建测试类"><a href="#新建测试类" class="headerlink" title="新建测试类"></a>新建测试类</h4><p>新建OneController：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.sxdx.sso.resource.one.controller;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.security.access.prepost.PreAuthorize;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.web.bind.annotation.GetMapping;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.web.bind.annotation.RestController;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import java.security.Principal;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import java.util.HashMap;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import java.util.Map;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">@RestController</span></pre></td></tr><tr><td class="code"><pre><span class="line">public class OneController &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    @PreAuthorize(&quot;#oauth2.hasScope(&#39;write&#39;)&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    @GetMapping(&quot;&#x2F;index&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public Map&lt;String,String&gt; index()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Map&lt;String,String&gt; mp &#x3D; new HashMap&lt;&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        mp.put(&quot;key&quot;,&quot;&#x2F;index&quot;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        return mp;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    @PreAuthorize(&quot;hasAuthority(&#39;user:add&#39;) and #oauth2.hasScope(&#39;read&#39;)&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    @GetMapping(&quot;&#x2F;user&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public Principal user(Principal principal) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        return principal;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<ul>
<li>@PreAuthorize(“#oauth2.hasScope(‘read’)”):只有scope包含read才有权访问。</li>
<li>@PreAuthorize(“hasAuthority(‘user:add’) and #oauth2.hasScope(‘read’)”):只有scope包含read，并且用户角色为 user:add 才有权访问。<br>认证服务器中KikiUserDetailService定义了所有登录用户，均有user:add权限</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span></pre></td></tr><tr><td class="code"><pre><span class="line">   public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       KikiSecurityUser user &#x3D; new KikiSecurityUser();</span></pre></td></tr><tr><td class="code"><pre><span class="line">       user.setUsername(username);</span></pre></td></tr><tr><td class="code"><pre><span class="line">       user.setPassword(this.passwordEncoder.encode(&quot;123456&quot;));</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">       return new User(username, user.getPassword(), user.isEnabled(),</span></pre></td></tr><tr><td class="code"><pre><span class="line">               user.isAccountNonExpired(), user.isCredentialsNonExpired(),</span></pre></td></tr><tr><td class="code"><pre><span class="line">               user.isAccountNonLocked(), AuthorityUtils.commaSeparatedStringToAuthorityList(&quot;user:add&quot;));</span></pre></td></tr><tr><td class="code"><pre><span class="line">   &#125;</span></pre></td></tr></table></figure>

<p>至此资源服务器sso-resource-one搭建完成</p>
<h3 id="新建资源服务器module：sso-resource-two"><a href="#新建资源服务器module：sso-resource-two" class="headerlink" title="新建资源服务器module：sso-resource-two"></a>新建资源服务器module：sso-resource-two</h3><p>仿照sso-resource-one,新建sso-resource-two即可。不再贴出代码。</p>
<h2 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h2><h3 id="resourceIds-作用演示"><a href="#resourceIds-作用演示" class="headerlink" title="resourceIds 作用演示"></a>resourceIds 作用演示</h3><p>查询 <a href="http://127.0.0.1:8002/one/user。" target="_blank" rel="noopener">http://127.0.0.1:8002/one/user。</a></p>
<p><img src="/images/oauth2/%E8%8E%B7%E5%8F%96client1%E7%9A%84%E8%B5%84%E6%BA%90.png" alt="获取client1的资源.png"></p>
<p>我们通过postman 密码模式获取token</p>
<p><img src="/images/oauth2/%E8%8E%B7%E5%8F%96client1%E7%9A%84token.png" alt="获取client1的token.png"></p>
<p>点击Send访问，记着添加请求头（client1:123456 base64编码）：</p>
<p><img src="/images/oauth2/client1%E7%9A%84%E8%B5%84%E6%BA%90.png" alt="client1的资源.png"></p>
<p>可以看到可以获取到对应资源。因为client1对应的resourceID为client1-resource。而 <a href="http://127.0.0.1:8002/one/user" target="_blank" rel="noopener">http://127.0.0.1:8002/one/user</a> 就是属于client1-resource的资源。</p>
<p>现在我们再次获取请求资源，不同的是把URl 改为 <a href="http://127.0.0.1:8003/two/user" target="_blank" rel="noopener">http://127.0.0.1:8003/two/user</a> 。来验证client1是否可以获取client2-resource的资源。<br>返回结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &quot;error&quot;: &quot;access_denied&quot;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &quot;error_description&quot;: &quot;Invalid token does not contain resource id (client2-resource)&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>无权访问client2-resource。我们修改client1的resourceIds，并重启服务。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.and()</span></pre></td></tr><tr><td class="code"><pre><span class="line">.withClient(&quot;client1&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">.secret(passwordEncoder.encode(&quot;123456&quot;))</span></pre></td></tr><tr><td class="code"><pre><span class="line">.authorizedGrantTypes(&quot;authorization_code&quot;,&quot;password&quot;, &quot;refresh_token&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">.autoApprove(true)</span></pre></td></tr><tr><td class="code"><pre><span class="line">.scopes(&quot;read&quot;,&quot;write&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">.redirectUris(&quot;http:&#x2F;&#x2F;localhost:8003&#x2F;two&#x2F;login&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">.resourceIds(&quot;client2-resource&quot;,&quot;client1-resource&quot;)</span></pre></td></tr></table></figure>
<p> resourceIds(“client2-resource”,”client1-resource”)表示client1可以访问sso-resource-one和sso-resource-two的资源。</p>
<p> 访问<a href="http://127.0.0.1:8002/one/user" target="_blank" rel="noopener">http://127.0.0.1:8002/one/user</a> ，发现可以获取资源。修改URL为<a href="http://127.0.0.1:8003/two/user.也可以获取到资源。" target="_blank" rel="noopener">http://127.0.0.1:8003/two/user.也可以获取到资源。</a></p>
<h3 id="scopes-作用演示"><a href="#scopes-作用演示" class="headerlink" title="scopes 作用演示"></a>scopes 作用演示</h3><p>再次修改URL为<a href="http://127.0.0.1:8002/one/index" target="_blank" rel="noopener">http://127.0.0.1:8002/one/index</a>,<br>返回：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &quot;error&quot;: &quot;access_denied&quot;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &quot;error_description&quot;: &quot;不允许访问&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>因为client1 的scope为read,而/one/index 需要 write.</p>
<h3 id="SSO-单点登录"><a href="#SSO-单点登录" class="headerlink" title="SSO 单点登录"></a>SSO 单点登录</h3><p>其实上面的演示过程已经实现了单点登录，我们通过token可以同时获取到sso-resource-one和sso-resource-two的资源,不过这个只适合密码模式。<br>浏览器直接访问 <a href="http://127.0.0.1:8002/one/user" target="_blank" rel="noopener">http://127.0.0.1:8002/one/user</a> 会报Full authentication is required to access this resource。</p>
<p>现在我们把sso-resource-one和sso-resource-two的 ResourceServerConfig类的 @EnableResourceServer注解去掉。<br>浏览器访问 <a href="http://127.0.0.1:8002/one/user,浏览器会重定向到" target="_blank" rel="noopener">http://127.0.0.1:8002/one/user,浏览器会重定向到</a> <a href="http://127.0.0.1:8001/login" target="_blank" rel="noopener">http://127.0.0.1:8001/login</a>:</p>
<p><img src="/images/oauth2/SSO%E7%99%BB%E5%BD%95.png" alt="SSO登录.png"> </p>
<p>输入garnett 123456 点击 “Sign in”</p>
<p><img src="/images/oauth2/SSO-client1.png" alt="SSO-client1.png"> </p>
<p>可以看到浏览器返回了<a href="http://127.0.0.1:8002/one/user对应的资源。接下来我们新开一个页面访问" target="_blank" rel="noopener">http://127.0.0.1:8002/one/user对应的资源。接下来我们新开一个页面访问</a> <a href="http://127.0.0.1:8003/two/user" target="_blank" rel="noopener">http://127.0.0.1:8003/two/user</a></p>
<p><img src="/images/oauth2/%E8%AE%BF%E9%97%AEsso-client2.png" alt="访问sso-client2.png"> </p>
<p><img src="/images/oauth2/sso-client2.png" alt="sso-client2.png"> </p>
<p>我们发现，我没要求输入用户名密码，即可获取到对应资源。</p>
<p>我们再访问 <a href="http://127.0.0.1:8002/one/index，会报403异常,不是很理解。发现将client1的" target="_blank" rel="noopener">http://127.0.0.1:8002/one/index，会报403异常,不是很理解。发现将client1的</a> scopes改为 (“read”,”write”)后就可以访问了。<br>哪位知道为啥还请不吝赐教！</p>
<p><img src="/images/oauth2/sso-403.png" alt="sso-403.png"> </p>
<p>访问 <a href="http://127.0.0.1:8003/two/index" target="_blank" rel="noopener">http://127.0.0.1:8003/two/index</a> ，返回结果： {“key”:”/index”}</p>
<p>参考：<br><a href="https://mrbird.cc/Spring-Security-OAuth2-SSO.html" target="_blank" rel="noopener">https://mrbird.cc/Spring-Security-OAuth2-SSO.html</a><br><a href="http://www.it1352.com/983633.html" target="_blank" rel="noopener">http://www.it1352.com/983633.html</a></p>
<hr>
<p>学然后知不足,教然后知困。知不足,然后能自反也;知困,然后能自强也。</p>
]]></content>
      <categories>
        <category>OAuth2</category>
        <category>Spring-Security</category>
      </categories>
      <tags>
        <tag>OAuth2</tag>
        <tag>Spring-Security</tag>
      </tags>
  </entry>
  <entry>
    <title>spring security oauth2 授权码模式、密码模式代码实践</title>
    <url>/2019/12/10/spring-security-oauth2-02/</url>
    <content><![CDATA[<p>上一节 <a href="https://blog.gaoyp.cn/2019/12/08/spring-security-oauth2-01/">spring security oauth2 基础知识</a> 介绍了spring security oauth2 基础知识.</p>
<p>本节实例代码演示,为了之后有一个可供代码实践的环境，本次搭建一个名为 spring-all 的聚合工程，今后不特殊说明，均在此项目下进行演示。</p>
<blockquote>
<p>环境说明：IDEA2019.2 、jdk 1.8 、maven 3.6.2 </p>
</blockquote>
<h2 id="搭建-spring-all"><a href="#搭建-spring-all" class="headerlink" title="搭建 spring-all"></a>搭建 spring-all</h2><h3 id="创建父级-maven项目：-spring-all"><a href="#创建父级-maven项目：-spring-all" class="headerlink" title="创建父级 maven项目： spring-all"></a>创建父级 maven项目： spring-all</h3><p><img src="/images/oauth2/%E5%88%9B%E5%BB%BAspring-all.png" alt="创建spring-all"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   &lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   </span></pre></td></tr><tr><td class="code"><pre><span class="line">       &lt;groupId&gt;com.sxdx&lt;&#x2F;groupId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       &lt;artifactId&gt;spring-all&lt;&#x2F;artifactId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       &lt;packaging&gt;pom&lt;&#x2F;packaging&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   </span></pre></td></tr><tr><td class="code"><pre><span class="line">       &lt;modules&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">           &lt;module&gt;..&#x2F;spring-security-oauth2&lt;&#x2F;module&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       &lt;&#x2F;modules&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   </span></pre></td></tr><tr><td class="code"><pre><span class="line">       &lt;parent&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">           &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">           &lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">           &lt;version&gt;2.1.6.RELEASE&lt;&#x2F;version&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">           &lt;relativePath&#x2F;&gt; &lt;!-- lookup parent from repository --&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       &lt;&#x2F;parent&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   </span></pre></td></tr><tr><td class="code"><pre><span class="line">       &lt;properties&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">           &lt;spring-cloud.version&gt;Greenwich.SR1&lt;&#x2F;spring-cloud.version&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       &lt;&#x2F;properties&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   </span></pre></td></tr><tr><td class="code"><pre><span class="line">       &lt;dependencyManagement&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">           &lt;dependencies&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">               &lt;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                   &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                   &lt;artifactId&gt;spring-cloud-dependencies&lt;&#x2F;artifactId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                   &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;&#x2F;version&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                   &lt;type&gt;pom&lt;&#x2F;type&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                   &lt;scope&gt;import&lt;&#x2F;scope&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">               &lt;&#x2F;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">           &lt;&#x2F;dependencies&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       &lt;&#x2F;dependencyManagement&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   &lt;&#x2F;project&gt;</span></pre></td></tr></table></figure>

<blockquote>
<p>指定 packaging为pom，表示这是一个纯聚合模块，无需打包为jar或者war。指定spring-boot版本：2.1.6.RELEASE，spring-cloud版本：Greenwich.SR1</p>
</blockquote>
<p>它们的对应关系：</p>
<table>
<thead>
<tr>
<th align="center">spring boot</th>
<th align="center">spring cloud</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Hoxton</td>
<td align="center">2.2.x</td>
</tr>
<tr>
<td align="center">Greenwich</td>
<td align="center">2.1.x</td>
</tr>
<tr>
<td align="center">Finchley</td>
<td align="center">2.0.x</td>
</tr>
<tr>
<td align="center">Edgware</td>
<td align="center">1.5.x</td>
</tr>
<tr>
<td align="center">Dalston</td>
<td align="center">1.5.x</td>
</tr>
</tbody></table>
<h3 id="创建一个-module项目：-spring-security-oauth2"><a href="#创建一个-module项目：-spring-security-oauth2" class="headerlink" title="创建一个 module项目： spring-security-oauth2"></a>创建一个 module项目： spring-security-oauth2</h3><p><img src="/images/oauth2/%E5%88%9B%E5%BB%BAsecurity-oauth2.png" alt="创建security-oauth2.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 https:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;parent&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;groupId&gt;com.sxdx&lt;&#x2F;groupId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;artifactId&gt;spring-all&lt;&#x2F;artifactId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;relativePath&gt;..&#x2F;spring-all&#x2F;pom.xml&lt;&#x2F;relativePath&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;&#x2F;parent&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;groupId&gt;com.sxdx&lt;&#x2F;groupId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;artifactId&gt;spring-security-oauth2&lt;&#x2F;artifactId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;name&gt;spring-security-oauth2&lt;&#x2F;name&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;description&gt;spring-security-oauth2 Demo&lt;&#x2F;description&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;properties&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;java.version&gt;1.8&lt;&#x2F;java.version&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;&#x2F;properties&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;dependencies&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">         &lt;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;&#x2F;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;&#x2F;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &lt;artifactId&gt;spring-cloud-starter&lt;&#x2F;artifactId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;&#x2F;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &lt;artifactId&gt;spring-cloud-starter-oauth2&lt;&#x2F;artifactId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;&#x2F;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &lt;artifactId&gt;spring-cloud-starter-security&lt;&#x2F;artifactId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;&#x2F;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &lt;groupId&gt;org.apache.commons&lt;&#x2F;groupId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &lt;artifactId&gt;commons-lang3&lt;&#x2F;artifactId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;&#x2F;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &lt;scope&gt;test&lt;&#x2F;scope&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;&#x2F;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;&#x2F;dependencies&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;build&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;plugins&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &lt;plugin&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &lt;&#x2F;plugin&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;&#x2F;plugins&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;&#x2F;build&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;&#x2F;project&gt;</span></pre></td></tr></table></figure>

<blockquote>
<p>lombok说明：因为项目里使用了Lombok注解,除引用lombok jar包外，我们还需要在IDEA里安装Lombok插件。<a href="https://www.cnblogs.com/pcheng/p/10945476.html" target="_blank" rel="noopener">https://www.cnblogs.com/pcheng/p/10945476.html</a></p>
</blockquote>
<h3 id="授权码模式（authorization-code）"><a href="#授权码模式（authorization-code）" class="headerlink" title="授权码模式（authorization code）"></a>授权码模式（authorization code）</h3><h4 id="创建一个实体类"><a href="#创建一个实体类" class="headerlink" title="创建一个实体类"></a>创建一个实体类</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.sxdx.spring.security.oauth2.entity;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">import lombok.Data;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.security.core.GrantedAuthority;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import java.io.Serializable;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import java.util.Set;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">@Data</span></pre></td></tr><tr><td class="code"><pre><span class="line">public class KikiSecurityUser implements Serializable &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    private static final long serialVersionUID &#x3D; 3191927289420949930L;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    private String password;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    private String username;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    private Set&lt;GrantedAuthority&gt; authorities;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    private boolean accountNonExpired &#x3D; true;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    private boolean accountNonLocked &#x3D; true;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    private boolean credentialsNonExpired &#x3D; true;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    private boolean enabled &#x3D; true;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h4 id="创建用户名密码校验类"><a href="#创建用户名密码校验类" class="headerlink" title="创建用户名密码校验类"></a>创建用户名密码校验类</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.sxdx.spring.security.oauth2.service;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">import com.sxdx.spring.security.oauth2.entity.KikiSecurityUser;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.security.core.authority.AuthorityUtils;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.security.core.userdetails.User;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.security.core.userdetails.UserDetails;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.security.core.userdetails.UserDetailsService;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.security.core.userdetails.UsernameNotFoundException;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.security.crypto.password.PasswordEncoder;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.stereotype.Service;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;**</span></pre></td></tr><tr><td class="code"><pre><span class="line"> * 校验用户名密码</span></pre></td></tr><tr><td class="code"><pre><span class="line"> *&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">@Service</span></pre></td></tr><tr><td class="code"><pre><span class="line">public class KikiUserDetailService implements UserDetailsService &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Autowired</span></pre></td></tr><tr><td class="code"><pre><span class="line">    private PasswordEncoder passwordEncoder;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Override</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        KikiSecurityUser user &#x3D; new KikiSecurityUser();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        user.setUsername(username);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        user.setPassword(this.passwordEncoder.encode(&quot;123456&quot;));</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        return new User(username, user.getPassword(), user.isEnabled(),</span></pre></td></tr><tr><td class="code"><pre><span class="line">                user.isAccountNonExpired(), user.isCredentialsNonExpired(),</span></pre></td></tr><tr><td class="code"><pre><span class="line">                user.isAccountNonLocked(), AuthorityUtils.commaSeparatedStringToAuthorityList(&quot;user:add&quot;));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>KikiUserDetailService实现了UserDetailsService接口的loadUserByUsername方法。定义登录逻辑：用户名任意，密码为123456 即可通过spring-security登录。loadUserByUsername方法返回一个UserDetails对象，该对象也是一个接口，<br>包含一些用于描述用户信息的方法，源码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface UserDetails extends Serializable &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Collection&lt;? extends GrantedAuthority&gt; getAuthorities();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    String getPassword();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    String getUsername();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    boolean isAccountNonExpired();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    boolean isAccountNonLocked();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    boolean isCredentialsNonExpired();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    boolean isEnabled();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>这些字段的含义如下：</p>
<ul>
<li>getAuthorities获取用户包含的权限，返回权限集合，权限是一个继承了GrantedAuthority的对象；</li>
<li>getPassword和getUsername用于获取密码和用户名；</li>
<li>isAccountNonExpired方法返回boolean类型，用于判断账户是否未过期，未过期返回true反之返回false；</li>
<li>isAccountNonLocked方法用于判断账户是否未锁定；</li>
<li>isCredentialsNonExpired用于判断用户凭证是否没过期，即密码是否未过期；</li>
<li>isEnabled方法用于判断用户是否可用。</li>
</ul>
<h4 id="创建一个通用返回类"><a href="#创建一个通用返回类" class="headerlink" title="创建一个通用返回类"></a>创建一个通用返回类</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.sxdx.spring.security.oauth2.entity;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">import java.io.Serializable;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import java.util.HashMap;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">public class KikiResponse extends HashMap&lt;String, Object&gt; implements Serializable &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    private static final long serialVersionUID &#x3D; 967397361339698151L;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public KikiResponse message(String message) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        this.put(&quot;message&quot;, message);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        return this;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    public KikiResponse data(Object data) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        this.put(&quot;data&quot;, data);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        return this;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Override</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public KikiResponse put(String key, Object value) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        super.put(key, value);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        return this;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    public String getMessage() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        return String.valueOf(get(&quot;message&quot;));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    public Object getData() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        return get(&quot;data&quot;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h4 id="创建Security配置类"><a href="#创建Security配置类" class="headerlink" title="创建Security配置类"></a>创建Security配置类</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.sxdx.spring.security.oauth2.config;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.context.annotation.Bean;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.security.crypto.password.PasswordEncoder;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">@EnableWebSecurity</span></pre></td></tr><tr><td class="code"><pre><span class="line">public class KikiSecurityConfig extends WebSecurityConfigurerAdapter &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;**</span></pre></td></tr><tr><td class="code"><pre><span class="line">     * Spring Security内部实现好的 BCryptPasswordEncoder。</span></pre></td></tr><tr><td class="code"><pre><span class="line">     * BCryptPasswordEncoder的特点就是，对于一个相同的密码，每次加密出来的加密串都不同</span></pre></td></tr><tr><td class="code"><pre><span class="line">     *&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Bean</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public PasswordEncoder passwordEncoder() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        return new BCryptPasswordEncoder();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<blockquote>
<p>KikiSecurityConfig类添加了@EnableWebSecurity注解。并且定义了spring-Security密码验证方式 BCryptPasswordEncoder。</p>
</blockquote>
<h4 id="创建认证服务器配置类"><a href="#创建认证服务器配置类" class="headerlink" title="创建认证服务器配置类"></a>创建认证服务器配置类</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.sxdx.spring.security.oauth2.config;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.context.annotation.Configuration;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.security.crypto.password.PasswordEncoder;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.security.oauth2.config.annotation.configurers.ClientDetailsServiceConfigurer;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.security.oauth2.config.annotation.web.configuration.AuthorizationServerConfigurerAdapter;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.security.oauth2.config.annotation.web.configuration.EnableAuthorizationServer;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;**</span></pre></td></tr><tr><td class="code"><pre><span class="line"> * 认证服务器配置</span></pre></td></tr><tr><td class="code"><pre><span class="line"> *&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">@Configuration</span></pre></td></tr><tr><td class="code"><pre><span class="line">@EnableAuthorizationServer</span></pre></td></tr><tr><td class="code"><pre><span class="line">public class KikiAuthorizationServerConfigurer extends AuthorizationServerConfigurerAdapter &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Autowired</span></pre></td></tr><tr><td class="code"><pre><span class="line">    private PasswordEncoder passwordEncoder;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Override</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public void configure(ClientDetailsServiceConfigurer clients) throws Exception &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        clients.inMemory()</span></pre></td></tr><tr><td class="code"><pre><span class="line">                .withClient(&quot;kiki&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                .secret(passwordEncoder.encode(&quot;123456&quot;))</span></pre></td></tr><tr><td class="code"><pre><span class="line">                .authorizedGrantTypes(&quot;password&quot;, &quot;refresh_token&quot;,&quot;authorization_code&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                .scopes(&quot;all&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                .redirectUris(&quot;http:&#x2F;&#x2F;localhost:8001&#x2F;getCode&quot;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>添加了 @EnableAuthorizationServer来开启认证服务器功能。</p>
<p>重写了 configure(ClientDetailsServiceConfigurer clients) 方法。该方法主要配置了：</p>
<ul>
<li>客户端从认证服务器获取令牌的时候，必须使用client_id为 kiki，client_secret为123456的标识来获取；</li>
<li>该client_id支持 password、authorization_code 模式获取令牌，并且可以通过refresh_token来获取新的令牌；</li>
<li>在获取client_id为kiki的令牌的时候，scope需指定为all，否则将获取失败；</li>
<li>配置了redirectUris，指定了获取code时的重定向地址；</li>
</ul>
<p>如果需要指定多个client，可以继续使用withClient配置。</p>
<h4 id="创建-KikiOauthController-来获取-code"><a href="#创建-KikiOauthController-来获取-code" class="headerlink" title="创建 KikiOauthController 来获取 code"></a>创建 KikiOauthController 来获取 code</h4><blockquote>
<p>就是定义一个方法供 redirectUris 重定向访问</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.sxdx.spring.security.oauth2.controller;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">import com.sxdx.spring.security.oauth2.entity.KikiResponse;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.security.core.Authentication;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.web.bind.annotation.GetMapping;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.web.bind.annotation.RestController;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import javax.servlet.http.HttpServletRequest;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import javax.servlet.http.HttpServletResponse;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">@RestController</span></pre></td></tr><tr><td class="code"><pre><span class="line">public class KikiOauthController &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    @GetMapping(value &#x3D; &quot;&#x2F;getCode&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public KikiResponse getCode(HttpServletRequest request, HttpServletResponse response)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        return new KikiResponse()</span></pre></td></tr><tr><td class="code"><pre><span class="line">                .put(&quot;code&quot;,request.getParameter(&quot;code&quot;))</span></pre></td></tr><tr><td class="code"><pre><span class="line">                .put(&quot;state&quot;,request.getParameter(&quot;state&quot;));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    @GetMapping(&quot;&#x2F;authentication&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public Object authentication(Authentication authentication)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        return authentication;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h4 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h4><p>1、 浏览器访问如下地址（参数说明参考上一节博客）<br><a href="http://localhost:8001/oauth/authorize?response_type=code&amp;client_id=kiki&amp;redirect_uri=http://localhost:8001/getCode&amp;state=state" target="_blank" rel="noopener">http://localhost:8001/oauth/authorize?response_type=code&amp;client_id=kiki&amp;redirect_uri=http://localhost:8001/getCode&amp;state=state</a><br>访问后页面如下：</p>
<p><img src="/images/oauth2/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%99%BB%E5%BD%95.png" alt="浏览器登录.png"></p>
<p>2、 输入任意用户名，密码为 123456，规则在KikiUserDetailService中已经定义。点击 sign in。</p>
<p><img src="/images/oauth2/%E6%8E%88%E6%9D%83%E7%A0%81%E6%A8%A1%E5%BC%8F-%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BA%BA%E5%B7%A5%E6%8E%88%E6%9D%83.png" alt="授权码模式-浏览器人工授权.png"></p>
<p>3、 选择 Approve ，点击Authorize按钮。</p>
<p><img src="/images/oauth2/%E6%8E%88%E6%9D%83%E7%A0%81-%E8%BF%94%E5%9B%9Ecode.png" alt="授权码-返回code.png"></p>
<p>发现我们已经获取到了code，其中state参数，没有具体意义，在浏览器访问时输入，返回code时原样一同返回。</p>
<p>4、 通过code，获取token。使用postman发送如下请求POST请求 localhost:8001/oauth/token</p>
<p><img src="/images/oauth2/%E6%8E%88%E6%9D%83%E7%A0%81-%E8%8E%B7%E5%8F%96token.png" alt="授权码-获取token.png"></p>
<p>填入获取的code 参数，grant_type为固定值，redirect_uri需要与第1步相同，其余参数在KikiAuthorizationServerConfigurer已经定义。</p>
<p>除此之外还需要设置请求头</p>
<p><img src="/images/oauth2/%E6%8E%88%E6%9D%83%E7%A0%81-%E8%AF%B7%E6%B1%82%E5%A4%B4.png" alt="授权码-请求头.png"></p>
<p>key为Authorization，value为Basic加上client_id:client_secret经过base64加密后的值（可以使用<a href="http://tool.chinaz.com/Tools/Base64.aspx）" target="_blank" rel="noopener">http://tool.chinaz.com/Tools/Base64.aspx）</a></p>
<p><img src="/images/oauth2/%E6%8E%88%E6%9D%83%E7%A0%81-%E5%8A%A0%E5%AF%86%E8%AF%B7%E6%B1%82%E5%A4%B4.png" alt="授权码-加密请求头.png"></p>
<p>5、 发送请求，获取token</p>
<p><img src="/images/oauth2/%E6%8E%88%E6%9D%83%E7%A0%81-%E8%BF%94%E5%9B%9Etoken.png" alt="授权码-返回token.png"></p>
<p>至此，授权码模式已经结束，可通过获取到的token访问资源服务器。一个授权码只能获取一次token，再次访问将会报错。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &quot;error&quot;: &quot;invalid_grant&quot;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &quot;error_description&quot;: &quot;Invalid authorization code: a8VfVM&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>6、通过token获取资源</p>
<p><img src="/images/oauth2/token%E8%8E%B7%E5%8F%96%E8%B5%84%E6%BA%90401.png" alt="token获取资源401.png"></p>
<p>虽然令牌是正确的，但是无法访问/authentication，所以我们必须配置资源服务器，让客户端可以通过合法的令牌来获取资源。<br>资源服务器的配置也很简单，只需要在配置类上使用@EnableResourceServer注解标注即可：</p>
<p>新建资源服务器配置类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.sxdx.spring.security.oauth2.config;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.context.annotation.Configuration;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.security.config.annotation.web.builders.HttpSecurity;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.security.oauth2.config.annotation.web.configuration.EnableResourceServer;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.security.oauth2.config.annotation.web.configuration.ResourceServerConfigurerAdapter;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">@Configuration</span></pre></td></tr><tr><td class="code"><pre><span class="line">@EnableResourceServer</span></pre></td></tr><tr><td class="code"><pre><span class="line">public class KikiResourceServerConfig extends ResourceServerConfigurerAdapter &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>但在添加资源服务器后重启服务，再次重复请求过程，返回：</p>
<p><img src="/images/oauth2/%E9%85%8D%E7%BD%AEOrder.png" alt="配置Order.png"></p>
<p>这是因为security配置服务器与资源服务器有加载优先级，需要确保security配置服务器先于资源服务器加载。我们按Ctrl点击 @EnableResourceServer，再点击 @Import(ResourceServerConfiguration.class)<br>可以看到资源服务器默认Order是3</p>
<p><img src="/images/oauth2/%E8%B5%84%E6%BA%90%E6%9C%8D%E5%8A%A1%E5%99%A8Order.png" alt="资源服务器Order.png"></p>
<p>所以我们在 KikiSecurityConfig 上添加@Order(2)即可。spring 中数字越小说明优先级越高。完整的 KikiSecurityConfig 如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.sxdx.spring.security.oauth2.config;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.context.annotation.Bean;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.core.annotation.Order;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.security.crypto.password.PasswordEncoder;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">@Order(2)</span></pre></td></tr><tr><td class="code"><pre><span class="line">@EnableWebSecurity</span></pre></td></tr><tr><td class="code"><pre><span class="line">public class KikiSecurityConfig extends WebSecurityConfigurerAdapter &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;**</span></pre></td></tr><tr><td class="code"><pre><span class="line">     * Spring Security内部实现好的 BCryptPasswordEncoder。</span></pre></td></tr><tr><td class="code"><pre><span class="line">     * BCryptPasswordEncoder的特点就是，对于一个相同的密码，每次加密出来的加密串都不同</span></pre></td></tr><tr><td class="code"><pre><span class="line">     *&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Bean</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public PasswordEncoder passwordEncoder() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        return new BCryptPasswordEncoder();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>再次重复以上步骤：</p>
<p><img src="/images/oauth2/authentication%E8%AF%B7%E6%B1%82.png" alt="authentication请求.png"></p>
<h3 id="密码模式（resource-owner-password-credentials）"><a href="#密码模式（resource-owner-password-credentials）" class="headerlink" title="密码模式（resource owner password credentials）"></a>密码模式（resource owner password credentials）</h3><p> 密码模式比起授权码模式来说，相对简单些。我们在postman中请求：localhost:8001/oauth/token?grant_type=password&amp;username=garnett&amp;password=123456</p>
<p> <img src="/images/oauth2/unsupported_grant_type.png" alt="unsupported_grant_type.png"></p>
<p> 这是因为密码模式需要用到 AuthenticationManager。</p>
<h4 id="注入AuthenticationManager"><a href="#注入AuthenticationManager" class="headerlink" title="注入AuthenticationManager"></a>注入AuthenticationManager</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.sxdx.spring.security.oauth2.config;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.context.annotation.Bean;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.core.annotation.Order;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.security.authentication.AuthenticationManager;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.security.crypto.password.PasswordEncoder;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">@Order(2)</span></pre></td></tr><tr><td class="code"><pre><span class="line">@EnableWebSecurity</span></pre></td></tr><tr><td class="code"><pre><span class="line">public class KikiSecurityConfig extends WebSecurityConfigurerAdapter &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;**</span></pre></td></tr><tr><td class="code"><pre><span class="line">     * Spring Security内部实现好的 BCryptPasswordEncoder。</span></pre></td></tr><tr><td class="code"><pre><span class="line">     * BCryptPasswordEncoder的特点就是，对于一个相同的密码，每次加密出来的加密串都不同</span></pre></td></tr><tr><td class="code"><pre><span class="line">     *&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Bean</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public PasswordEncoder passwordEncoder() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        return new BCryptPasswordEncoder();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;**</span></pre></td></tr><tr><td class="code"><pre><span class="line">     * 密码模式需要用到</span></pre></td></tr><tr><td class="code"><pre><span class="line">     * @return</span></pre></td></tr><tr><td class="code"><pre><span class="line">     * @throws Exception</span></pre></td></tr><tr><td class="code"><pre><span class="line">     *&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Bean</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public AuthenticationManager authenticationManagerBean() throws Exception &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        return super.authenticationManagerBean();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<blockquote>
<p>注入了authenticationManagerBean 对象。</p>
</blockquote>
<h4 id="修改认证服务器"><a href="#修改认证服务器" class="headerlink" title="修改认证服务器"></a>修改认证服务器</h4><p>接下来修改KikiAuthorizationServerConfigurer认证服务器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.sxdx.spring.security.oauth2.config;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">import com.sxdx.spring.security.oauth2.service.KikiUserDetailService;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.context.annotation.Configuration;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.core.annotation.Order;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.security.authentication.AuthenticationManager;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.security.crypto.password.PasswordEncoder;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.security.oauth2.config.annotation.configurers.ClientDetailsServiceConfigurer;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.security.oauth2.config.annotation.web.configuration.AuthorizationServerConfigurerAdapter;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.security.oauth2.config.annotation.web.configuration.EnableAuthorizationServer;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.security.oauth2.config.annotation.web.configurers.AuthorizationServerEndpointsConfigurer;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;**</span></pre></td></tr><tr><td class="code"><pre><span class="line"> * 认证服务器配置</span></pre></td></tr><tr><td class="code"><pre><span class="line"> *&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">@EnableAuthorizationServer</span></pre></td></tr><tr><td class="code"><pre><span class="line">@Configuration</span></pre></td></tr><tr><td class="code"><pre><span class="line">public class KikiAuthorizationServerConfigurer extends AuthorizationServerConfigurerAdapter &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Autowired</span></pre></td></tr><tr><td class="code"><pre><span class="line">    private PasswordEncoder passwordEncoder;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Autowired</span></pre></td></tr><tr><td class="code"><pre><span class="line">    private AuthenticationManager authenticationManager;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Autowired</span></pre></td></tr><tr><td class="code"><pre><span class="line">    private KikiUserDetailService userDetailService;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Override</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public void configure(AuthorizationServerEndpointsConfigurer endpoints)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            throws Exception &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        endpoints.authenticationManager(authenticationManager).</span></pre></td></tr><tr><td class="code"><pre><span class="line">        userDetailsService(userDetailService);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Override</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public void configure(ClientDetailsServiceConfigurer clients) throws Exception &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        clients.inMemory()</span></pre></td></tr><tr><td class="code"><pre><span class="line">                .withClient(&quot;kiki&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                .secret(passwordEncoder.encode(&quot;123456&quot;))</span></pre></td></tr><tr><td class="code"><pre><span class="line">                .authorizedGrantTypes(&quot;password&quot;, &quot;refresh_token&quot;,&quot;authorization_code&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                .scopes(&quot;all&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                .redirectUris(&quot;http:&#x2F;&#x2F;localhost:8001&#x2F;getCode&quot;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<blockquote>
<p>重写了configure(AuthorizationServerEndpointsConfigurer endpoints) 。</p>
</blockquote>
<h4 id="演示-1"><a href="#演示-1" class="headerlink" title="演示"></a>演示</h4><p>重启服务，再次获取token：</p>
<p> <img src="/images/oauth2/%E5%AF%86%E7%A0%81%E6%A8%A1%E5%BC%8F-%E8%8E%B7%E5%8F%96token.png" alt="密码模式-获取token.png"></p>
<p> 通过token获取资源：</p>
<p>  <img src="/images/oauth2/%E5%AF%86%E7%A0%81%E6%A8%A1%E5%BC%8F-token%E8%8E%B7%E5%8F%96%E8%B5%84%E6%BA%90.png" alt="密码模式-token获取资源.png"></p>
<p>在这里发现一个问题，就是上面密码模式获取到了对应的资源，我一开始以为万事大吉了。<br>当再次启动服务并先通过密码模式获取token，继而通过token获取资源/authentication时发现再次报401错误了。多次试验发现规律：<br>先用密码模式的token获取资源就会报401。<br>先用授权码模式获取的token来请求资源没问题，这个之后再通过密码模式获取资源就也变正常了。</p>
<p>解决方法：在KikiSecurityConfig中添加如下配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span></pre></td></tr><tr><td class="code"><pre><span class="line">protected void configure(HttpSecurity http) throws Exception &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    http.requestMatchers()</span></pre></td></tr><tr><td class="code"><pre><span class="line">            .antMatchers(&quot;&#x2F;oauth&#x2F;**&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            .and()</span></pre></td></tr><tr><td class="code"><pre><span class="line">            .authorizeRequests()</span></pre></td></tr><tr><td class="code"><pre><span class="line">            .antMatchers(&quot;&#x2F;oauth&#x2F;**&quot;).authenticated()</span></pre></td></tr><tr><td class="code"><pre><span class="line">            .and()</span></pre></td></tr><tr><td class="code"><pre><span class="line">            .csrf().disable();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>至此，密码模式介绍完毕！</p>
<p>不过添加这个后申请授权码页面会报403，所以需要确认下授权码模式和密码模式是否可以共存。待研究后再更新文章。</p>
<p>关于上面的问题，各种尝试后终于解决：修改ikiSecurityConfig中添加如下配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http.requestMatchers()</span></pre></td></tr><tr><td class="code"><pre><span class="line">                .antMatchers(&quot;&#x2F;oauth&#x2F;**&quot;,&quot;&#x2F;login&#x2F;**&quot;,&quot;&#x2F;logout&#x2F;**&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                .and()</span></pre></td></tr><tr><td class="code"><pre><span class="line">                .authorizeRequests()</span></pre></td></tr><tr><td class="code"><pre><span class="line">                .antMatchers(&quot;&#x2F;oauth&#x2F;**&quot;).authenticated()</span></pre></td></tr><tr><td class="code"><pre><span class="line">                .and()</span></pre></td></tr><tr><td class="code"><pre><span class="line">                .csrf().disable()</span></pre></td></tr><tr><td class="code"><pre><span class="line">                .formLogin().permitAll();</span></pre></td></tr></table></figure>

<p>至此，我们的项目已经同时支持授权码模式、密码模式了。</p>
<h3 id="客户端模式（client-credentials）"><a href="#客户端模式（client-credentials）" class="headerlink" title="客户端模式（client credentials）"></a>客户端模式（client credentials）</h3><p>这里简单介绍下客户端模式：这种模式直接根据client的id和密钥即可获取token，无需用户参与。这种模式比较合适消费api的后端服务，不支持refresh token。</p>
<p>我们修改KikiAuthorizationServerConfigurer 的configure(ClientDetailsServiceConfigurer clients)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">clients.inMemory()</span></pre></td></tr><tr><td class="code"><pre><span class="line">        .withClient(&quot;kiki&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        .secret(passwordEncoder.encode(&quot;123456&quot;))</span></pre></td></tr><tr><td class="code"><pre><span class="line">        .authorizedGrantTypes(&quot;password&quot;, &quot;refresh_token&quot;,&quot;authorization_code&quot;,&quot;client_credentials&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        .autoApprove(true)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        .scopes(&quot;all&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        .redirectUris(&quot;http:&#x2F;&#x2F;localhost:8001&#x2F;getCode&quot;)</span></pre></td></tr></table></figure>
<p>添加kiki这个client对client_credentials的支持，但是注意：client_credentials和refresh_token是互斥的。以下演示可以证明：</p>
<h4 id="演示-2"><a href="#演示-2" class="headerlink" title="演示"></a>演示</h4><p>通过postman获取token：<a href="http://localhost:8001/oauth/token?grant_type=client_credentials&amp;client_id=kiki&amp;state=state" target="_blank" rel="noopener">http://localhost:8001/oauth/token?grant_type=client_credentials&amp;client_id=kiki&amp;state=state</a></p>
<p><img src="/images/oauth2/%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%A8%A1%E5%BC%8F%E8%8E%B7%E5%8F%96token.png" alt="客户端模式获取token.png"></p>
<p>（别忘记添加Authorization请求头）其中 grant_type 固定为 client_credentials，返回的token信息与授权码、密码模式获取的比较发现少了refresh_token。<br>这也证明了client_credentials模式不支持refresh_token。</p>
<p>接下来通过token获取资源：</p>
<p><img src="/images/oauth2/%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%A8%A1%E5%BC%8Ftoken%E8%8E%B7%E5%8F%96%E8%B5%84%E6%BA%90.png" alt="客户端模式token获取资源.png"></p>
<h3 id="授权码模式扩展"><a href="#授权码模式扩展" class="headerlink" title="授权码模式扩展"></a>授权码模式扩展</h3><h4 id="使用自定义登录页"><a href="#使用自定义登录页" class="headerlink" title="使用自定义登录页"></a>使用自定义登录页</h4><h4 id=""><a href="#" class="headerlink" title=""></a></h4><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>现在我们的项目就同时支持授权码模式、密码模式以及客户端模式了。一般来说，安全性最好的是授权码模式<br>即外部系统访问我们的系统使用授权码模式（无需提供给他们用户名密码），内部可信系统直接使用密码模式、或者客户端模式即可。</p>
<h2 id="postman-oauth2-调试使用技巧"><a href="#postman-oauth2-调试使用技巧" class="headerlink" title="postman oauth2 调试使用技巧"></a>postman oauth2 调试使用技巧</h2><p>在授权码调试过程中，我们需要用到浏览器和postman。来回切换十分麻烦。其实postman提供了很好的调试方法：</p>
<p><img src="/images/oauth2/postman-oauth2-%E6%8E%88%E6%9D%83%E7%A0%811.png" alt="postman-oauth2-授权码1.png"></p>
<p>点击 Get New Access Token 按钮配置获取授权码获取token。</p>
<p><img src="/images/oauth2/postman-oauth2-%E6%8E%88%E6%9D%83%E7%A0%812.png" alt="postman-oauth2-授权码2.png"></p>
<p>按引导操作即可模拟操作。这个稍微研究下就会了，密码模式大同小异，不再演示了。</p>
<p>参考链接：<br><a href="https://mrbird.cc/Spring-Security-OAuth2-Guide.html" target="_blank" rel="noopener">https://mrbird.cc/Spring-Security-OAuth2-Guide.html</a><br><a href="http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html</a></p>
]]></content>
      <categories>
        <category>OAuth2</category>
        <category>Spring-Security</category>
      </categories>
      <tags>
        <tag>OAuth2</tag>
        <tag>Spring-Security</tag>
      </tags>
  </entry>
  <entry>
    <title>spring security oauth2 基础知识</title>
    <url>/2019/12/08/spring-security-oauth2-01/</url>
    <content><![CDATA[<div class="note info">
            <p>OAuth（开放授权）是一个开放标准，允许用户授权第三方移动应用访问他们存储在另外的服务提供者上的信息，而不需要将用户名和密码提供给第三方移动应用或分享他们数据的所有内容，OAuth2.0是OAuth协议的延续版本，但不向后兼容OAuth 1.0即完全废止了OAuth1.0。</p>
          </div>

<div class="note info">
            <p>OAuth是一种用来规范令牌（Token）发放的授权机制，主要包含了四种授权模式：授权码模式、简化模式、密码模式和客户端模式。Spring Security OAuth2对这四种授权模式进行了实现.</p>
          </div>

<h2 id="名词定义"><a href="#名词定义" class="headerlink" title="名词定义"></a>名词定义</h2><p>（1）Third-party application：第三方应用程序，本文中又称”客户端”（client）。<br>（2）HTTP service：HTTP服务提供商，本文中简称”服务提供商”。<br>（3）Resource Owner：资源所有者。<br>（4）User Agent：用户代理，本文中就是指浏览器。<br>（5）Authorization server：认证服务器，即服务提供商专门用来处理认证的服务器。<br>（6）Resource server：资源服务器，即服务提供商存放用户生成的资源的服务器。它与认证服务器，可以是同一台服务器，也可以是不同的服务器。</p>
<p>目前只用到过授权码模式、密码模式。另外两种不怎么常见。</p>
<h2 id="授权码模式"><a href="#授权码模式" class="headerlink" title="授权码模式"></a>授权码模式</h2><p>授权码模式（authorization code）是功能最完整、流程最严密的授权模式。它的特点就是通过客户端的后台服务器，与”服务提供商”的认证服务器进行互动。</p>
<p><img src="/images/oauth2/%E6%8E%88%E6%9D%83%E7%A0%81%E6%A8%A1%E5%BC%8F.png" alt="授权码模式"> </p>
<p>*步骤如下：<br>（A）用户打开客户端以后，客户端要求用户给予授权。<br>（B）用户同意给予客户端授权。<br>（C）客户端使用上一步获得的授权，向认证服务器申请令牌。<br>（D）认证服务器对客户端进行认证以后，确认无误，同意发放令牌。<br>（E）客户端使用令牌，向资源服务器申请获取资源。<br>（F）资源服务器确认令牌无误，同意向客户端开放资源。</p>
<ol>
<li>A步骤中，客户端申请认证的URI，包含以下参数：</li>
</ol>
<ul>
<li>response_type：表示授权类型，必选项，此处的值固定为”code”</li>
<li>client_id：表示客户端的ID，必选项</li>
<li>redirect_uri：表示重定向URI，可选项</li>
<li>scope：表示申请的权限范围，可选项</li>
<li>state：表示客户端的当前状态，可以指定任意值，认证服务器会原封不动地返回这个值。</li>
</ul>
<ol start="2">
<li>C步骤中，服务器回应客户端的URI，包含以下参数：</li>
</ol>
<ul>
<li>code：表示授权码，必选项。该码的有效期应该很短，通常设为10分钟，客户端只能使用该码一次，否则会被授权服务器拒绝。该码与客户端ID和重定向URI，是一 一对应关系。</li>
<li>state：如果客户端的请求中包含这个参数，认证服务器的回应也必须一模一样包含这个参数。</li>
</ul>
<ol start="3">
<li>D步骤中，客户端向认证服务器申请令牌的HTTP请求，包含以下参数：</li>
</ol>
<ul>
<li>grant_type：表示使用的授权模式，必选项，此处的值固定为”authorization_code”。</li>
<li>code：表示上一步获得的授权码，必选项。</li>
<li>redirect_uri：表示重定向URI，必选项，且必须与A步骤中的该参数值保持一致。</li>
<li>client_id：表示客户端ID，必选项。</li>
<li>client_id：表示客户端ID，必选项。</li>
</ul>
<h2 id="密码模式"><a href="#密码模式" class="headerlink" title="密码模式"></a>密码模式</h2><p>   密码模式（Resource Owner Password Credentials Grant）中，用户向客户端提供自己的用户名和密码。客户端使用这些信息，向认证服务器索要授权。</p>
<p><img src="/images/oauth2/%E5%AF%86%E7%A0%81%E6%A8%A1%E5%BC%8F.png" alt="密码模式"></p>
<p>步骤如下：<br>（A）用户向客户端提供用户名和密码。<br>（B）客户端将用户名和密码发给认证服务器，向后者请求令牌。<br>（C）认证服务器确认无误后，向客户端提供访问令牌。</p>
<p>B步骤中，客户端发出的HTTP请求，包含以下参数：</p>
<ul>
<li>grant_type：表示授权类型，此处的值固定为”password”，必选项。</li>
<li>username：表示用户名，必选项。</li>
<li>password：表示用户的密码，必选项。</li>
<li>scope：表示权限范围，可选项。</li>
</ul>
<h2 id="客户端模式"><a href="#客户端模式" class="headerlink" title="客户端模式"></a>客户端模式</h2><p> 这种模式直接根据client的id和密钥即可获取token，无需用户参与。这种模式比较合适消费api的后端服务，不支持refresh token</p>
<h2 id="简化模式（implicit）"><a href="#简化模式（implicit）" class="headerlink" title="简化模式（implicit）"></a>简化模式（implicit）</h2><p> 这种模式比授权码模式少了code环节，回调url直接携带token，这种模式的使用场景是基于浏览器的应用<br> 这种模式基于安全性考虑，建议把token时效设置短一些，不支持refresh token</p>
<h2 id="Spring-Security-OAuth2"><a href="#Spring-Security-OAuth2" class="headerlink" title="Spring Security OAuth2"></a>Spring Security OAuth2</h2><p>Spring框架对OAuth2协议进行了实现，<br>Spring Security OAuth2主要包含认证服务器和资源服务器这两大块的实现：</p>
<p><img src="/images/oauth2/spring-security-oauth2.png" alt="spring-security-oauth2"></p>
<p>认证服务器主要包含了四种授权模式的实现和Token的生成与存储；<br>资源服务器主要是在Spring Security的过滤器链上加了OAuth2AuthenticationProcessingFilter过滤器，即使用OAuth2协议发放令牌认证的方式来保护我们的资源。</p>
<h2 id="补充知识：关于scope参数的说明（小黄人语录）"><a href="#补充知识：关于scope参数的说明（小黄人语录）" class="headerlink" title="补充知识：关于scope参数的说明（小黄人语录）"></a>补充知识：关于scope参数的说明（小黄人语录）</h2><div class="note success">
            <p>a服务 resourceId ： a<br>b服务 resourceId ： b</p><p>Client1：clientid: client1 ,scopse: read,      resourceId:a,b<br>Client2：clientid: client2 ,scopse: read,write,resourceId:a,b</p><p>a服务 某个方法加 @PreAuthorize(“#oauth2.hasScope(‘read’)”)<br>b服务 某个方法加 @PreAuthorize(“#oauth2.hasScope(‘write’)”)</p><p>那么: client1这个客户端就只能访问a服务和b服务的加了read标识的方法<br>      client2这个client就能同时访问加了read 和 write的方法</p><p>每个服务都应该有个 resourceId，新建 clientDetails 的时候也可以指定 resourceId，不指定就能访问所有，指定了只能访问指定的，访问其他的就会抛异常</p>
          </div>


<p><em>下一章演示代码实例</em></p>
<p>参考链接：<br><a href="https://mrbird.cc/Spring-Security-OAuth2-Guide.html" target="_blank" rel="noopener">https://mrbird.cc/Spring-Security-OAuth2-Guide.html</a><br><a href="http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html</a></p>
]]></content>
      <categories>
        <category>OAuth2</category>
        <category>Spring-Security</category>
      </categories>
      <tags>
        <tag>OAuth2</tag>
        <tag>Spring-Security</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown基础语法</title>
    <url>/2019/11/29/markdown-study/</url>
    <content><![CDATA[<h1 id="MarkDown基础语法"><a href="#MarkDown基础语法" class="headerlink" title="MarkDown基础语法"></a>MarkDown基础语法</h1><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">用法:</span></pre></td></tr><tr><td class="code"><pre><span class="line"># 一级标题</span></pre></td></tr><tr><td class="code"><pre><span class="line">## 二级标题</span></pre></td></tr></table></figure>



<h2 id="段落及区块引用"><a href="#段落及区块引用" class="headerlink" title="段落及区块引用"></a>段落及区块引用</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">用法:</span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt; 高亮练习...</span></pre></td></tr></table></figure>

<p>效果如下:</p>
<blockquote>
<p>高亮练习…</p>
</blockquote>
<a id="more"></a>

<h2 id="链接和图片"><a href="#链接和图片" class="headerlink" title="链接和图片"></a>链接和图片</h2> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">用法:</span></pre></td></tr><tr><td class="code"><pre><span class="line">1、打开一个页面</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&lt;a href&#x3D;&quot;https:&#x2F;&#x2F;www.cnblogs.com&#x2F;&quot; target&#x3D;&quot;_blank&quot;&gt;新页面跳转到博客园&lt;&#x2F;a&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">2、当前页面打开</span></pre></td></tr><tr><td class="code"><pre><span class="line">	[当前页面跳转到博客园](https:&#x2F;&#x2F;www.cnblogs.com&#x2F;&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">3、图片</span></pre></td></tr><tr><td class="code"><pre><span class="line">	![图片](https:&#x2F;&#x2F;upload-images.jianshu.io&#x2F;upload_images&#x2F;703764-605e3cc2ecb664f6.jpg?imageMogr2&#x2F;auto-orient&#x2F;strip%7CimageView2&#x2F;2&#x2F;w&#x2F;1240)</span></pre></td></tr></table></figure>
<p> 效果如下:</p>
<p> <a href="https://www.cnblogs.com/" target="_blank">新页面跳转到博客园</a></p>
<p><a href="https://www.cnblogs.com/" target="_blank" rel="noopener">当前页面跳转到博客园</a></p>
<p><img src="https://upload-images.jianshu.io/upload_images/703764-605e3cc2ecb664f6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片"></p>
<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">用法:(*或+或-标识)</span></pre></td></tr><tr><td class="code"><pre><span class="line">*	段落1</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	&gt;段落2沙发士大夫撒旦</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	暗示法法师</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">*	段落2</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	&gt; sdfsasfa</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">* 	段落3</span></pre></td></tr></table></figure>

<ul>
<li><p>段落1</p>
<blockquote>
<p>段落2沙发士大夫撒旦</p>
</blockquote>
<p>暗示法法师</p>
</li>
<li><p>段落2</p>
<blockquote>
<p>sdfsasfa</p>
</blockquote>
</li>
<li><p>段落3</p>
</li>
</ul>
<h3 id="有序列表练习"><a href="#有序列表练习" class="headerlink" title="有序列表练习:"></a>有序列表练习:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">用法:</span></pre></td></tr><tr><td class="code"><pre><span class="line">1. 1</span></pre></td></tr><tr><td class="code"><pre><span class="line">2. 2</span></pre></td></tr><tr><td class="code"><pre><span class="line">3. 3</span></pre></td></tr></table></figure>

<ol>
<li>1</li>
<li>2</li>
<li>3</li>
</ol>
<h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">用法:</span></pre></td></tr><tr><td class="code"><pre><span class="line">*** </span></pre></td></tr><tr><td class="code"><pre><span class="line">或者</span></pre></td></tr><tr><td class="code"><pre><span class="line">---</span></pre></td></tr></table></figure>

<p>效果如下:</p>
<hr>
<h2 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h2><blockquote>
<p>使用*或_包裹即可。使用单一符号标记的效果是斜体，使用两个符号标记的效果是加粗</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">用法:</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">*这里是斜体*</span></pre></td></tr><tr><td class="code"><pre><span class="line">_这里是斜体_</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">**这里是加粗**</span></pre></td></tr><tr><td class="code"><pre><span class="line">__这里是加粗__</span></pre></td></tr></table></figure>
<p>效果如下:</p>
<p><em>这里是斜体</em><br><em>这里是斜体</em></p>
<p><strong>这里是加粗</strong><br><strong>这里是加粗</strong></p>
<h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><blockquote>
<p>使用反引号 `</p>
</blockquote>
<p>一行代码:</p>
<p><code>source.registerCorsConfiguration(&quot;/**&quot;, cors);</code></p>
<p>多行代码:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Bean</span></pre></td></tr><tr><td class="code"><pre><span class="line">   public CorsWebFilter corsFilter() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       UrlBasedCorsConfigurationSource source &#x3D; new UrlBasedCorsConfigurationSource(new PathPatternParser());</span></pre></td></tr><tr><td class="code"><pre><span class="line">       CorsConfiguration cors &#x3D; new CorsConfiguration();</span></pre></td></tr><tr><td class="code"><pre><span class="line">       cors.setAllowCredentials(true);</span></pre></td></tr><tr><td class="code"><pre><span class="line">       cors.addAllowedOrigin(CorsConfiguration.ALL);</span></pre></td></tr><tr><td class="code"><pre><span class="line">       cors.addAllowedHeader(CorsConfiguration.ALL);</span></pre></td></tr><tr><td class="code"><pre><span class="line">       cors.addAllowedMethod(CorsConfiguration.ALL);</span></pre></td></tr><tr><td class="code"><pre><span class="line">       source.registerCorsConfiguration(&quot;&#x2F;**&quot;, cors);</span></pre></td></tr><tr><td class="code"><pre><span class="line">       return new CorsWebFilter(source);</span></pre></td></tr><tr><td class="code"><pre><span class="line">   &#125;</span></pre></td></tr></table></figure>
<h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">用法</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">|序号(左对齐)|姓名(居中)|年龄(右对齐)|</span></pre></td></tr><tr><td class="code"><pre><span class="line">|:---|:---:|---:|</span></pre></td></tr><tr><td class="code"><pre><span class="line">|1   |张三  |23 |</span></pre></td></tr><tr><td class="code"><pre><span class="line">|2   |李四  |33 |</span></pre></td></tr></table></figure>

<blockquote>
<p>说明:默认居左,对中间使用几个-没有要求</p>
</blockquote>
<p>:--- 表示文字居左</p>
<p>---: 表示文字居右</p>
<p>:---: 表示文字居中。</p>
<table>
<thead>
<tr>
<th align="left">序号(左对齐)</th>
<th align="center">姓名(居中)</th>
<th align="right">年龄(右对齐)</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="center">张三</td>
<td align="right">23</td>
</tr>
<tr>
<td align="left">2</td>
<td align="center">李四</td>
<td align="right">33</td>
</tr>
</tbody></table>
<h2 id="特殊字符-使用时需要在前面加转义字符"><a href="#特殊字符-使用时需要在前面加转义字符" class="headerlink" title="特殊字符:使用时需要在前面加转义字符 \"></a>特殊字符:使用时需要在前面加转义字符 \</h2><p>需要处理的特殊字符有:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\   反斜线</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#96;   反引号</span></pre></td></tr><tr><td class="code"><pre><span class="line">*   星号</span></pre></td></tr><tr><td class="code"><pre><span class="line">_   底线</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;&#125;  花括号</span></pre></td></tr><tr><td class="code"><pre><span class="line">[]  方括号</span></pre></td></tr><tr><td class="code"><pre><span class="line">()  括弧</span></pre></td></tr><tr><td class="code"><pre><span class="line">#   井字号</span></pre></td></tr><tr><td class="code"><pre><span class="line">+   加号</span></pre></td></tr><tr><td class="code"><pre><span class="line">-   减号</span></pre></td></tr><tr><td class="code"><pre><span class="line">.   英文句点</span></pre></td></tr><tr><td class="code"><pre><span class="line">!   惊叹号</span></pre></td></tr></table></figure>

<p>例如:</p>
<p>\ 需要 写为 \\</p>
<p>* 需要 写为 \*</p>
<blockquote>
<p>参考:<a href="https://www.jianshu.com/p/335db5716248" target="_blank" rel="noopener">https://www.jianshu.com/p/335db5716248</a></p>
</blockquote>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
</search>
